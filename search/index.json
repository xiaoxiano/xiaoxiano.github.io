[{"content":"Let’s Encrypt 是一个免费的，自动化的，开放的证书颁发机构（CA），为公众的利益而运行。 它是一项由 Internet Security Research Group（ISRG）提供的服务。\nacme.sh 则是实现了 acme 协议, 可以从 letsencrypt 生成免费的证书。\nLet’s Encrypt 速率限制 每个注册网域(Registered Domain) 的凭证颁发数量，限制为每周50 张 更新凭证受到重复凭证限制，一个星期内仅能颁发5 张重复的凭证。 网域验证失败限制，对于每个帐号每域名每小时5 次的限制。 每个IP 位置每3 个小时最多能建立10 个帐号。 如果你达到速率限制，你只能等待一个星期直到速率限制结束。\n安装 acme.sh curl https://get.acme.sh | sh sudo apt install socat # 安装socat 选择默认 CA Zerossl 从 acme.sh v 3.0.0 开始，acme.sh 使用 Zerossl 作为默认 ca，您必须先注册帐户（一次），然后才能颁发新证书。\n~/.acme.sh/acme.sh –register-account -m xxxx@xxxx.com Let\u0026rsquo;s Encrypt 如果需要更换Let\u0026rsquo;s Encrypt可以使用如下命令：\n~/.acme.sh/acme.sh --set-default-ca --server letsencrypt 通过 http 方式申请证书 Webroot模式 这种方式需要你的服务器上面已经部署了网站环境。Acme 自动在你的网站根目录下放置一个文件,来验证你的域名所有权,完成验证. 然后就可以生成证书了.\n# 生成 RSA 证书： ~/.acme.sh/acme.sh --issue -d example.com -w /var/www/_letsencrypt/ # 生成 ECC 证书： ~/.acme.sh/acme.sh --issue -d example.com -w /var/www/_letsencrypt/ --keylength ec-256 /var/www/_letsencrypt/ 为 example.com 站点下的 /.well-known/acme-challenge/ 证书请求目录。\n80 端口空闲的证书申请方式 ~/.acme.sh/acme.sh --issue -d example.com --standalone 安装证书到指定文件夹 ~/.acme.sh/acme.sh --installcert -d mydomain.com --key-file /root/cert/private.key --fullchain-file /root/cert/cert.crtchmod -R 755 /root/cert 上面的 /root/private.key 以及 /root/cert.crt 是把密钥和证书安装到 /root 目录，并改名为 private.key 和 cert.crt。\n更新 更新证书 手动更新 ~/.acme.sh/acme.sh --renew -d example.com --force 自动更新 安装 acme.sh 时会自动创建一个 cronjob，每天定期检查所有证书，如果证书需要更新会自动更新证书。 通过 crontab -l 查看 crontab 任务:\n46 0 * * * \u0026#34;/root/.acme.sh\u0026#34;/acme.sh --cron --home \u0026#34;/root/.acme.sh\u0026#34; \u0026gt; /dev/null 更新 Acme 脚本 升级 Acme.sh 到最新版本\n~/.acme.sh/acme.sh --upgrade 如果你不想手动升级, 可以开启自动升级:\n~/.acme.sh/acme.sh --upgrade --auto-upgrade 通过 DNS 方式申请证书(通常只支持付费域名) 几个 CA 的简单对比\n功能 LE Buypass ZeroSSL SSL.com Google Public CA 有效期 90 天 180 天 90 天 90 天 90 天 多域名 支持 支持，最多 5 个 支持 收费支持 支持 泛域名 支持 不支持 支持 收费支持 支持 Rate Limit 有 有 收费无 未知 有 GUI 管理 否 否 有 有 无 ECC 证书链 否 否 有 未知 无 客户支持 社区 收费 收费 收费 收费 cloudflare 使用全局 API 密钥，您需要登录您的 Cloudflare 帐户以获取您的API 密钥\nexport CF_Key=\u0026#34;sdfsdfsdfljlbjkljlkjsdfoiwje\u0026#34; export CF_Email=\u0026#34;xxxx@sss.com\u0026#34; 颁发证书：\n./acme.sh --issue --dns dns_cf -d example.com -d www.example.com 阿里云 DNS 申请方式 export Ali_Key=\u0026#34;abcd\u0026#34; export Ali_Secret=\u0026#34;xxxxxxxxxx\u0026#34; # RSA 证书 acme.sh --issue --dns dns_ali -d example.com -d *.example.com # ECC 证书 acme.sh --issue --dns dns_ali -d example.com -d *.example.com --keylength ec-256 Ali_Key 和 Ali_Secret 需要从阿里云RAM访问控制中获取。\nDNSPod 申请方式 export DP_Id=\u0026#34;1234\u0026#34; export DP_Key=\u0026#34;xxxxxxxxxxx\u0026#34; acme.sh --issue --dns dns_dp -d example.com -d www.example.com 文档 如何颁发证书\n使用 DNS API\n选项和参数\n","date":"2022-10-24T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/acme/","title":"acme.sh 申请证书"},{"content":"前言 云是我们常用的服务，aws是头部厂商，但我们还有更多选择，以降低价格。即使aws有高昂且复杂的定价，仍有很多人使用，所以本文也将介绍。\n目前我在使用的云存储是Backblaze B2（兼容S3 API），价格仅为 Amazon S3、Microsoft Azure 和 Google Cloud 的1/4。\n我们同样需要一个CDN缓存加速（cloudflare 与传统 CDN 不同，CloudFlare 处理对网站的所有请求，能够阻止针对网站的攻击，可以再加到传统CDN前作为防护），CDN在用户第一次请求后，会在接近用户的区域缓存源服务器的静态资源（没人请求不缓存，不主动和服务器保持同步），后续访问就更加快速，并降低服务器压力，可以使用cloudfront免费套餐，如果每月传出超过 1T 数据，可以考虑使用 bunny CDN。\nS3 Bucket桶 桶就类似于根文件夹，其命名必须全局性唯一。也就是说，如果别人已经创建了命为X的Bucket，你就不能再用X作为桶的名字了。\nEvents事件 在S3中，可以定义很多事件及其处理函数。比如当文件被创建，修改，删除，复制时，触发Lambda。这样就可以构建Event Driven Architecture，比如：新文件到S3 -\u0026gt; 触发Lambda处理函数 -\u0026gt; 处理结束后通知AppSync/GraphQL API -\u0026gt; 通知用户文件已经处理完毕。\nS3费用决定因素 官方：存储和管理数据时需要考虑六大 Amazon S3 成本组成：存储定价、请求和数据检索定价、数据传输和传输加速定价、数据管理和分析定价、复制定价以及使用 S3 Object Lambda 处理数据的价格。\n通常我们关注存储类型、储存数据量、请求量、数据传输的费用。\n存储类型 S3 标准 S3 标准是一种通用对象存储平台，提供较低的延迟和较高的吞吐量，因此非常适合各种使用案例，包括云应用程序、动态网站、内容分发、移动和游戏应用程序以及大数据分析。\nS3 智能分层 ——通用选它 S3 智能分层可自动识别并将不常访问的数据（30天内未访问的数据）移动到成本较低的基础架构中。当访问不频繁层中的对象时，它会自动移回更高性能层，并且30天时钟重新启动。在访问模式发生变化时，在两个访问层（频繁访问层和不频繁访问层）之间移动数据来实现自动节省成本，非常适用于访问模式未知或不断变化的数据。\nS3标准-IA（不频繁访问）——备份选它 S3 Standard-IA 适用于不常访问（超过30天访问一次）、但在需要时要求快速访问的数据。提供与“S3 标准”相同的高持久性、高吞吐量和低延迟，成本较低且性能出色使得“S3标准–IA”很适合长期存储和备份，以及用作灾难恢复文件的数据存储。\nS3 单区域 - IA（不频繁访问） S3标准-IA 的单区域存储，此类别不会自动在至少三个AZ上存储数据。\nS3 Glacier 即时检索 Amazon S3 Glacier Instant Retrieval 是一种归档存储类，可以为很少访问（超过90天访问一次）且需要毫秒级检索速度的长期数据提供最低成本的存储。\nS3 Glacier 灵活检索（前称为 S3 Glacier） S3 Glacier Flexible Retrieval 为每年访问 1—2 次且异步检索的归档数据提供低成本存储，数据检索时间可配置，从数分钟到数小时不等。\nAmazon S3 Glacier 深度档案 支持长期保留和数字化保存一年可能访问一到两次的数据，数据检索时间为 12 小时以内。\ncloudfront Origin domain ：源域，选S3 存储桶需配置Alternate Domain Names作为加速站点，写自己解析过的域名即为加速的站点\nAmazon S3 存储桶– DOC-EXAMPLE-BUCKET.s3.us-west-2.amazonaws.com\n配置为网站的 Amazon S3 存储桶– https://DOC-EXAMPLE-BUCKET.s3-website.us-west-2.amazonaws.com\nMediaStore 容器– examplemediastore.data.mediastore.us-west-1.amazonaws.com\nMediaPackage 端点– examplemediapackage.mediapackage.us-west-1.amazonaws.com\n亚马逊 EC2 实例– ec2-203-0-113-25.compute-1.amazonaws.com\nElastic Load Balancing 负载均衡器– example-load-balancer-1234567890.us-west-2.elb.amazonaws.com\n您自己的网络服务器– https://www.example.com\n自选ip失败经历 查看官方公布的ip段（我们只需要边缘节点ip-\u0026ldquo;CLOUDFRONT_REGIONAL_EDGE_IP_LIST\u0026rdquo;，因为GLOBAL站点会自动判断离边缘节点最近的区域和进行健康检查，再连到边缘节点） 由于给的ip是CIDR格式，我们需要转换。先JSON转列表。然后CIDR转ip（因为在线转不支持批量转换，所以建议下载这个工具），重命名为cidr2ip.exe，新建cidrs.txt，把列表复制进去，cmd执行cidr2ip -f cidrs.txt可得很大一列ip。最后ip批量查询，下载后可以看到ip地区，复制你所需地区的ip（查询速度会很慢，我的vps是日本的，排在最前面，运气很好没有查询很久）。\n创建Cloud front测速链接\naws首页搜索cloud front 创建分配\n源域填写能测速的地址：cachefly.cachefly.net 协议：匹配查看器\n自动压缩对象：No 缓存键和源请求（选择第二项）：Legacy cache settings 创建\n复制得到的域名 打开显示为测速地址即可（需要等到部署完成）\n使用CloudflareSpeedTest](https://github.com/XIU2/CloudflareSpeedTest)优选ip， cmd输入CloudflareST.exe -url xxxxxxxxxxx.cloudfront.net/100mb.test发现ip全部不能用。 aws查看vcpu ","date":"2022-10-07T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/cloud-service/","title":"云服务"},{"content":"主要参考文章\nAPI API的英文即 Application Programming Interface 首字母的缩写，直译过来的意思就是：程序之间的接口。我更倾向于把API理解为，程序之间的合约。有关 API 是什么及它的意义这里就不展开讲了。\nchrome浏览器开发者工具\n勾选上谷歌开发者工具的preserve log，保留上一个页面接口调用信息，从而方便我们查看\nPostman 界面导航说明 请求：\nparams：get请求传参。\nAuthrization：鉴权\nHeaders：请求头\naccept:客户端接收的数据类型。\ncontent-type:客户端发送给服务器的数据类型\nuser-agent:客户端的类型\nxmlhttprequest:异步请求\nBody：Post请求传参\nnone：没有参数\nform-data：文件上传（包含键值对和文件上传）\nx-www-from-urlencodeed：表单请求（键值对）\nraw：使用原始数据格式请求（JSON，XML，HTML，Text，Javascript）\nbinary：二进制文件上传。\nPre-request-script：请求之前的脚本。\nTests；请求之后的脚本。\nSetting：设置\nCookies：用于自动管理Cookie的功能\n响应：\nBody：返回的信息\nPretty（各种格式查看返回数据）\nRaw（文本格式）\nPreview（网页）\nCookie：响应Cookie\ntoken鉴权码：\ncsrf_token：一般情况下有效期是7-15天。\naccess_token：一般情况下有效期是10分钟-2小时\nHeaders：响应头\nTestResults：测试结果\n200 响应码\nGET 请求 GET 请求基本操作 （1）点击主界面「+」号，新建一个请求页\n（2）选择 GET 请求命令\n（3）输入 API 地址\n在 GoRest API 设计中 GET 请求无需鉴权，所有我们直接点击「Send」即可远程调取服务器信息。\n如果我们只想看调取其中一位用户的信息应该怎么办呢？我们可以在 API URL 中带上参数。\n带参数的 GET 请求 如果我们想查询 ID 为 2043 的用户信息，我们只需要在请求页面中的 Params(参数) 标签页的 KEY - VALUE 内填写对应的参数即可，之后 Postman 会自动在 API URL 中生成你填写的参数，使 URL 带上参数 GET 请求。\nhttps://gorest.co.in/public/v1/users?id=2043 设置完成后，点击「Send」\n我们可以看到，返回值中仅包含我们请求的 user id 为 2043 的用户信息。\nGET 请求中的多条件查询 有时，我们需要使用 API 进行多条件查询操作，比如想找 name 值为 kalacloud.com ，同时 gender 值为 male 的用户。（特别提示：此格式是通用写法，但最终要看 API 的开发者如何约定调用方式）\nBaseURL + ResourceName + ? + key1 = value1 + \u0026amp; + key 2 = value 2 …… 主 URL 之后使用 ? 连接参数，参数与参数之间使用 \u0026amp; 连接符连接。\nhttps://gorest.co.in/public-api/users/?name=kalacloud.com\u0026amp;gender=male 当然，我们可以直接在 Postman 的 Params 中直接填写 KEY - VALUE\n让 Postman 帮我们生成，然后点击「Send」\n可以看到 API GET 调取了我们设定的两个 VALUE 值的 data 信息。\n特别提示，你可以点击右上角的「Bulk Edit」进行参数的批量编辑\nPOST 请求 POST 方式一：模仿浏览器\n在发送一个get请求之后，postman会自动保存cookis，我们只需复制 Payload 的数据格式到 body ，复制 x-csrf-token 到 Headers ，发送这个 POST 请求\n自动方式可以参考\nPOST 方式二：鉴权 在 Authorization 中添加鉴权方式和密钥，postman会自动添加到Headers，按照api写入所需body，发送这个 POST 请求\n用 Postman 发送第一个 PUT 更新请求 PUT 请求一般用于更新服务器已有资源，如果服务器中没有对应的资源，那么 PUT 会创建相应的资源（特别提醒：虽然 PUT 有创建新资源的功能，但是否能创建成功，最终取决于你调用的 API 是否支持此功能）\n打开你的 Postman 我们来创建一个 PUT 请求。\n点击「+」号，新建一个请求页\n请求类型选择「PUT」\n根据第6节我们使用 POST 请求创建的资源 ID 为 1475 ，又根据 GoRest API 的文档得知，修改资源的 API 地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PUT 修改 ID 为 1475 资源的请求地址应该写：\nhttps://gorest.co.in/public/v1/users/1475 选择在 Body 标签中填写 JSON 格式的资源修改信息。我们将 1475 中的邮箱由\nJiangChuan@kalacloud.com 修改为 Hi@kalacloud.com，所以我们在 Body 中填写以下代码。\n{ \u0026#34;name\u0026#34;: \u0026#34;kalacloud\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;Male\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;Hi@kalacloud.com\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;Active\u0026#34; } 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 PUT 请求 如上图所示，可以看到红4位置 响应代码返回 200 ，这说明 PUT 请求已经执行成功。 返回的 Body 信息中，email 字段已经更新为 Hi@kalacloud.com 用 Postman 发送第一个 PATCH 更新请求 PATCH 请求一般用于服务器资源的部分更新，它相对于 PUT 提交的数据更少，不用提整个数据，只需要提交需要修改的字段即可。有关 PUT 和 PATCH 的更多区别，可查看本文第9节。\n打开你的 Postman 我们来创建一个 PATCH 请求。\n点击「+」号，新建一个请求页\n请求类型选择「PATCH」\n根据第6节我们使用 POST 请求创建的资源 ID 为 1475 ，又根据 GoRest API 的文档得知，修改资源的 API 地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PATCH 修改 ID 为 1475 资源的请求地址应该写，到这里都和 PUT 请求修改资源的方法一样。\nhttps://gorest.co.in/public/v1/users/1475 选择在 Body 标签中填写 JSON 格式的资源修改信息。上一节我们已经将 ID 为 1475 资源的邮箱改为 Hi@kalacloud.com ，接着我们用 PATCH 请求把这个邮箱改为\nHelloWord@kalacloud.com { \u0026#34;email\u0026#34;:\u0026#34;HelloWord@kalacloud.com\u0026#34; } 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 PATCH 请求 如上图所示，可以看到红4位置 响应代码返回 200 ，这说明 PATCH 请求已经执行成功。\n返回的 Body 信息中，email 字段已经更新为\nHelloWord@kalacloud.com PUT 和 PATCH 的区别 在 HTTP 协议中，PUT 和 PATCH 都是用于更新服务器资源的命令，但他们有着不同的格式和用途。\nPUT 请求：一般用于更新服务器已有资源，如果服务器中没有对应的资源，那么 PUT 会创建相应的资源（特别提醒：虽然 PUT 有创建新资源的功能，但是否能创建最终取决于你调用的 API 是否支持此功能）\nPATCH 请求：用于局部更新服务器现有资源，它不用像 PUT 更新资源中的一点点也要提交所有字段信息，PATCH 更新哪个字段就提交哪个字段的更新信息即可。\n举例说明PUT 和 PATCH 的区别：\n同样是更新资源中的 Email 信息，PUT 需要带上资源中的所有信息，然后在更新（上图）\n而 PATCH 则仅需要提交更新部分，即仅提交邮箱信息即可（下图）\n那么，如果 PUT 像 PATCH 一样仅提交资源的局部信息会发生什么呢？会 400 报错。\nPUT 不论修改多少，必须把修改资源的全部字段写全，否则会 400 报错。\n用 Postman 发送第一个 DELETE 删除请求 我们在上文讲了获取(GET)，创建(POST)，更新(PUT / PATCH) 请求，接着我们来说说删除(DELETE) 请求。顾名思义，DELETE 请求执行可删除整个资源。我们来直接实践一次你就明白了。\n打开你的 Postman ，跟随本教程一起创建一个 DELETE 请求。\n点击「+」号，新建一个请求页\n请求类型选择「DELETE」\n我们来把上文刚刚创建的 ID 为 1475 的资源彻底删掉。根据 GoRest API 的文档得知，删除资源的 API 请求地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PATCH 删除 ID 为 1475 资源的请求地址应该写：\nhttps://gorest.co.in/public/v1/users/1475 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 DELETE 请求，删除对应的资源。 如上图所示，提交 DELETE 请求后，响应代码为 204 ，返回的 body 为空，删除成功。\n特别提示：在 GoRest 的文档说明中，特别说了 DELETE 删除返回值的状态。\nAPI 返回状态具体是怎么样的，还要看 API 的开发者是如何约定的，并非只有返回 200 才是成功的。\nPostman 中的全局变量、环境变量、集合变量的设置 Postman 设置变量的意义 Postman 里有多种变量，我们可以把某些重要的值抽象出来变成变量，方便我们做场景 / 条件切换。比如，我们可以把 baseURL 抽出来，在环境变量里设置「生产环境变量」和「测试环境变量」，之后，我们只需要切换标签即可快速将数据从一个环境切换到另一个环境中，非常方便。\nPostman 常用的三种变量形式 全局变量：全局变量一旦声明，即可应用到 Postman 中所有测试的 API 中。任何请求都可以直接使用全局变量，它的作用域是全局的。 环境变量：Postman 的环境变量可以理解为一组选项，当这组环境变量选项被选中时，才会生效，特别适合「生产环境」和「测试环境」之间的切换等应用场景。 集合变量：集合变量是针对集合（Collections）生效的，一个集合下可能有 N 条 API 请求，集合变量可以一次修改集合下的所有变量数值。 以上三种变量的作用域从大到小为 全局 集合 环境，当三个变量形式同时作用于一个 API 测试条时，Postman 会优先使用最小作用域变量。\n如何在 Postman 设置全局变量与环境变量 新建一个请求页，点击右上角的「小眼睛」进入变量设置页。 页面上方为「环境变量」，我们点击编辑设置环境变量名为「卡拉云_API 测试环境」 VARIABLE 设置为 baseURL，INITIAL VALUE 设置为 https://gorest.co.in ，保存之后我们就可以使用 {{baseURL}} 变量来替代 API URL 了。 页面下方为「全局变量」，VARIABLE 设置为 kalacloud_id，INITIAL VALUE 设置为 2312 (2312 为 GoRest 中的一个已存在的用户信息 ID)，保存后我们就可以使用 {{kalacloud_id}} 变量来替代 ID 值了。 我们来一起测一下刚刚设置好的「全局变量」和「环境变量」是否生效。\n新建一个 GET 请求页，地址栏填入： {{baseURL}}/public/v1/users?id={{kalacloud_id}} 点击「Send」 返回响应代码为 200 说明请求成功，返回的 Body 信息是 ID 为 2312 的用户信息，说明全局和环境变量已生效。\n如何在 Postman 设置集合变量 集合变量是指应用在整个集合所有请求中的变量，集合变量优先与其他变量应用与请求，也就是说如果有集合变量，那么其他变量与集合变量相冲突的化，优先执行集合变量。\n集合变量很适合临时修改整个集合中的变量，来针对集合进行测试。\n打开你的 Postman，我们一起操作一遍。\n选中一个集合，点击集合标题右侧「\u0026hellip;」选择编辑。 进入集合设置页，选择 Variables 设置集合变量 此时，整个集合下所有请求页，都应用了此集合变量。 如何使用 Postman Pre-request scripts 预请求脚本 Pre-request scripts 预请求脚本是在 API 请求之前执行的脚本，我们可以临时更改请求的某些变量。一般预请求脚本有这么两种常见的应用场景。(1)设置动态请求头信息。 (2)设置动态请求参数信息。比如，当我们要请求一个与时间有关的资源时，我们可以在预请求脚本中添加 timestamp 字段，这是一个动态值，我们可以通过前置请求脚本来实现。\n举例说明：比如我们要在 header 中包含一个时间戳，我们可以这样操作\n在 Pre-request scripts 中添加获取时间戳的代码 pm.environment.set(\u0026#34;TimeStampHeader\u0026#34;,new Date()); 在 header 中添加预脚本中的变量 TimeStampHeader 当请求时，Postman 会先执行预脚本获取时间戳，然后再将时间戳赋予到 header 中 timestamp 值中。 接着我们来执行这条 GET 请求，打开控制控制台，在控制台中，可以看到 Request Headers 中包含我们刚刚设置的时间戳 「timestamp」特别提示：有关控制台的讲解，在本教程第14节。 附：常用的 Pre-request scripts ：\n获取变量\n//通用语法 postman.getGlobalVariable(\u0026#34;key\u0026#34;); //获取全局变量 postman.getEnvironmentVariable(\u0026#34;key\u0026#34;); //获取环境变量 //postman native app 特有语法 pm.globals.get(\u0026#34;key\u0026#34;); //获取全局变量 pm.environment.get(\u0026#34;key\u0026#34;); //获取环境变量 设置变量\n//通用语法 postman.setGlobalVariable(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置全局变量 postman.setEnvironmentVariable(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置环境变量 //postman native app 特有语法 pm.globals.get(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置全局变量 pm.environment.get(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置环境变量 清除变量\n//通用语法 postman.clearGlobalVariable(\u0026#34;key\u0026#34;); //清除全局变量 postman.clearEnvironmentVariable(\u0026#34;key\u0026#34;); //清除环境变量 //postman native app 特有语法 pm.globals.unset(\u0026#34;key\u0026#34;); //清除全局变量 pm.environment.unset(\u0026#34;key\u0026#34;); //清除环境变量 将数组、嵌套对象存储到全局\u0026amp;环境变量中\n//将数组储存到环境变量中 var array = [1, 2, 3, 4]; postman.setEnvironmentVariable(\u0026#34;array\u0026#34;, JSON.stringify(array)); //将嵌套对象储存到环境变量中 var obj = { a: [1, 2, 3, 4], b: { c: \u0026#39;val\u0026#39; } }; postman.setEnvironmentVariable(\u0026#34;obj\u0026#34;, JSON.stringify(obj)); //从环境变量中获取数组对象 var array = JSON.parse(postman.getEnvironmentVariable(\u0026#34;array\u0026#34;)); //从环境变量中获取嵌套对象/json对象 var obj = JSON.parse(postman.getEnvironmentVariable(\u0026#34;obj\u0026#34;)); 如何创建 Postman Tests 测试脚本 - Postman 断言功能 在 Postman 中 Pre-request 和 Tests 是两兄弟，一个是在调用前执行（Pre-request），一个是在调用后执行（Tests），我们可以在 Tests 中使用 JavaScript 校验代码协助我们验证结果，可以说 Tests 是 Postman 的断言功能\nPostman Tests 断言的实际应用 Postman 状态类断言 1.我们首先创建一个 GET 请求，然后点击 Postman 中 Tests 标签，进入断言设置。\n2.我们可以在右侧已经预设好的断言代码，我们先点击「Status code: Code is 200」，可以看到预设的代码直接写入编辑框。这段代码的意思是，如果执行调用，服务器返回响应代码为 200 时，判断为 PASS 即调用成功。\n3.点击「Send」执行 GET 请求，返回的断言可以在 Test Results 中看到结果。\n4.绿色的 PASS，说明服务器返回的响应代码为 200 ，调用成功。\nPostman 结果比较类断言 我们再添加一条带有变量的 JavaScript 断言设置，比较预期结果和实际返回结果之间是否一致。\n我们刚刚 GET 请求了 ID 2312 的用户信息，其中 name 的值为 kalacloud\n那么我们接下来写一个 JS 判断预期与返回结果是否一致。即预期为 name 的值为「kalacloud」，写断言自动判断返回结果的name值是否也是「kalacloud」\n1.在 Tests 选项卡右侧选择「Response body:JSON value check」，我们来检测 ID 为 2312 的返回值中，name 的值是否为 kalacloud\n2.我们将「Your Test Name」替换为「检查 ID 为 2312 的 name 返回值为 kalacloud」让这条测试的名字直接反应出我们想测试的内容。\n3.使用\njsonData.data[0].name 代替jsonData.value ，即检测第一个返回值中的 name 的 value\n4.检测返回值：在 to.eql() 中输入待检测值 \u0026quot;kalacloud\u0026quot;，即需要检测的 text。\n5.代码如下，你可以复制并根据你的情况简单修改，然后在 Postman 中，跟随教程一起测试。\n特别注意：这里的 ID = 2312 是我这里的情况，你需要根据你的情况进行相应修改。\npm.test(\u0026#34;Status code is 200\u0026#34;, function () { pm.response.to.have.status(200); }); pm.test(\u0026#34;检查 ID 为 2312 的 name 返回值为 kalacloud\u0026#34;, function () { var jsonData = pm.response.json(); pm.expect(jsonData.data[0].name).to.eql(\u0026#34;kalacloud\u0026#34;); }); 如何在 Postman 中使用控制台 控制台可以非常直观的显示当前调用的一系列信息，我们可以在「菜单 → view → Show Postman Console」或者点击 Postman 左下角的「Console」图标，打开控制台。\n我们可以在 Tests 测试脚本中加入 console.log 来显示我们需要在控制台显示的调用信息。\n如上图，我们在 Test 脚本中加入以下代码\nconsole.log(\u0026#34;本次测试 id 值为\u0026#34;,pm.variables.get(\u0026#34;kalacloud_id\u0026#34;)); 可以显示隐藏在变量下面的具体变量值，方便我们测试时，进行相应的判断。\n如何使用 Runner 批量执行测试，批量更换变量测试 当我们有一组 API 且这一组之间相互关联的关系，使用手动测试效率非常低。这时，我们就要用到 Postman 的批量执行（Runner）功能，Runner 不仅可以批量执行 API 调用，还可以批量更换变量。掌握此方法，大幅度提升 API 测试效率。\n打开你的 Postman ，跟随本教程一起操作一遍吧。\n本次批量 API 测试，我们先导入一个 CSV 文件，文件中包含四组等待新建的用户信息，将 CSV 文件导入 Runner 中待用。 新建 POST 调用页，在 Body 里写上创建用户所需信息，所有值使用变量替代，这些变量将从 CSV 中读取。 新建 GET 调用页，使用 email 作为查询 KEY 进行查询，如果上一步 POST 执行成功，那么 GET 就能成功查询到新建用户对应的 email，查询到表示 POST 创建成功。 在「卡拉云_kalacloud.com_批量测试」这个集合中设置 Tests 中设置全局断言，每当一个调用执行完毕时，进行 Tests 一次判断。 pm.test(\u0026#34;Status code is 200\u0026#34;, function () { pm.response.to.have.status(200); }); 打开「卡拉云_kalacloud.com_批量测试」合集的「Run Collection」的设置页 Iterations：这是测试组，我们 CSV 文件中有 4 组测试条目 Delay：延迟，一般填 2000 毫秒，太密集的请求，容易被服务器拒绝 Data：这里选择我们刚刚的 CSV 文件：kalacloud_users.csv 导入测试数据 点击 RUN 蓝色按钮开始执行批量测试 从上图可以看到，Postman 按顺序提交了 POST 请求和 GET 请求，并连续测试了从 CSV 文件导入的 4 组数据。一键批量测试，相当高效。\n","date":"2022-08-04T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/test/","title":"测试接口"},{"content":"购买配件 配件 用途 mq2 pro 续航版 提升头戴舒适度，可以按照自己需要选择没有续航的 磁吸镜片 近视适用 USB3.0串流线 玩steam的游戏需要和电脑串流 网络 国内quest2用户应该已经具备上外网的条件，不再赘述。\nquest2需要无线网络链接，解决网络问题一般有以下方式：\n刷路由器，这个方式比较直接，我认为日常不适用的场景较多，所以我没用。 电脑热点，下文介绍。 下面介绍通用的sstap方法。\n打开科学上网，允许局域网连接。\n下载sstap，我使用的1.1.0.1版本。\n配置并打开sstap 打开热点，并打开 网络和Internet设置 -\u0026gt; 更改适配器选项 -\u0026gt; 右键 SSTAP 1 -\u0026gt; 属性 -\u0026gt; 共享 ，然后就可以连热点了。 clash方法\n如果你安装了clash，并且有网线连接电脑，clash TUN模式开热点应该也可以。\n注册，接受邀请领取30美金奖励 使用outlook、gmail等邮箱和原生ip至少提前1天注册facebook账号。\n接受邀请比较麻烦（实际上大多玩家只玩破解版，无需受邀，无需此步骤！），有需要直接去找别人代操作受邀！！以下方式成本过高，作为邀请别人的参考！\n注意：接受邀请也是高风险的操作，由于变换ip和账号资料不完善，依然有可能封号\n我试了多地vps，原生ip也全都出现Ineligible Country​，原因是服务器厂商用的数据中心ip（type是hosting），会被识别屏蔽。所以要用住宅代理（type是isp），由于成本高，服务器厂商几乎不用，只有代理厂商的住宅代理和部分静态住宅代理才可以接受邀请。我搜索了多家代理厂商，价格便宜的只有 911s5 和 iproyal\n代理厂商 特点 价格 911s5 自有软件，pc端指定软件代理，使用简单，ip质量差，部分可以邀请使用 最低28美元/150ip，每ip可用24小时 iproyal 直接给地址端口和用户，所以在国内必须自己搭建国外节点并且中转才能使用，但是ip质量较好、使用舒适。必须实名，不实名很多网站不能访问（包括facebook），而且实名较为耗时 3美元/GB ，paypal入金最低20美元 “以xui为例的中转配置文件”\r// 直接修改\u0026#34;servers\u0026#34;即可使用 { \u0026#34;api\u0026#34;: { \u0026#34;services\u0026#34;: [ \u0026#34;HandlerService\u0026#34;, \u0026#34;LoggerService\u0026#34;, \u0026#34;StatsService\u0026#34; ], \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 62789, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;Socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;proxy.iproyal.com\u0026#34;, \u0026#34;port\u0026#34;: 12325, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34; }, { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: {} }, { \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;blocked\u0026#34; } ], \u0026#34;policy\u0026#34;: { \u0026#34;system\u0026#34;: { \u0026#34;statsInboundDownlink\u0026#34;: true, \u0026#34;statsInboundUplink\u0026#34;: true } }, \u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;inbound-12325\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;ip2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, \u0026#34;protocol\u0026#34;: [ \u0026#34;bittorrent\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;stats\u0026#34;: {} } // 配置文件详解 { \u0026#34;api\u0026#34;: { // api: 提供了一些 API 接口供远程调用 \u0026#34;services\u0026#34;: [ // services: [string] 开启的 API 列表 \u0026#34;HandlerService\u0026#34;, // HandlerService:添加、删除一个入站、出站代理在一个入站代理中添加、删除一个用户 \u0026#34;LoggerService\u0026#34;, // 内置Logger \u0026#34;StatsService\u0026#34; // 内置的数据统计服务 ], \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; // tag: string api中的tag是**出站**代理标识 }, \u0026#34;inbounds\u0026#34;: [ // 入站 -\u0026gt; 路由 不用修改 { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 62789, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, // 任意门,可以监听一个本地端口 \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ], \u0026#34;outbounds\u0026#34;: [ // 出站 ##################此处开始添加################## { // 添加出站节点 \u0026#34;protocol\u0026#34;: \u0026#34;Socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 12325, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34; }, #################此处结束添加################### { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, // 向任意网络发送（正常的）TCP 或 UDP 数据 \u0026#34;settings\u0026#34;: {} }, { \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, // 禁止访问 \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;blocked\u0026#34; } ], \u0026#34;policy\u0026#34;: { \u0026#34;system\u0026#34;: { \u0026#34;statsInboundDownlink\u0026#34;: true, \u0026#34;statsInboundUplink\u0026#34;: true } }, \u0026#34;routing\u0026#34;: { // 路由 -\u0026gt; 出站 \u0026#34;rules\u0026#34;: [ ##################此处开始添加################## { // 添加路由，xui的\u0026#34;inboundTag\u0026#34;规则是\u0026#34;inbound-port\u0026#34; \u0026#34;inboundTag\u0026#34;: [ \u0026#34;inbound-12325\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;ip2\u0026#34;, // -\u0026gt; \u0026#34;outbounds\u0026#34;: {\u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34;} \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, #################此处结束添加################### { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, // -\u0026gt; \u0026#34;api\u0026#34;: {\u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34;} \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, // -\u0026gt; 禁止访问 \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, // -\u0026gt; 禁止访问 \u0026#34;protocol\u0026#34;: [ \u0026#34;bittorrent\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;stats\u0026#34;: {} } 激活 下载Oculus App，quest2联网后配对，配对成功就说明Quest2激活成功了。\n安装第三方应用 便携方式 87vr助手安装热门游戏和应用，安卓apk可以通过QQ发送直接安装。 更多破解应用可以看看极客VR（1元注册）、VR魔趣网。\n常规方式 首先需要开启开发者模式。在Oculus开发者网站创建一个开发者组织，再去Oculus APP菜单 -\u0026gt; 设备 -\u0026gt; 开发者模式 -\u0026gt; 打开 。 下载SideQuest并安装。 下载Oculus ADB驱动。右键单击android_winusb.inf选择“安装”。然后用USB线将头显和电脑连接起来，在头显中点击“允许”。 然后就可以安装apk了。 如果apk附带文件夹，就拖入obb文件夹。 进入头显的未知来源就可以使用了。 SKYBOX 《SkyBox VR》是最优秀的vr视频播放器，而且可以使用本地网络播放电脑上的影片。\nvr影片体积超过10G的很常见，quest2装不了多少，所以放在pc，局域网共享。\n电脑设置开启共享。 无密码的共享 有密码的共享，找到用户名和改密码 共享存放影片的文件夹。(以后删除共享点击图一的“删除访问”) 去quest2 SKYBOX 本地网络查看。 常见问题 恢复出厂设置 手机配对后在app菜单 -\u0026gt; 设备 -\u0026gt; 高级设置 -\u0026gt; 恢复出场设置\n登陆Oculus官网 -\u0026gt; 点头像 -\u0026gt; Oculus settings -\u0026gt; Devices DELETE -\u0026gt; DEVICE DATA\n截图 按住右手柄Oculus Home键（椭圆键） + 扳机按键（食指键）\n","date":"2022-05-14T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/quest2/","title":"quest2入门使用汇总"},{"content":"安装 配置 JDK、安装配置Android Studio\nflutter(windows) flutter安装\nset PUB_HOSTED_URL=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/dart-pub\u0026#34; #配置国内镜像 set FLUTTER_STORAGE_BASE_URL=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/flutter\u0026#34; 安装遇坑 //配置build.gradle(project:android) allprojects { repositories { google() jcenter() maven { url \u0026#34;https://storage.googleapis.com/download.flutter.io\u0026#34; } } } 更新 flutter upgrade flutter doctor 创建 Flutter 项目 dart 变量 # 创建一个变量并将其初始化 var name = \u0026#39;Bob\u0026#39;; # 指定类型 String name = \u0026#39;Bob\u0026#39;; # 如果对象(name)不局限于单一的类型(String),可以将其指定为 Object（或 dynamic）类型 Object name = \u0026#39;Bob\u0026#39;; ? 可空类型 int? a=123; // int? 表示a是一个可空类型 ! 类型断言 a! // a不为空 常量 final 和 const final在被使用到的时候才会进行初始化, 如果只是被定义, 而没有被使用到, 那么这个变量一直没有被初始化 (\u0026lsquo;懒加载\u0026rsquo;); 而const修饰的变量, 一经定义就会在编译期间对其进行初始化\nfinal name = \u0026#39;Bob\u0026#39;; // Without a type annotation final String nickname = \u0026#39;Bobby\u0026#39;; 类型 内置类型 int 整数值 double 浮点数字 String 字符串 bool 布尔类型 List 集合类型 Set 无序集合 Map 字典型 不常用类型 enum　枚举类型,用于表示固定数量的常量值。在switch语句中运行良好。\nObject　对象类型，允许任何类型。\ndynamic　动态类型，不仅接受所有对象，而且还允许所有操作\nvoid main() { dynamic foo=\u0026#34;bar\u0026#34;; print(foo); foo=123; print(foo); } Set　无序集合，主要的功能就是去除数组重复内容 void main(){ List myList=[\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;,\u0026#39;西瓜\u0026#39;,\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;,\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;]; var s=new Set(); s.addAll(myList); print(s); print(s.toList()); } 几乎不用的类型 runes 暴露了字符串的 Unicode 代码点（Unicode 为每个字母、数字和符号定义了一个唯一的数值）。例如，用于表情符号，(😆) 是\\u{1f606}。\nSymbol 表示标识符，例如#。\nvoid main() { assert(Symbol(\u0026#39;bar\u0026#39;)==#bar); } // true 类型转换 String -\u0026gt; int myint = int.parse(myString); String -\u0026gt; double mydouble = double.parse(myString); int -\u0026gt; String myString = myint.toString(); double -\u0026gt; String myString = 3.14159.toStringAsFixed(2); // myString = \u0026#39;3.14\u0026#39; 将 list 映射为 widget List MyList.map((item) =\u0026gt; SomeWidget(item)).toList(); 函数 bool isNoble(int atomicNumber) { // bool:返回类型 return _nobleGases[atomicNumber] != null; } 箭头函数 =\u0026gt;\n=\u0026gt; expr 是 { return expr; }的简写\n参数 命名参数（可传可不传） String printUserInfo(String username, {int age = 0, String sex = \u0026#39;男\u0026#39;}) {//行参，用大括号 if (age != 0) { return \u0026#34;姓名:$username---性别:$sex--年龄:$age\u0026#34;; } return \u0026#34;姓名:$username---性别:$sex--年龄保密\u0026#34;; } print(printUserInfo(\u0026#39;张三\u0026#39;)); //实参 print(printUserInfo(\u0026#39;张三\u0026#39;, age: 20, sex: \u0026#39;未知\u0026#39;)); //实参,命名参数的实参必须传入参数名age: sex: 位置参数（可传可不传） String printUserInfo(String username,[String sex=\u0026#39;男\u0026#39;,int age=0]){ //行参，用中括号 if(age!=0){ return \u0026#34;姓名:$username---性别:$sex--年龄:$age\u0026#34;; } return \u0026#34;姓名:$username---性别:$sex--年龄保密\u0026#34;; } print(printUserInfo(\u0026#39;张三\u0026#39;)); //实参 print(printUserInfo(\u0026#39;小李\u0026#39;,\u0026#39;女\u0026#39;,30)); //实参 运算符 算术运算符\n+(加)　–(减)　-(负)　*(乘)　/(除)　~/(取整)　%（取余）\n关系运算符\n==　！=　\u0026gt;　\u0026lt;　\u0026gt;=　\u0026lt;=\n逻辑运算符\n!(取反)　\u0026amp;\u0026amp;(与)　||(或)\n赋值运算符\n基础赋值运算符　=　??=(为 null 的变量赋值)\n复合赋值运算符　+=　-=　*=　/=　%=　~/=\n其他运算符 ()　使用一个方法\n[]　访问 List\n?[]　访问 List,左侧可以为null\n.　访问成员\n?.　访问成员,左侧可以为null\nif-else的表达式：\ncondition ? expr1 : expr2 如果条件为真，则计算expr1（并返回其值）；否则，计算并返回expr2的值。\nexpr1 ?? expr2 如果expr1不为 null，则返回其值；否则，计算并返回expr2的值。\n类 方法 实例方法 实例方法可以访问实例变量和 this\nimport \u0026#39;dart:math\u0026#39;; class Point { final double x; final double y; Point(this.x, this.y); double distanceTo(Point other) { var dx = x - other.x; var dy = y - other.y; return sqrt(dx * dx + dy * dy); } } get 和 set 特殊方法:实例对象的每一个属性都有一个隐式的 Getter 方法，非 final 属性还会有一个 Setter 方法\nclass Rectangle { double left, top, width, height; Rectangle(this.left, this.top, this.width, this.height); // Define two calculated properties: right and bottom. double get right =\u0026gt; left + width; set right(double value) =\u0026gt; left = value - width; double get bottom =\u0026gt; top + height; set bottom(double value) =\u0026gt; top = value - height; } 抽象类、抽象方法 抽象类常用于定义接口，抽象类常常会包含抽象方法\nabstract class Doer { // Define instance variables and methods... void doSomething(); // Define an abstract method. } class EffectiveDoer extends Doer { void doSomething() { // Provide an implementation, so the method is not abstract here... } } 构造函数 实例化类时会被自动触发\n一般用于初始化操作\n没有返回值\n普通构造函数 构造函数方法名和类名相同\nclass Point { num x, y; Point(num x, num y) { // There\u0026#39;s a better way to do this, stay tuned. this.x = x; this.y = y; } } 简化形式：\nclass Point { num x, y; // Syntactic sugar for setting x and y // before the constructor body runs. Point(this.x, this.y); } 命名构造函数 class Point { num x, y; Point(this.x, this.y); // 命名构造函数，新增代码 Point.origin() { x = 0; y = 0; } } 请记住，命名构造函数不可继承，如果子类想要有 和父类一样的命名构造函数，那就写个同名的（通常也会在子类的命名构造函数里，调用父类的同名命名构造函数）\n调用父类构造函数 如果你的类，继承于父类，那么子类的构造函数，势必要调用父类的构造函数，这时候就要分两种情况：\nDart语言帮你调用父类的无参数构造函数 代码中显式调用父类的构造函数 默认调用调用父类的无参数构造函数 如果你没有显式调用父类的构造函数，并且父类有一个无参数构造函数，那么Dart就会帮你在子类的构造函数方法体的最前面，调用父类的无参数构造函数。当然，后面我们会说道，构造函数分成好几部分来初始化成员变量，调用的顺序如下：\n初始化列表 父类的无参数构造函数 子类的无参数构造函数 当然，如果父类没有无参数构造函数，或者Dart这种隐式调用无法满足你的要求，那就需要显式调用父类的构造函数了\n显式调用父类构造函数 显式调用父类构造函数，应该在初始化列表中完成\nclass Person { String firstName; Person.fromJson(Map data) { print(\u0026#39;in Person\u0026#39;); } } class Employee extends Person { // Person does not have a default constructor; // you must call super.fromJson(data). Employee.fromJson(Map data) : super.fromJson(data) { print(\u0026#39;in Employee\u0026#39;); } } main() { var emp = new Employee.fromJson({}); // Prints: // in Person // in Employee } 初始化列表就是构造函数名的冒号后面，打括号前面的部分。\n初始化列表 初始化列表的执行顺序，在整个构造函数的最前面，它除了可以调用父类的构造函数，还可以在构造函数方法体之前，初始化一些成员变量。\n// Initializer list sets instance variables before // the constructor body runs. Point.fromJson(Map\u0026lt;String, num\u0026gt; json) : x = json[\u0026#39;x\u0026#39;], y = json[\u0026#39;y\u0026#39;] { print(\u0026#39;In Point.fromJson(): ($x, $y)\u0026#39;); } 尤其是初始化那些final修饰的成员变量时，初始化列表很有用，因为在方法体中，不能给final修饰的成员变量赋值，因为在执行方法体的时候，final修饰的成员变量已经不能变了。这个地方很多人犯错。\nimport \u0026#39;dart:math\u0026#39;; class Point { final num x; final num y; final num distanceFromOrigin; Point(x, y) : x = x, y = y, distanceFromOrigin = sqrt(x * x + y * y); } main() { var p = new Point(2, 3); print(p.distanceFromOrigin); } 重定向构造函数 定义构造函数的时候，除了一个普通构造函数，还可以有若干命名构造函数，这些构造函数之间，有时候会有一些相同的逻辑，如果分别书写在各个构造函数中，会有些多余，所以构造函数可以传递。\nclass Point { num x, y; // The main constructor for this class. Point(this.x, this.y); // Delegates to the main constructor. Point.alongXAxis(num x) : this(x, 0); } 传递构造函数，没有方法体，会在初始化列表中，调用另一个构造函数。\n常量构造函数 class ImmutablePoint { static final ImmutablePoint origin = const ImmutablePoint(0, 0); final num x, y; const ImmutablePoint(this.x, this.y); } 如果你的类，创建的对象永远不会改变，你可以在编译期就创建这个常量实例，并且定义一个常量构造函数，并且确保所有的成员变量都是final的。\n工厂构造函数 有时候可能有一种需求，并不需要每次都创建新的类实例，而是每一种情况，只需要一个实例：\nclass Logger { final String name; bool mute = false; // _cache is library-private, thanks to // the _ in front of its name. static final Map\u0026lt;String, Logger\u0026gt; _cache = \u0026lt;String, Logger\u0026gt;{}; factory Logger(String name) { if (_cache.containsKey(name)) { return _cache[name]; } else { final logger = Logger._internal(name); # 调用构造函数 _cache[name] = logger; return logger; } } Logger._internal(this.name); # 定义构造函数 void log(String msg) { if (!mute) print(msg); } } main() { var logger = Logger(\u0026#39;UI\u0026#39;); logger.log(\u0026#39;Button clicked\u0026#39;); } 工厂构造函数，没有权利访问this\n上例的意思是，类中又一个静态缓存_cache保存着一些Logger类实例，创建实例时，给工厂构造函数传递的name，如果在缓存中已经存在，就用缓存中现成的实例，如果没有，就新建一个实例，并且也放到缓存中。\n如此这般，我们可以创建名字为UI / SYS / API 等的实例，然后在debug的时候，如果设置名字为UI的Logger实例的mute为true，就不会打印UI相关的log，而不影响其它两个名字的log。\n扩展 扩展类 extends Extends是典型的OOP类继承。如果 a类 扩展了 b类，则 a类 可以使用或覆盖 b类 中实现的所有属性、变量、函数 。在 Dart 中，一个类只能扩展一个类。 implements 创建另一个类或接口的实现。当 a类 实现 b类 时，必须实现 b类 中定义的所有功能(所有属性、变量、函数)。一个类可以实现多个接口。\nwith mixin使用with关键字，类似于继承，可以扩展多个类。mixins的类只能继承自Object，不能再继承其他类，且不能有构造函数。\n# extends只能扩展一个类，而mixin没有限制，可以一起使用 class Maestro extends Person with Musical, Aggressive, Demented { Maestro(String maestroName) { name = maestroName; canConduct = true; } } super super关键字用于调用父类的对象、方法、构造函数和子类中的属性。\n// 访问父类变量 super.variable_name; // 访问父类方法 super.method_name(); // 转发给超类的构造函数 const MyApp({Key? key}) : super(key: key); 扩展方法 extension FancyNum on num { num plus(num other) =\u0026gt; this + other; num times(num other) =\u0026gt; this * other; } print(5.plus(3)); // Equal to \u0026#34;5 + 3\u0026#34;. print(5.times(8)); // Equal to \u0026#34;5 * 8\u0026#34;. print(2.plus(1).times(3)); // Equal to \u0026#34;(2 + 1) * 3\u0026#34;. 泛型 泛型常用于需要要求类型安全的情况，可以减少代码重复。 @override 注解来表示你重写了一个成员 异步 // 示例：等待返回自己ip import \u0026#39;package:http/http.dart\u0026#39;as http; import \u0026#39;dart:convert\u0026#39;; Future getIPAddress() async { final url =\u0026#39;https://httpbin.org/ip\u0026#39;; var response = await http.get(Uri.parse(url)); String ip = json.decode(response.body)[\u0026#39;origin\u0026#39;]; return ip; } void main() async { final ip = await getIPAddress(); print(ip); } flutter 生命周期 Flutter 中万物皆为Widget，widget类继承自DiagnosticableTree。\nDiagnosticableTree即“诊断树”，主要作用是提供调试信息。\nWidget.createElement() :创建一个Element实例，记为element。\nKey: [Key]是[Widget]、[Element]和[SemanticsNode]的标识符。Key可以保持组件之前的状态，比如在用户滑动时或者修改集合时，决定的条件在canUpdate()方法中。\ncanUpdate(...): newWidget与oldWidget的runtimeType和key同时相等时就会用new widget去更新Element对象的配置，否则就会创建新的Element。\ncreateState():为每一个StatefulElement创建一个State实例。\nelement.mount() :调用createRenderObject创建RenderObject，并使用attachRenderObject将RenderObject关联到Element上。\nStatelessWidget生命周期图 StatefulWidgets更为复杂，使用Getx接管更好用，不再详解\nGetx ###状态管理 ####声明一个反应变量 你有3种方法可以把一个变量变成是 \u0026ldquo;可观察的\u0026rdquo;。\n1 - 第一种是使用 Rx{Type}。\n// 建议使用初始值，但不是强制性的 final name = RxString(\u0026#39;\u0026#39;); final isLogged = RxBool(false); final count = RxInt(0); final balance = RxDouble(0.0); final items = RxList\u0026lt;String\u0026gt;([]); final myMap = RxMap\u0026lt;String, int\u0026gt;({}); 2 - 第二种是使用 Rx，规定泛型 Rx\u0026lt;Type\u0026gt;。\nfinal name = Rx\u0026lt;String\u0026gt;(\u0026#39;\u0026#39;); final isLogged = Rx\u0026lt;Bool\u0026gt;(false); final count = Rx\u0026lt;Int\u0026gt;(0); final balance = Rx\u0026lt;Double\u0026gt;(0.0); final number = Rx\u0026lt;Num\u0026gt;(0) final items = Rx\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;([]); final myMap = Rx\u0026lt;Map\u0026lt;String, int\u0026gt;\u0026gt;({}); // 自定义类 - 可以是任何类 final user = Rx\u0026lt;User\u0026gt;(); 3 - 第三种更实用、更简单、更可取的方法，只需添加 .obs 作为value的属性。\nfinal name = \u0026#39;\u0026#39;.obs; final isLogged = false.obs; final count = 0.obs; final balance = 0.0.obs; final number = 0.obs; final items = \u0026lt;String\u0026gt;[].obs; final myMap = \u0026lt;String, int\u0026gt;{}.obs; // 自定义类 - 可以是任何类 final user = User().obs; 使用值 // controller final count1 = 0.obs; final count2 = 0.obs; int get sum =\u0026gt; count1.value + count2.value; // 由于.obs把变量换成`Rx{Type}`类型，所以需要用.value取值 // 视图 GetX\u0026lt;Controller\u0026gt;( builder: (controller) { print(\u0026#34;count 1 rebuild\u0026#34;); return Text(\u0026#39;${controller.count1.value}\u0026#39;); }, ), GetX\u0026lt;Controller\u0026gt;( builder: (controller) { print(\u0026#34;count 2 rebuild\u0026#34;); return Text(\u0026#39;${controller.count2.value}\u0026#39;); }, ), GetX\u0026lt;Controller\u0026gt;( builder: (controller) { print(\u0026#34;count 3 rebuild\u0026#34;); return Text(\u0026#39;${controller.sum}\u0026#39;); }, ), dio 原理 # dio_mixin.dart 文件中 DioMixin 实现了 Dio abstract class DioMixin implements Dio { @override Future\u0026lt;Response\u0026lt;T\u0026gt;\u0026gt; post\u0026lt;T\u0026gt;( String path, { # path： 请求的url链接 data, # data： 请求数据，例如上传用到的FromData Map\u0026lt;String, dynamic\u0026gt;? queryParameters, # data： 请求数据，例如上传用到的FromData Options? options, # queryParameters： 查询参数 CancelToken? cancelToken, # cancelToken： 用来取消发送请求的token ProgressCallback? onSendProgress, # onSendProgress： 网络请求发送的进度 ProgressCallback? onReceiveProgress, # onSendProgress： 网络请求发送的进度 }) { return request\u0026lt;T\u0026gt;( # 返回request方法 path, data: data, options: checkOptions(\u0026#39;POST\u0026#39;, options), queryParameters: queryParameters, cancelToken: cancelToken, onSendProgress: onSendProgress, onReceiveProgress: onReceiveProgress, ); } } get() post() 等调用时，返回request方法，request 方法对请求参数处理，并返回 fetch 方法，fetch 进行响应数据设定、构建请求流、添加拦截器、请求分发。\n其他 double width = MediaQuery.of(context).size.width; 屏幕宽度\ndouble height = MediaQuery.of(context).size.height; 屏幕高度\n","date":"2022-04-30T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/flutter/","title":"flutter基础备忘录"},{"content":"root（不同手机不同操作，刷机有变砖风险！） 以前手机都是用虚拟机 VMOS Pro，应用权限是有了，但现手机不能自动开屏幕锁自动执行任务，于是只能root。 大概分为以下步骤：\n解bl锁 各品牌手机解锁有所不同，三星、小米、一加、Google pixel等部分厂商官方给解锁。\\\n解锁困难的华为旧机：我用的是github的potatoNV短接解锁，如果其中没有你的手机，直接淘宝不要浪费时间。作者在youtube有教程，照做就好了（视频简介的USB com 1.0连接教程也要看，他的点击DriverSetup操作很快，不要漏了），短接点可以参考这里。获得解锁码搜华为工具箱即可解锁。\n刷rom（系统）、刷入 TWRP recovery 建议不要刷机软件一键刷机，都是垃圾系统，一般就用原系统刷适合你手机的TWRP。新手机找不到官方TWRP去https://unofficialtwrp.com/，点图片左下角手机品牌可以进入分类，收录了全面的非官方TWRP。 \\\n小米为例：在https://xiaomirom.com/下载刷机工具，刷酷安ID乌堆小透明的ROM（另外欧版eu社区版ROM不错，但我的k50至尊版无论刷欧版还是刷gsi均不能使用chrome联网，小米手机已被我拉黑）。然后按照此教程操作，安装选择默认即可，开机后卸载重装magisk。\\\n华为为例：我在https://m.huaweirom.com/rom/找到华为有TWRP的rom，我当时看到网站干净无广告就刷了，是可以用的，此网站应该靠谱。Fastboot模式运行run脚本就行了。\nroot github下载magisk放进手机储存卡（有人建议低版安卓用20.4版本），进入TWRP recovery安装，开机后酷安安装magisk app即可。\nMacroDroid 基础 设置：\n防止系统清理：进入系统最近任务界面，点击应用旁边的小锁，锁定应用不被系统清理 忽略电池优化：依次打开系统设置，应用和通知，应用管理，设置，特殊访问权限，忽略电池优化（直接在设置搜索栏搜索电池也能找到），允许忽略应用 设置启动管理：依次打开系统设置，电池，启动管理，关闭应用自动管理后弹出的对话框中选中：允许自启动，允许关联启动，允许后台活动 权限全部打开 shell shell命令很方便定义操作（点击的坐标可以在手机开发者选项中打开指针位置）。shell命令摘录网站\n#按键事件 input text \u0026lt;string\u0026gt; #输入文本 input keyevent 20 #向下 input keyevent 4 #返回 input keyevent 3 #Home input keyevent 6 #挂机 input keyevent 84 #搜索 input keyevent 26 #电源，息屏 input keyevent 24 #音量+ input keyevent 25 #音量- #模拟点击 input tap 100 100 #滑动 input swipe x1 y1 x2 y2 ms input swipe 100 100 400 100 300 #左往右 input swipe 400 100 100 100 300 #右往左 input swipe 100 100 100 400 300 #上往下 input swipe 100 400 100 100 300 #下往上 input swipe 100 100 400 400 300 #上往下斜 input swipe 400 400 100 100 300 #下往上斜 #长按 input swipe 100 100 100 100 1000 //在 100 100 位置长按 1000毫秒 ","date":"2021-11-24T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/phone-root/","title":"root手机和自动化"},{"content":"本github actions方法已于2022-07-15完全被封，请去仓库看文档 freenom自动续期 Fork luolongfei大佬的freenom库，再添加以下workflow： “点击展开完整代码”\r# 1、Fork 本仓库 # 2、在你 Fork 的本仓库下的 Settings \u0026gt; Secrets 画面追加以下几个 secret 变量： # FREENOM_USERNAME、FREENOM_PASSWORD、MULTIPLE_ACCOUNTS、MAIL_USERNAME、MAIL_PASSWORD、TO、MAIL_ENABLE、TELEGRAM_CHAT_ID、 # TELEGRAM_BOT_TOKEN、TELEGRAM_BOT_ENABLE、NOTICE_FREQ # （注：此处列出了所有可用变量，你只用追加你需要用到的变量，变量的具体含义请参考本项目的 .env 文件中的说明，一般情况下，.env 文件中的某些 # 项存在默认值，如果默认值满足你的需求则可不追加到 Secrets，它们会保持默认） # # 下面定时任务中的时间是世界时间，每天 10:00（本示例已改为2:00） 执行，由于创建虚拟环境会消耗时间，故任务会延迟 30 秒左右执行 # # @Author of yml configuration file: RouRouX \u0026lt;https://github.com/RouRouX\u0026gt; \u0026amp; mybsdc \u0026lt;mybsdc@gmail.com\u0026gt; # ###### end 说明 ###### name: Run it on action on: push: branches: - main schedule: - cron: 00 02 * * * workflow_dispatch: jobs: run-it: runs-on: ubuntu-18.04 name: Run it on action steps: - name: Checkout master uses: actions/checkout@v2 - name: Setup PHP uses: shivammathur/setup-php@v2 with: php-version: \u0026#39;7.2\u0026#39; - name: Setting run: | echo \u0026#39;Renew freenom domain name automatically.\u0026#39; echo \u0026#39;@Author of yml configuration file: RouRouX \u0026lt;https://github.com/RouRouX\u0026gt; \u0026amp; mybsdc \u0026lt;mybsdc@gmail.com\u0026gt;\u0026#39; echo \u0026#39;@Url: https://github.com/luolongfei/freenom\u0026#39; cp .env.example .env if [[ (\u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39; == \u0026#39;\u0026#39; || \u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39; == \u0026#39;\u0026#39;) \u0026amp;\u0026amp; \u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39; == \u0026#39;\u0026#39; ]]; then echo \u0026#39;你在 Github 的当前项目的 Settings \u0026gt; Secrets 画面没有设置任何与账户信息相关的 secret 值，无法正常运行，请添加新的 secret 值，设置 FREENOM_USERNAME 与 FREENOM_PASSWORD，或者设置 MULTIPLE_ACCOUNTS，以及 .env 文件中其它必要项，各项的具体含义与格式参考本项目 .env 文件中的说明。\u0026#39;; fi if [ \u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^FREENOM_USERNAME=.*$/FREENOM_USERNAME=\u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^FREENOM_PASSWORD=.*$/FREENOM_PASSWORD=\u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MULTIPLE_ACCOUNTS=.*$/MULTIPLE_ACCOUNTS=\u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_USERNAME }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_USERNAME=.*$/MAIL_USERNAME=\u0026#39;${{ secrets.MAIL_USERNAME }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_PASSWORD }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_PASSWORD=.*$/MAIL_PASSWORD=\u0026#39;${{ secrets.MAIL_PASSWORD }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TO }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TO=.*$/TO=\u0026#39;${{ secrets.TO }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_ENABLE }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_ENABLE=.*$/MAIL_ENABLE=\u0026#39;${{ secrets.MAIL_ENABLE }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_CHAT_ID }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_CHAT_ID=.*$/TELEGRAM_CHAT_ID=\u0026#39;${{ secrets.TELEGRAM_CHAT_ID }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_BOT_TOKEN }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_BOT_TOKEN=.*$/TELEGRAM_BOT_TOKEN=\u0026#39;${{ secrets.TELEGRAM_BOT_TOKEN }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_BOT_ENABLE }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_BOT_ENABLE=.*$/TELEGRAM_BOT_ENABLE=\u0026#39;${{ secrets.TELEGRAM_BOT_ENABLE }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.NOTICE_FREQ }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^NOTICE_FREQ=.*$/NOTICE_FREQ=\u0026#39;${{ secrets.NOTICE_FREQ }}\u0026#39;/\u0026#34; .env; fi sed -i \u0026#34;s/^ON_GITHUB_ACTIONS=.*$/ON_GITHUB_ACTIONS=true/\u0026#34; .env - name: Run run: | php run # 以下为保活所需step - name: curl id: enable_workflow env: REST_TOKEN: ${{ secrets.REST_TOKEN }} API_ADDRESS: ${{ secrets.API_ADDRESS }} run: | echo \u0026#34;Enable Workflow Start...\u0026#34; curl -X PUT -H \u0026#34;Authorization: token $REST_TOKEN\u0026#34; \u0026#34;$API_ADDRESS\u0026#34; echo \u0026#34;Finished\u0026#34; 在你 Fork 的本仓库下的 Settings -\u0026gt; Secrets 页面追加以下几个secret秘密环境变量\n变量名 含义 默认值 是否必须 备注 FREENOM_USERNAME freenom 账户 - 是 只支持邮箱账户，不支持也不打算支持第三方社交账户登录 FREENOM_PASSWORD freenom 密码 - 是 某些特殊字符可能需要转义，在Github actions环境，请在除字母数字以外的字符前加上“\\”，否则可能无法正确读取密码，此举是防止某些字符在shell命令行被解析，举个例子，比如我密码是fei.,:!~@#$%^\u0026amp;*?233-_abcd^$$，那么写到秘密变量时就应写为fei\\.\\,\\:\\!\\~\\@\\#\\$\\%\\^\\\u0026amp;\\*\\?233\\-\\_abcd\\^\\$\\$。而在普通VPS环境，则只用在密码中的“#”或单双引号前加“\\”，请参考.env.example文件内的注释，应该没人会设置那么变态的密码吧 MULTIPLE_ACCOUNTS 多账户支持 - 否 多个账户和密码的格式必须是“\u0026lt;账户1\u0026gt;@\u0026lt;密码1\u0026gt;|\u0026lt;账户2\u0026gt;@\u0026lt;密码2\u0026gt;|\u0026lt;账户3\u0026gt;@\u0026lt;密码3\u0026gt;”，如果设置了多账户，上面的FREENOM_USERNAME和FREENOM_PASSWORD可不设置 MAIL_USERNAME 机器人邮箱账户 - 是 支持Gmail、QQ邮箱以及163邮箱，尽可能使用163邮箱或者QQ邮箱，而非之前推荐的Gmail。因为谷歌的安全机制，每次在新设备登录 Gmail 都会先被限制，需要手动解除限制才行，而Github Actions每次创建的虚拟环境都会分配一个新的设备IP，相当于每次都是从新设备登录Gmail，而我们不可能每次都去手动为Gmail解除登录限制，所以这种机制会导致无法发出通知邮件。具体的配置方法参考「 配置发信邮箱 」 MAIL_PASSWORD 机器人邮箱密码 - 是 Gmail填密码，QQ邮箱或163邮箱填授权码 TO 接收通知的邮箱 - 是 你自己最常用的邮箱，推荐使用QQ邮箱，用来接收机器人邮箱发出的域名相关邮件 MAIL_ENABLE 是否启用邮件推送功能 true 否 true：启用false：不启用默认启用，如果设为false，不启用邮件推送功能，则上面的MAIL_USERNAME、MAIL_PASSWORD、TO变量变为非必须，可不设置 TELEGRAM_CHAT_ID 你的chat_id - 否 通过发送/start给@userinfobot可以获取自己的id TELEGRAM_BOT_TOKEN 你的Telegram bot的token - 否 TELEGRAM_BOT_ENABLE 是否启用Telegram Bot推送功能 false 否 true：启用false：不启用默认不启用，如果设为true，则必须设置上面的TELEGRAM_CHAT_ID和TELEGRAM_BOT_TOKEN变量 NOTICE_FREQ 通知频率 1 否 0：仅当有续期操作的时候1：每次执行 REST_TOKEN 如后文所示 - 否 保活所需 API_ADDRESS 如后文所示 - 否 保活所需 （注：你只用关注上面表格中的必须项，非必须项可不设置，将保持默认值。更多相关变量的含义、格式以及默认值，请参考本项目的.env.example文件内的注释）\n启用 Actions ，完成。 保活 Fork zhzhzhy/Workflow-Keep-Alive库\n创建 sercets ：\n变量名 值 备注 REST_TOKEN 个人访问令牌（Personal access tokens） 个人资料照片-\u0026gt;设置-\u0026gt;Developer settings API_ADDRESS https://api.github.com/repos/{owner}/{target-repo}/actions/workflows/enable_workflow/enable 修改{owner}/{target-repo} 运行 github action。\n相互唤醒，再次在目标 repo 的工作流程中执行上述步骤，并添加所需 Github Action step（此步骤已标注请回看）。\n附 github workflow 语法文档\n修改定时任务 —— Cron示例\n","date":"2021-11-19T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/freenom/","title":"freenom自动续期（废弃）"},{"content":"actions部署前后端分离项目 参考文章\n本文使用github actions + docker compose部署到github container registry（这适用于中小型项目） 附：容器注册平台对比\n准备好你的dockerfile，如无docker和docker-compose基础请先看文档和前文。\n使用github actions “点击展开示例actions”\ron: push: branches: - master workflow_dispatch: env: REGISTRY: ghcr.io IMAGE_NAME: ${{ github.repository }} jobs: build-and-push-image: runs-on: ubuntu-latest permissions: contents: read packages: write strategy: matrix: node: [ \u0026#39;14\u0026#39; ] steps: - name: Checkout repository uses: actions/checkout@v2 - name: Setup node uses: actions/setup-node@v2 with: node-version: ${{ matrix.node }} - name: npm install run: | cd web #进入前端dockerfile目录 npm install - name: Set up QEMU uses: docker/setup-qemu-action@v1 - uses: docker/setup-buildx-action@v1 id: builder1 - uses: docker/setup-buildx-action@v1 id: builder2 - name: Log in to the Container registry uses: docker/login-action@v1 with: registry: ${{ env.REGISTRY }} username: ${{ github.actor }} password: ${{ secrets.GITHUB_TOKEN }} # 用于消毒标签，tag是此动作的重要功能之一，本示例没使用，请见文档 - name: Extract metadata (tags, labels) for Docker id: meta1 uses: docker/metadata-action@v3 with: images: ghcr.io/username/server # images地址 - name: Extract metadata (tags, labels) for Docker id: meta2 uses: docker/metadata-action@v3 with: images: ghcr.io/username/web # images地址 - name: Build and push Docker image 1 uses: docker/build-push-action@v2 with: builder: ${{ steps.builder1.outputs.name }} context: ./server # 服务端dockerfile目录 file: ./server/Dockerfile # 服务端dockerfile push: true tags: ${{ steps.meta1.outputs.tags }} labels: ${{ steps.meta1.outputs.labels }} cache-from: type=gha cache-to: type=gha,mode=max - name: Build and push Docker image 2 uses: docker/build-push-action@v2 with: builder: ${{ steps.builder2.outputs.name }} context: ./web # 前端dockerfile目录 file: ./web/Dockerfile # 前端dockerfile push: true tags: ${{ steps.meta2.outputs.tags }} labels: ${{ steps.meta2.outputs.labels }} cache-from: type=gha cache-to: type=gha,mode=max deploy: runs-on: ubuntu-latest needs: build-and-push-image steps: - uses: appleboy/ssh-action@master with: host: ${{ secrets.host }} #仓库设置中添加Secrets：HOST username: root password: ${{ secrets.PASSWORD }} #仓库设置中添加Secrets：PASSWORD port: 22 script: | echo $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin # 用户名 docker-compose -f docker-compose-nginx.yaml -f docker-compose-app.yaml pull # docker-compose名 docker-compose -f docker-compose-nginx.yaml -f docker-compose-app.yaml up -d # docker-compose名 # 此actions许多参数由github自动提供，无需添加，需修改的均已注释 在服务器上完成向 Container registry 验证\n具体操作：打开/etc/profile\nexport CR_PAT=YOUR_TOKEN source /etc/profile echo $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin 新建docker-compose-app.yaml和代理容器docker-compose-nginx.yaml,示例文档。如有不懂，请多看几遍acme-companion和示例文档。最后，Issues中的实例可能会有帮助。 ","date":"2021-11-15T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/auto-deploy/","title":"docker自动化部署"},{"content":"docker 安装docker：\n#更新apt包索引 sudo apt-get update #安装包以允许apt通过 HTTPS 使用存储库 sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release #添加Docker官方的GPG密钥 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg #设置稳定存储库 echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null #安装最新版本的Docker Engine和containerd sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io #hello-world 映像验证 sudo docker run hello-world # 使用脚本安装 curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh Dockerfile “点击展开go语言示例”\r# 这个参考示例来自李文周大佬的bluebell项目 FROM golang:alpine AS builder # 为我们的镜像设置必要的环境变量 ENV GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 # 移动到工作目录：/build WORKDIR /build # 复制项目中的 go.mod 和 go.sum文件并下载依赖信息 COPY go.mod . COPY go.sum . RUN go mod download # 将代码复制到容器中 COPY . . # 将我们的代码编译成二进制可执行文件 bluebell_app RUN go build -o bluebell_app . ################### # 接下来创建一个小镜像 ################### FROM debian:stretch-slim COPY ./wait-for.sh / COPY ./templates /templates COPY ./static /static COPY ./conf /conf # 从builder镜像中把/dist/app 拷贝到当前目录 COPY --from=builder /build/bluebell_app / RUN set -eux; \\ apt-get update; \\ apt-get install -y \\ --no-install-recommends \\ netcat; \\ chmod 755 wait-for.sh # 声明服务端口 EXPOSE 8084 # 需要运行的命令 #ENTRYPOINT [\u0026#34;/bluebell_app\u0026#34;, \u0026#34;conf/config.yaml\u0026#34;] 基础知识参考 以下简介节选自docker文档：\n**卷（volumes）**存储在由 Docker管理的主机文件系统（在 Linux 上的/var/lib/docker/volumes/ ）。卷完全由 Docker 管理，非 Docker 进程不应修改文件系统的这一部分。卷是在 Docker 中持久化数据的最佳方式。 # 将当前目录的相对路径挂载到/app目录中 volumes: - ./:/app docker compose 安装docker compose：\n#单独下载和安装 Compose，不装Docker CLI #下载 Docker Compose 的当前稳定版本 curl -SL https://github.com/docker/compose/releases/download/v2.7.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose #对二进制文件应用可执行权限 sudo chmod +x /usr/local/bin/docker-compose #测试安装 docker compose version # 脚本 curl -fsSL https://get.docker.com -o get-docker.sh \u0026amp;\u0026amp; \\ sudo sh get-docker.sh \u0026amp;\u0026amp; \\ docker -v \u0026amp;\u0026amp; \\ curl -SL https://github.com/docker/compose/releases/download/v2.7.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose \u0026amp;\u0026amp; \\ sudo chmod +x /usr/local/bin/docker-compose \u0026amp;\u0026amp; \\ docker compose version docker-compose.yaml “点击展开和折叠代码”\rversion: \u0026#39;3.7\u0026#39; services: mysql5.7: # 镜像名 image: \u0026#39;mysql:5.7\u0026#39; # 容器名(以后的控制都通过这个) container_name: mysql5.7 # 重启策略 restart: always environment: # 时区上海 TZ: Asia/Shanghai # root 密码 MYSQL_ROOT_PASSWORD: root # 初始化数据库(后续的初始化sql会在这个库执行) MYSQL_DATABASE: nacos_config # 初始化用户(不能是root 会报错, 后续需要给新用户赋予权限) MYSQL_USER: nacos # 用户密码 MYSQL_PASSWORD: nacos # 映射端口 ports: - 3306:3306 volumes: # 数据挂载 #- /root/mysql/data/:/var/lib/mysql/ # 配置挂载 #- /root/mysql/conf/:/etc/mysql/conf.d/ # 初始化目录挂载，注意此处我只跑了这个挂载，只是为了说明其他配置不应该数据初始化 - /root/mysql/init/:/docker-entrypoint-initdb.d/ command: # 将mysql8.0默认密码策略 修改为 原先 策略 (mysql8.0对其默认策略做了更改 会导致密码无法匹配) --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 networks: - proxy server: image: ghcr.io/USERNAME/server:master container_name: server ports: - 8082:8082 expose: - \u0026#34;8082\u0026#34; depends_on: - mysql5.7 restart: always volumes: - \u0026#39;./data:/data/\u0026#39; networks: - proxy web: image: ghcr.io/USERNAME/web:master container_name: web depends_on: - server restart: always ports: - 3000:3000 expose: - \u0026#34;3000\u0026#34; environment: - VIRTUAL_HOST=example.com - VIRTUAL_PORT=3000 - LETSENCRYPT_HOST=example.com - LETSENCRYPT_EMAIL=mail@example.com networks: - proxy networks: proxy: name: nginx-proxy external: true “点击展开nginx-proxy代码”\rversion: \u0026#39;3\u0026#39; services: nginx-proxy: image: jwilder/nginx-proxy container_name: nginx-proxy ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; volumes: - conf:/etc/nginx/conf.d - vhost:/etc/nginx/vhost.d - html:/usr/share/nginx/html - dhparam:/etc/nginx/dhparam - certs:/etc/nginx/certs:ro - /var/run/docker.sock:/tmp/docker.sock:ro restart: always networks: - nginxproxy labels: - \u0026#34;com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy\u0026#34; letsencrypt: image: jrcs/letsencrypt-nginx-proxy-companion container_name: nginx-proxy-le depends_on: - nginx-proxy volumes: - vhost:/etc/nginx/vhost.d - html:/usr/share/nginx/html - dhparam:/etc/nginx/dhparam:ro - certs:/etc/nginx/certs - acme:/etc/acme.sh - /var/run/docker.sock:/var/run/docker.sock:ro ################## # 由于LETSENCRYPT证书速率限制，可使用ZeroSSL # 注释掉web服务environment中的： - LETSENCRYPT_HOST=example.com - LETSENCRYPT_EMAIL=mail@example.com # 需添加如下environment environment: - ACME_CA_URI=https://acme.zerossl.com/v2/DV90 - ZEROSSL_API_KEY= ################## restart: always networks: - nginxproxy volumes: conf: vhost: html: dhparam: certs: acme: networks: nginxproxy: name: nginx-proxy external: true 基础知识参考 以下简介节选自docker compose文档：\nCompose 中的网络: Compose默认为您的应用程序设置单个网络。服务中的每个容器都加入默认网络。例如，假设您的应用程序是在一个名为myapp的目录，运行docker-compose up时会创建一个名为myapp_default的网络，服务中使用web和db的配置创建的容器会以web和db的名字加入myapp_default。\n但是，当你使用external（外部网络，例如你有2个或多个docker-compose.yml）时，Compose不会创建默认网络，你必须使用docker network create Your_Nerwork预先创建网络。\n注意：文档中示例写法错误，会报错\nnetworks: proxy: external: name: nginx-proxy 应写为:\nnetworks: proxy: name: nginx-proxy external: true 常用命令 Docker命令 docker run [可选参数] imagename #新建并启动容器 --name = \u0026#34;name\u0026#34; 容器取名 -it 交互模式进入容器 -d 后台启动容器 注意：一般后台启动要有前台的应用，否则很可能被守护程序杀掉 -p ip:主机端口:容器端口 #指定端口映射 -v或--volume /卷名称的路径:/容器中的挂载路径 查看： docker search xxx #搜索dockerhub-镜像 docker images [-a][-q] #列出本地主机的-镜像 -a 显示所有信息 -q 显示所有id docker ps [-a][-q] #显示当前正在运行的容器 -a 显示当前运行的容器，并显示历史运行过的容器 -q 只显示运行容器的编号 docker logs 容器id #日志 docker top 容器id #查看容器中进程信息 docker inspect 容器id #查看容器的详细信息 操作： docker build -t tag . #构建标签为tag的镜像 docker pull 镜像：版本号 #拉取-镜像 docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止容器 docker kill 容器id #强制停止容器 docker rm 容器id #删除停止状态的容器 docker rm -f 容器id #强制删除容器 docker rmi -f xxx #删除单个-镜像 docker rmi -f $(docker images -aq) #删除所有-镜像 docker stop $(docker ps -a -q) #停止所有容器运行 docker rm $(docker ps -a -q) #删除所有容器 docker network rm $(docker network ls -q) #删除所有network docker system prune --all --force --volumes #删除一切 exit 容器停止并退出 ctrl+p+q 容器不停止退出 docker exec -it mysql /bin/bash #进入正在执行的mysql容器 docker exec -it 容器名 /bin/sh #进入容器 docker exec -it 容器名 -c \u0026#34;apt-get update \u0026amp;\u0026amp; apt-get install -y vim\u0026#34; #进入容器安装vim编辑器 docker exec -it 容器名 -c \u0026#34; apk add --update vim\u0026#34; #进入alpine容器安装vim编辑器 docker inspect -f \u0026#39;{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}\u0026#39; [container_name_or_id] #查看容器ip 从容器拷贝内容到主机： docker cp 容器id: 路径 主机目的路径 #此处不必进入容器，容器可以是关闭的。 Docker-compose命令 docker-compose up -d # 在后台启动服务 docker-compose pull # 拉取 docker-compose -f docker-compose.yml up -d # 指定docker-compose.yml docker-compose -f docker-compose.yml pull # 指定docker-compose.yml，后同 查看： docker-compose ps # 查看正在运行中的容器 docker-compose ps -a # 查看所有编排容器，包括已停止的容器 docker-compose images # 列出Compose文件构建的镜像 docker-compose logs # 查看日志 docker-compose logs [serviceName] # 查看某服务的日志 docker-compose logs -f [serviceName] # 查看某服务的实时日志 操作： docker-compose stop # 停止服务 docker-compose start # 启动已经存在的服务 docker-compose pause [serviceName] # 暂停服务 docker-compose unpause [serviceName] # 恢复服务 docker-compose restart [serviceName] # 重启服务 docker-compose rm # 删除所有（停止状态的）服务容器 docker-compose down # 删除所有容器 docker-compose down --remove-orphans # 删除orphans容器 docker-compose config -q # 验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容 docker-compose exec --index=1 [serviceName] sh # 进入某服务的第1个容器执行命令 docker-compose --help # 帮助 ","date":"2021-10-27T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/docker-compose/","title":"docker和docker-compose"},{"content":"git git命令 官网git备忘表比各种教程都易看\npush脚本 #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master 公开仓库fork为私有仓库 fork一个公开仓库 使用github导入功能，写fork仓库的地址，并创建私有仓库 本地操作 git clone git@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git #克隆到本地 git remote add upstream git@github.com:\u0026lt;original_owner\u0026gt;/\u0026lt;original_repo\u0026gt;.git #添加上游(源)仓库用于更新 git remote set-url --push upstream DISABLE #禁用推送到上游(源)仓库 git remote -v可以看到： origin\tgit@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git (fetch) origin\tgit@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git (push) upstream\tgit@github.com:\u0026lt;original_owner\u0026gt;/\u0026lt;original_repo\u0026gt;.git (fetch) upstream\tDISABLE (push) 拉取更新 git fetch upstream git merge upstream/master Linux 文件 i 键可以对文件进行修改， Esc + :+ wq 退出并保存修改之后的文件\nsudo gedit ~/File //编辑 touch File //新建文件 mkdir -p Folder/a/src //新建文件夹 sudo rm -r Folder //删除文件夹 安装包 apt sudo apt update \u0026amp;\u0026amp; apt upgrade //更新 dpkg --list //显示所有软件 sudo apt-get install 包名 //安装 sudo apt-get remove 包名 //卸载不删除配置文件 sudo apt-get --purge remove 包名 //软件及其配置文件一并删除 snap sudo snap list //列出已经安装的snap包 sudo snap install \u0026lt;snap name\u0026gt; //安装一个snap包 sudo snap refresh \u0026lt;snap name\u0026gt; //更新一个snap包，如果后面不加包的名字更新所有的snap包 sudo snap remove \u0026lt;snap name\u0026gt; //删除一个snap包 端口 sudo apt-get install lsof //安装lsof lsof -i:80 //查看80端口 kill -9 pid //强制杀进程 命令 local #用于声明局部变量 source systemctl stop service # 停止一个服务 systemctl daemon-reload # 重载所有修改过的配置文件 systemctl enable #将服务设置为每次开机启动 set -eux #用于脚本开头设置 #-e 若指令传回值不等于0，则立即退出shell。0表示没有错误 #-u 当执行时使用到未定义过的变量，则显示错误信息。 #-x 执行指令后，会先显示该指令及所下的参数。 grep 、sed、awk grep 、sed、awk被称为linux中的\u0026quot;三剑客\u0026quot;。\ngrep 更适合单纯的查找或匹配文本 sed 更适合编辑匹配到的文本 awk 更适合格式化文本，对文本进行较复杂格式处理 sed sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为\u0026quot;pattern space\u0026quot;，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。\n语法 sed [option] \u0026#39;command\u0026#39; fileName 选项\n-n 使用安静silent模式。在一般sed的用法中，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来\n-e 直接在指令列模式上进行 sed 的动作编辑\n-f 直接将 sed 的动作写在一个文件内，-f filename则可以执行filename内的sed命令\n-r 让sed命令支持扩展的正则表达式(默认是基础正则表达式)\n-i 直接修改读取的文件内容，而不是由屏幕输出\n命令\na\\：追加行，a\\的后面跟上字符串s(多行字符串可以用\\n分隔)，则会在当前选择的行的后面都加上字符串s\nc\\：替换行，c\\后面跟上字符串s(多行字符串可以用\\n分隔)，则会将当前选中的行替换成字符串s\ni\\：插入行，i\\后面跟上字符串s(多行字符串可以用\\n分隔)，则会在当前选中的行的前面都插入字符串s\nd：删除行delete，该命令会将当前选中的行删除\np：打印print，该命令会打印当前选择的行到屏幕上\ny：替换字符，通常y命令的用法是这样的：y/Source-chars/Dest-chars/，分割字符/可以用任意单字符代替，用Dest-chars中对应位置的字符替换掉Soutce-chars中对应位置的字符\ns：替换字符串，通常s命令的用法是这样的：1,$s/Regexp/Replacement/Flags，分隔字符/可以用其他任意单字符代替，用Replacement替换掉匹配字符串\n替换选项\n\\digit：Replacement中可含有后向引用中的\\digit(digit是1至9)，引用前面定义的子表达\n\u0026amp;：代表模版空间中的整个匹配部分\n\\L：将在其后的替换部分转换成小写字母，直到发现一个\\U或\\E，GNU扩展功能\n\\l：将下一个字符转换成小写字母，GNU扩展功能\n\\U：将在其后的替换部分转换成大写字母，直到发现一个\\L或\\E，GNU扩展功能\n\\u：将下一个字符转换成大写字母，GNU扩展功能\n\\E：停止由\\L或\\U指示开始的大小写转换，GNU扩展功能\n标志选项\ng：将用Replacement替换模版空间中所有匹配Regexp的部分，则不仅仅是第一个匹配部分\ndigit：只用Replacement替换模版空间中第digit(digit是1至9)个匹配Regexp的部分\np：若发生了替换操作，指示显示模版空间中新的数据\nw file-name：若发生了替换操作，指示将模版空间中新的数据写入指定的文件file-name中\ni：表示进行Regexp匹配时，是不区分大小写字母的\n示例 a命令 sed '1,$a\\add one' test.txt 从第一行到最后一行所有行后追加\u0026quot;add one\u0026quot;字符串行\nsed '/first/a\\add one' test.txt 在匹配到first行追加\u0026quot;add one\u0026quot;字符串行\ni命令 与a命令类似，只不过在匹配的行前面插入字符串行，不举例了。\nc命令 sed '1,$c\\add one' test.txt 从第一行到最后一行所有行替换为\u0026quot;add one\u0026quot;字符串行\nsed '/first/c\\add one' test.txt 将匹配到first行替换为\u0026quot;add one\u0026quot;字符串行\nd命令 sed '4,$d' test.txt 从第四行到最后一行全部删除\np命令 sed -n '/^first.*end$/p' test.txt 以first开头end结尾的所有行全部打印\ns命令 sed 's/line/text/g' test.txt 将所有行的line替换为text，g代表全局选项，没有g只替换所有行的第一个匹配项\nsed '/^first.*end$/s/line/text/g' test.txt 匹配以first开头end结尾的所有行，然后将line全部替换为text\nsed 's/\\(.*\\)line$/\\1/g' test.txt 本例中的\\(\\)中包裹的内容表示正则表达式的第n部分，.*表示任意字符串，所以此例相当于删除所有行末的line\n脚本语言备忘录 shell 原文地址\nname=\u0026#34;MyName\u0026#34; //定义变量 echo $name 或 echo ${name} //使用变量 val=`expr 2 + 2` #expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 echo \u0026#34;Total value : $val\u0026#34; 2\u0026gt;\u0026amp;1 把\u0026#34;标准错误输出\u0026#34;重定向到\u0026#34;标准输出\u0026#34; 特殊变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2 $# 传递给脚本或函数的参数个数总和 $* 传递给脚本或函数的所有参数，当被双引号 \u0026quot; \u0026quot; 包含时，所有的位置参数被看做一个字符串 $@ 传递给脚本或函数的所有参数，当被双引号 \u0026quot; \u0026quot; 包含时，每个位置参数被看做独立的字符串 $? 上个命令的退出状态，或函数的返回值 $$ 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。 测试符 描述 -eq，equal 等于 -ne，not equal 不等于 -gt，greater than 大于 -lt，lesser than 小于 -ge，greater or equal 大于或等于 -le，lesser or equal 小于或等于 -z 检测字符串长度是否为 0，为 0 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 待续\npython os 函数名 使用方法 getcwd() 返回当前工作目录 chdir(path) 改变工作目录 listdir(path=\u0026rsquo;.') 列举指定目录中的文件名（\u0026rsquo;.\u0026lsquo;表示当前目录，\u0026rsquo;..\u0026lsquo;表示上一级目录） mkdir(path) 创建单层目录，如该目录已存在抛出异常 makedirs(path) 递归创建多层目录，如该目录已存在抛出异常，注意：\u0026lsquo;E:\\a\\b\u0026rsquo;和\u0026rsquo;E:\\a\\c\u0026rsquo;并不会冲突 remove(path) 删除文件 rmdir(path) 删除单层目录，如该目录非空则抛出异常 removedirs(path) 递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常 rename(old, new) 将文件old重命名为new system(command) 运行系统的shell命令 walk(top) 遍历top路径以下所有的子目录，返回一个三元组：(路径, [包含目录], [包含文件])【具体实现方案请看：第30讲课后作业^_^】 以下是支持路径操作中常用到的一些定义，支持所有平台 os.curdir 指代当前目录（\u0026rsquo;.\u0026rsquo;） os.pardir 指代上一级目录（\u0026rsquo;..\u0026rsquo;） os.sep 输出操作系统特定的路径分隔符（Win下为\u0026rsquo;\\\u0026rsquo;，Linux下为\u0026rsquo;/\u0026rsquo;） os.linesep 当前平台使用的行终止符（Win下为\u0026rsquo;\\r\\n\u0026rsquo;，Linux下为\u0026rsquo;\\n\u0026rsquo;） os.name 指代当前使用的操作系统（包括：\u0026lsquo;posix\u0026rsquo;, \u0026rsquo;nt\u0026rsquo;, \u0026lsquo;mac\u0026rsquo;, \u0026lsquo;os2\u0026rsquo;, \u0026lsquo;ce\u0026rsquo;, \u0026lsquo;java\u0026rsquo;） os.path 函数名 使用方法 basename(path) 去掉目录路径，单独返回文件名 dirname(path) 去掉文件名，单独返回目录路径 join(path1[, path2[, \u0026hellip;]]) 将path1, path2各部分组合成一个路径名 split(path) 分割文件名与路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在 splitext(path) 分离文件名与扩展名，返回(f_name, f_extension)元组 getsize(file) 返回指定文件的尺寸，单位是字节 getatime(file) 返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getctime(file) 返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getmtime(file) 返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） 以下为函数返回 True 或 False exists(path) 判断指定路径（目录或文件）是否存在 isabs(path) 判断指定路径是否为绝对路径 isdir(path) 判断指定路径是否存在且是一个目录 isfile(path) 判断指定路径是否存在且是一个文件 islink(path) 判断指定路径是否存在且是一个符号链接 ismount(path) 判断指定路径是否存在且是一个挂载点 samefile(path1, paht2) 判断path1和path2两个路径是否指向同一个文件 BeautifulSoup from bs4 import BeautifulSoup html_doc = \u0026#34;\u0026#34;\u0026#34; \u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;story\u0026#34;\u0026gt;Once upon a time there were three little sisters; and their names were \u0026lt;a href=\u0026#34;http://example.com/elsie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026#34;http://example.com/lacie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Lacie\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026#34;http://example.com/tillie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link3\u0026#34;\u0026gt;Tillie\u0026lt;/a\u0026gt;; and they lived at the bottom of a well.\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;story\u0026#34;\u0026gt;...\u0026lt;/p\u0026gt; \u0026#34;\u0026#34;\u0026#34; # 解析html_doc soup = BeautifulSoup(html_doc, \u0026#39;html.parser\u0026#39;) # 按照标准的缩进格式的结构输出 print(soup.prettify()) # 选择元素 soup.title # \u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt; # 提取节点信息 soup.title.name # u\u0026#39;title\u0026#39; # 获取属性 soup.p.attrs # {\u0026#39;class\u0026#39;: [\u0026#39;title\u0026#39;], \u0026#39;name\u0026#39;: \u0026#39;Dormouse\u0026#39;} soup.p.attrs[\u0026#39;name\u0026#39;] # Dormouse # 获取文本内容 soup.title.get_text() soup.title.string # u\u0026#39;The Dormouse\u0026#39;s story\u0026#39; # 获取第一个P标签下的所有的子节点，children是迭代器，所以用list转换 list(soup.p.children) list(soup.p.children)[0].text # 获取前面和后面的兄弟节点，迭代器类型 list(soup.a.next_siblings) list(soup.a.previous_siblings) # 找到标签 soup.find(\u0026#39;title\u0026#39;) # \u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt; # 找到所有\u0026lt;a\u0026gt;标签的链接 for link in soup.find_all(\u0026#39;a\u0026#39;): print(link.get(\u0026#39;href\u0026#39;)) # CSS选择器 html_doc = \u0026#34;\u0026#34;\u0026#34; \u0026lt;div class=\u0026#34;panel\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;panel-heading\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;Hello World\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;panel-body\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;list\u0026#34; id=\u0026#34;list-1\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Foo\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Bar\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Jay\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;list list-samll\u0026#34; id=\u0026#34;list-2\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Foo\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Bar\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Jay\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026#34;\u0026#34;\u0026#34; print(soup.select(\u0026#39;.panel-heading\u0026#39;)) # 获取class为panel-heading的节点 print(soup.select(\u0026#39;ul li\u0026#39;)) # 获取ul下的li节点 print(soup.select(\u0026#39;#list-2 li\u0026#39;)) # 获取id为list-2下的li节点 print(soup.select(\u0026#39;ul\u0026#39;)) # 获取所有的ul节点 正则表达式 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n\u0026lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“`(. (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`( (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95 (?\u0026lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?\u0026lt;=95 (?\u0026lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?\u0026lt;!95 x|y 匹配x或y。例如，“`z [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \\d 匹配一个数字字符。等价于[0-9]。 \\D 匹配一个非数字字符。等价于[^0-9]。 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04\u0026amp;1”。正则表达式中可以使用ASCII编码。. *num* 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。 *n* 标识一个八进制转义值或一个向后引用。如果*n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n*为一个八进制转义值。 *nm* 标识一个八进制转义值或一个向后引用。如果*nm之前至少有nm个获得子表达式，则nm为向后引用。如果*nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则*nm将匹配八进制转义值nm*。 *nml* 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 一、校验数字的表达式 1. 数字：^[0-9]*$ 2. n位的数字：^\\d{n}$ 3. 至少n位的数字：^\\d{n,}$ 4. m-n位的数字：^\\d{m,n}$ 5. 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 10. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 12. 非零的负整数：^\\-[1-9][]0-9″*$ 或 ^-[1-9]\\d*$ 13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1. 汉字：^[\\u4e00-\\u9fa5]{0,}$ 2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3. 长度为3-20的所有字符：^.{3,20}$ 4. 由26个英文字母组成的字符串：^[A-Za-z]+$ 5. 由26个大写英文字母组成的字符串：^[A-Z]+$ 6. 由26个小写英文字母组成的字符串：^[a-z]+$ 7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20} 9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 11. 可以输入含有^%\u0026amp;’,;=?$\\”等字符：[^%\u0026amp;’,;=?$\\x22]+ 12. 禁止输入含有~的字符[^~\\x22]+ 其它： .*匹配除 \\n 以外的任何字符。 /[\\u4E00-\\u9FA5]/ 汉字 /[\\uFF00-\\uFFFF]/ 全角符号 /[\\u0000-\\u00FF]/ 半角符号 三、特殊需求表达式 1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%\u0026amp;=]*)?$ 4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 5. 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6. 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7. 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 12. 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 1.有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0″不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了+可以用*替代,如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\n1. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 2. 中文字符的正则表达式：[\\u4e00-\\u9fa5] 3. 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 4. 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 5. HTML标记的正则表达式：\u0026lt;(\\S*?)[^\u0026gt;]*\u0026gt;.*?\u0026lt;/\\1\u0026gt;|\u0026lt;.*? /\u0026gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 6. 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 7. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 8. 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 9. IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) 10. IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 11. IP-v4地址：\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b (提取IP地址时有用) 12. 校验IP-v6地址:(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 13. 子网掩码：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 14. 校验日期:^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。) 15. 抽取注释：\u0026lt;!–(.*?)–\u0026gt; 16. 查找CSS属性:^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 17. 提取页面超链接:(\u0026lt;a\\\\s*(?!.*\\\\brel=)[^\u0026gt;]*)(href=”https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?’.implode(‘|(?:www\\\\.)?’, $follow_list).’))[^” rel=”external nofollow” ]+)”((?!.*\\\\brel=)[^\u0026gt;]*)(?:[^\u0026gt;]*)\u0026gt; 18. 提取网页图片:\\\\\u0026lt; *[img][^\\\\\\\\\u0026gt;]*[src] *= *[\\\\”\\\\’]{0,1}([^\\\\”\\\\’\\\\ \u0026gt;]*) 19. 提取网页颜色代码:^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 20. 文件扩展名效验:^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?”\u0026lt;\u0026gt;|]+\\\\.txt(l)?$ 21. 判断IE版本：^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ ","date":"2021-07-22T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/command/","title":"常用命令"},{"content":"部分电脑配置记录 win10 config git git config --global http.proxy http://127.0.0.1:port.http git config --global https.proxy https://127.0.0.1:port.http 文件路径：C:\\Users\\90487\\.gitconfig，90487是我的用户名\nTerminal（临时使用） set http_proxy=http://127.0.0.1:port.http #临时命令行代理 set https_proxy=http://127.0.0.1:port.http #临时命令行代理 VM Ubuntu config 代理 Windows中使用ipconfig查看VMware Network Adapter VMnet8的ip地址，ubuntu中进入“设置”-“网络”-“proxy”，在Socks Host里写入之前查到的ip地址\ngit config git config --global user.name \u0026#34;John Doe\u0026#34; #配置github账号用户名 git config --global user.email johndoe@example.com #配置邮箱 git ssh 代理 创建~/.ssh/config 文件：\nHost github.com User git ProxyCommand nc -v -x ip:port.socks %h %p #写自己ip 终端代理（临时使用）\n方法一：直接在命令前加proxychains\n方法二：直接在.bashrc最后加入：\nexport http_proxy=\u0026#34;http://ip:port.http\u0026#34; #写自己ip export https_proxy=\u0026#34;http://ip:port.http\u0026#34; #写自己ip source ~/.bashrc #使配置生效 Ubuntu升级 # 更新 sudo apt update sudo apt upgrade sudo reboot # 启动 GUI 更新向导 sudo update-manager -c update错误 N: 无法安全地用该源进行更新，所以默认禁用该源 cd /etc/apt/sources.list.d sudo rm -f * # 删除全部软件源 W: Failed to fetch http://archive.ubuntu.com/ 备份您的来源列表 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup\n打开/etc/apt/sources.list粘贴这里对应地区和版本的sources.list条目\n# DNS 设置 sudo vim /etc/resolv.conf # 使用Google DNS作为首选 DNS 服务器 nameserver 8.8.8.8 nameserver 8.8.4.4 Ubuntu安装go sudo apt install snap #安装snap，使用snap更易安装、更新 sudo snap install go --classic #安装go sudo vim /etc/profile #编辑profile export GOROOT=/snap/go #在最后一行添加 export PATH=$PATH:$GOROOT/bin source /etc/profile #保存 go version #验证 export GO111MODULE=on export GOPROXY=https://goproxy.cn #设置 go get 为国内源（无代理） Goland 使用 goland无限试用，方法适用IDEA系列\ngoland中添加第三方插件仓库地址：https://plugins.zhile.io 安装插件：IDE Eval Reset 下载 直接把zip包拖进IDE的窗口来进行插件的安装 Help -\u0026gt; Eval Reset 勾选Auto reset before per restart 原文地址，本段仅进行简述，使操作简明\n不能输入中文（Ubuntu） 在goland.sh注释之后的首行添加\nexport XMODIFIERS=\u0026#34;@im=ibus\u0026#34; export GTK_IM_MODULE=\u0026#34;ibus\u0026#34; export QT_IM_MODULE=\u0026#34;ibus\u0026#34; goland.vmoptions添加-Drecreate.x11.input.method=true\nWin10 系统问题 Win10 资源管理器无限重启闪屏 安全模式开机\n长按开机键3次，选择【疑难解答】-【高级选项】-【启动设置】- 【重启】，在启动设置内， 按 4 或 F4 就可以进入安全模式了。\n更换本地账户、新建本地账户。\n开机后右键windows图标点击 powershell（管理员）\n在命令提示符(管理员)中复制粘贴输入以下指令：\nnet user User ****** /add (User是新建账户，******是新建的随机密码)　net localgroup administrators User /add (赋予该账号管理员权限)\n重启后按电源键息屏，再开启后可以切换到User账户，进去后一切正常，表示故障原因不在硬件和系统方面，肯定是第三方软件。\n新建文本粘贴以下代码\nWindows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\\LocalDumps\\explorer.exe] \u0026#34;DumpFolder\u0026#34;=hex(2):43,00,3a,00,5c,00,43,00,72,00,61,00,73,00,68,00,44,00,75,\\ 00,6d,00,70,00,73,00,00,00 重命名为1.reg，运行后会在C盘建立CrashDumps文件夹（路径C:\\CrashDumps），当系统闪屏后里面有后缀.dmp文件，把这个文件拖到Visual Studio里打开，可以排查相关的第三方软件的路径，挨个卸载。我放在vs里显示我IDM下载程序缺少二进制文件，卸载后完美进入系统。\n自用软件 本文软件均为自用，本人无意推广任何软件，所以下载地址请自行查找，一般在google可找到官方，或者在52论坛搜搜看\nwin10优雅必备 Wallpaper Engine　#壁纸，steam购买\nEverything + uTools　#文件快捷搜索及工具\nquicker　#鼠标便捷操作神器\nDeskGo　#腾讯出品的桌面软件格子\nGeek Uninstaller　#卸载无残留\nclover　#资源管理器多标签页\n火绒　#屏蔽弹窗\ntypora　#markdown记事本，据说notion在线笔记，我把博客当作在线笔记了\nwin10 microsoft store工具\nWindows Terminal　#命令行 TranslucentTB　#任务栏透明 EarTrumpet　#音频管理 安卓app 浏览器：Chrome、Kiwi、x浏览器\n影视：zd01.tv下载 + AdGuard　# AdGuard设置复杂请自行研究，去除视频开头广告可在日志中找到广告，把这几个广告网站地址添加到自定义过滤\n音乐：listen1　# 并不完美，希望找到更好用的\n小说：阅读　# 酷安评论区可以找书源\n阅读：ReadEra、福昕PDF阅读器\n去除启动广告：跳过广告\n手机控制\nMacroDroid、hamibot　#手机自动化 Moonlight　#局域网流畅投屏 AirDroid和AirMirror　#手机远程控制手机 向日葵远程控制 其他\nzarchiver　#文件管理和解压 星空视频壁纸 Sendapp #提取apk ","date":"2021-07-18T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/config/","title":"环境配置和软件"},{"content":"准备 1.Ubuntu\nsudo apt update #更新 2.github账号\n3.git配置\ngit config --global user.name \u0026#34;John Doe\u0026#34; #配置github账号用户名 git config --global user.email johndoe@example.com #配置邮箱 4.连接github\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; #生成SSH Keys 此为新版 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; #此为常用版 cat ~/.ssh/id_ed25519.pub #复制 点击github右上角头像-\u0026gt; Settings -\u0026gt; SSH and GPG Keys -\u0026gt; New SSH key添加\nssh -T git@github.com #验证连接，输入yes 官方文档\n5.git ssh 代理设置\n非必要步骤，如果有一天ssh push网速极慢但https push正常，可尝试此操作\n创建~/.ssh/config 文件：\nHost github.com User git ProxyCommand nc -v -x 127.0.0.1:10808 %h %p #请修改127.0.0.1:10808 安装 snap install hugo --channel=extended #安装hugo hugo version #验证 hugo new site myblog #创建博客 git init #初始化 git remote add origin git@github.com:**** #连接远程仓库 git clone https://github.com/CaiJimmy/hugo-theme-stack/ #安装stack主题 rm config.toml \u0026amp;\u0026amp; cp themes/hugo-theme-stack/exampleSite/config.yaml . #使用主题的配置文件 把myblog/themes/hugo-theme-stack/exampleSite/content内容移到myblog/content使用主题示例文章\n本地预览： myblog下执行\nhugo server 浏览器打开：\nhttp://localhost:1313/ #目前本地运行不显示文章目录，估计是操作系统原因 部署 注：我将介绍使用github托管源码自动化部署，如果您仅在本地存放源码，提交public文件夹即可，无需使用下列方法。\n1.虽然博客内容全都能看到，但我们可能不太希望公开源码，不开放源码使用github pages需要创建2个仓库: 创建 username.github.io.source 仓库存放源码可设为私人仓库，创建 username.github.io 仓库作为公开仓库\n点击github右上角头像-\u0026gt; Settings -\u0026gt; Developer Settings-\u0026gt; Personal access tokens -\u0026gt; Generate new token （Note随意，Select scopes全选,复制token，我们这里使用Personal tokens比Deploy keys更方便）\n找到源码仓库Settings-\u0026gt; Secrets -\u0026gt; New repository secret （Name写PERSONAL_TOKEN，Value粘贴token）\n2.创建github actions的workflows自动部署文件：\nmkdir -p .github/workflows \u0026amp;\u0026amp; touch ~/myblog/.github/workflows/main.yml 粘贴脚本：\nname: github pages on: push: branches: - master jobs: deploy: runs-on: ubuntu-latest #可使用指定版本，例：runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest #可使用指定版本，例：hugo-version: \u0026#39;0.83.1\u0026#39; extended: true - name: Build run: hugo --gc --forceSyncStatic --minify --cleanDestinationDir - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} # PERSONAL_TOKEN是源码仓库secrets的name external_repository: username/username.github.io # Pages 远程仓库 publish_branch: master # 部署的分支 publish_dir: ./public commit_message: ${{ github.event.head_commit.message }} #cname: www.example.com # 使用自定义域名 只需更改external_repository: username/username.github.io 为你的github账户名，脚本详情\n3.在myblog文件夹下创建push.sh\ntouch push.sh 粘贴脚本：\n#!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master 在myblog下运行 sh push.sh命令\n到此已完成部署，之后任何更新如上运行push脚本即可\n修改主题 此处仅列举常见需修改内容，更多内容请看stack主题文档\n本博客修改样式来自rmdhnreza\n更多定制文章可以参考这里\n主题配置 1.修改~/myblog/config.yaml\n1 baseurl: https://username.github.io #改为自己的 2 languageCode: zh-CN #中文编码 4 paginate: 10 #文章分页数 5 title: Example Site #博客名字 30 DefaultContentLanguage: zh-cn #中文 34 hasCJKLanguage: true #正确计数中、日、韩文语言的字数 48 since: 2021 52 published: 2006-01-02 #日期格式 53 lastUpdated: 2006-01-02 #更新日期格式 56 emoji: 🍥 #头像角标 57 subtitle: #博客名下的简介 61 src: img/avatar.png #头像，myblog/themes/hugo-theme-stack/assets/img 135 name: \u0026#39;首页\u0026#39; #改中文左侧菜单home 155 startLevel: 1 #从文章1级标题使用文章目录 2.左侧菜单栏 ~/myblog/content/page用于左侧菜单，请自定义\n2 title: \u0026#39;关于\u0026#39; #中文左侧菜单about，后同 3.覆盖主题样式\n直接在~/myblog下复制复制我的assets、layouts文件夹，本主题来源于rmdhnreza。\n另外修改：\n~/myblog/assets/scss/variables.scss\nlink-background-color: 0, 255, 255 链接背景颜色 注：浏览器可能缓存样式，可使用无痕模式\n创建文章 hugo new post/文件夹名/index.md #创建文章 写文章：\n1.front matter:\n--- title: hugo使用stack主题搭建博客及部署 #标题 description: #副标题，此样式不可用 date: 2021-07-04 #日期 lastmod: 2021-07-27 #上次修改内容的日期 slug: hugo-blog #URL的尾部，用于文章地址 categories: #文章分类 - blog --- front matter仅列举本文使用，hugo front matter官方文档\n2.常见文章markdown语法：\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n`单行代码` `` 有`需用双反引号 ``\n```html\n多行代码\n```\n[链接](https://)\n\\ 写在特殊符号前为转义；写在行尾为换行\\\n*斜体*\n**加粗**\n~~删除线~~\n* 无序列表\n双空格* 子无序列表\n![图片描述](本地图片.jpg)\n表格\n| Italics | Bold | Code | | -------- | -------- | ------ | | *italics* | **bold** | `code` | shortcodes ./myblog/layouts/shortcodes\n{{\u0026lt; spoiler text=\u0026quot;点击展开和折叠代码\u0026quot; \u0026gt;}}\n```html\ncode\n```\n{{\u0026lt; /spoiler \u0026gt;}}\n{{\u0026lt; typography font=\u0026quot;monoton\u0026quot; size=\u0026quot;30px\u0026quot; style=\u0026quot;normal\u0026quot; weight=\u0026quot;bold\u0026quot; color=\u0026quot;blue\u0026quot;\u0026gt;}} 自定义字体 {{\u0026lt; /typography \u0026gt;}}\n# font　Google 字体\n# size　大小\n# style　normal正常， italic 斜体\n# weight　bold 加粗 ， lighter 更细\n评论系统 waline官方文档写得非常清楚，您只需 LeanCloud设置 和 部署到Vercel ，拿到URL\n然后修改~/myblog/config.yaml\n52 provider: waline #评论系统，本文示例使用waline 73 serverURL: https:// #评论系统URL用你自己的 执行sh push.sh即可\n自定义域名 在~/myblog/config.yaml修改baseurl: https://username.github.io\n在~/myblog/.github/workflows/main.yml最后一行取消注释并修改cname: www.example.com\n执行sh push.sh即可\n启用https：参考链接\n没有域名？为了白嫖可在freenom和cloudflare进行申请域名和解析，这可能花费一些时间，如对此没有了解建议暂时跳过自定义域名。\nfreenom脚本自动续期参考后续文章\n","date":"2021-07-03T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/hugo-blog/","title":"hugo使用stack主题搭建博客及部署"}]