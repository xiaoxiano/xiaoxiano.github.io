[{"content":"跑步 手表 专业跑表：推荐佳明，数据专业，用于参加马拉松及越野\n日常的跑表：可以选自己手机品牌的（例如OPPO Watch X），认准双频GPS，不仅准确，而且使用esim完全不用带手机\n不选手环：每次跑步都需要连接手机，并要在手机网络信号好的地方用，否则单频GPS误差相当大，只能看心率。\n跑鞋 只说国际四大跑鞋我买过的顶缓：\n索康尼 胜利21：舒适度拉满，韧弹型，长距离完全不泄力，但我是小体重，脚感硬，长期训练量大的话会伤跟腱 新百伦 1080v13：脚感软，后程有泄力但能接受，内部材质差，稍作修改后还算舒适，可以作为慢跑主力 亚瑟士 nimbus26：又厚！又磨脚！鞋底很软也很泄力，我感觉完全脱离了跑步鞋的范畴，用作走路比较好。唯一好评的是鞋垫，可以复购鞋垫 布鲁克斯 甘油max：待测 衣服 根据喜好随便买就可以，没穿出好坏，列举些常见品牌\n厚衣服 轻工：热力怪 内道：聚能卷 马甲 腰包裤：马孔多 袜子：悍将、feetures、乔丹 薄上衣：速干即可 山地车 参考：2024山地车选购指南\n尺寸 轮径26、车架17 适合身高165cm-175cm 刹车 首选油压碟刹 次选机械碟刹 不选V刹 前叉避震 首选气压 次选油、弹簧 弹簧 变速：禧玛诺、速联 21速=3齿盘×7飞轮 24速=3齿盘×8飞轮 27速=3齿盘×9飞轮 品牌 首选线下：捷安特、美利达、喜德盛(性价比) 品控好：千里达(性价比)、福玛特 其它：邦德富士达、迪卡侬 高端：崔克、闪电 3000以内选购 美利达公爵600：长途旅行，考虑耐用及维修，综合体验更好（即使传奇500刹车配置更高，公爵300s几乎不减配） 千里达 X7Elite ","date":"2024-11-10T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/sports/","title":"运动装备推荐"},{"content":"fiddler fiddler的缺点是不支持中文，也可以使用另一款针对安卓的抓包软件reqable（前身HttpCanary）。\nSystem Proxy：Fiddler通过系统代理的形式来进行监听请求和响应\n证书：fiddler默认只抓取http协议，要抓取https协议需要在设置中rust Fiddler CA，勾选Capture HTTPS traffic和Ignore server certificate errors\n允许远程连接：\nFilters：过滤器，匹配想要的请求\n更多内容参考官方文档\nAndroid 模拟器 模拟器中，mumu支持android12兼容性最强，雷电模拟器也可以用，而BlueStacks5 不支持代理，夜神的性能较差。\n别的文章说要网络桥接，这样模拟器会断连，无需使用\n打开root权限 打开写入权限(可能会自动关闭，使用时检查) 查看电脑ip，打开WLAN设置填写代理 打开浏览器，输入IP:8888，DOWNLOAD CERTIFICATE，在状态栏点击安装\n移动证书，因为部分应用使用系统证书，需要把证书移动至系统证书目录（以下方法适用于Android 7 到 Android 13）\n在windows窗口运行adb：\n# 查看设备连接 adb devices # 获得权限 adb root \u0026amp;\u0026amp; adb remount # 进入shell adb shell # 切换root用户 su # 查看用户证书的名称 ls /data/misc/user/0/cacerts-added/ # 将用户证书挪至系统证书目录 mv /data/misc/user/0/cacerts-added/[证书] /system/etc/security/cacerts/ # 如果查看证书可以下载MT管理器 真机 用真机肯定麻烦点，但有些app不支持使用模拟器打开。\nroot，Magisk\nWindows放行端口\n控制面板 -\u0026gt; Windows Defender 防火墙 -\u0026gt; 高级设置 -\u0026gt; 入站规则 -\u0026gt; 新建规则\u0026hellip; -\u0026gt; 端口8888\n查看电脑ip，打开WLAN设置填写代理 打开浏览器，输入IP:8888，DOWNLOAD CERTIFICATE，在状态栏点击安装\nMagisk安装模块（允许真机启用 adb root）\n适用于 Android 9/10、适用于 Android 11+\nadb移动证书 # 查看设备连接 adb devices # 获得权限 adb root \u0026amp;\u0026amp; adb remount # 进入shell adb shell # 切换root用户 su # 重新挂载具有读写权限的根（/）分区 mount -o rw,remount / # 查看用户证书 ls /data/misc/user/0/cacerts-added/ # 将用户证书挪至系统证书目录 mv /data/misc/user/0/cacerts-added/[证书] /system/etc/security/cacerts/ # 恢复只读状态 mount -o ro,remount / # 如果查看证书可以下载MT管理器 可以抓包了。如果看到二进制加密数据，就需要破解apk，以后再详细研究。\n","date":"2024-08-30T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/capture/","title":"Fiddler5抓包APP数据"},{"content":" 执业医师考试(中国大陆)专用，精简了大量内容，不作为诊疗建议\n执医技能2024 ","date":"2024-05-26T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/medical/","title":"医学"},{"content":"不可逆算法（哈希HASH） 哈希算法 哈希算法：将一段（通常是较大的）数据映射为较短小的数据。这段小数据就是大数据的哈希值，它是唯一的，一旦大数据发生变化，他的哈希值也会发生变化。\n哈希碰撞\n哈希碰撞是指，两个不同的输入得到了相同的输出：\n\u0026#34;AaAaAa\u0026#34;.hashCode(); // 0x7460e8c0 \u0026#34;BBAaBB\u0026#34;.hashCode(); // 0x7460e8c0 碰撞能不能避免，哈希算法的输出长度越长，碰撞概率越小。\n算法 输出长度（位） 输出长度（字节） MD5 128 bits 16 bytes SHA-1 160 bits 20 bytes RipeMD-160 160 bits 20 bytes SHA-256 256 bits 32 bytes SHA-512 512 bits 64 bytes 应用：\n用于密码管理 - 把用户的密码以MD5值（或类似的其它算法）的方式保存起来，用户注册的时候，系统是把用户输入的密码计算成 MD5 值，然后再去和系统中保存的 MD5 值进行比较，如果密文相同，就可以认定密码是正确的，否则密码错误。通过这样的步骤，系统在并不知道用户密码明码的情况下就可以确定用户登录系统的合法性。如果数据库泄漏，黑客也无法拿到用户的原始口令，如果黑客有一个预先计算好的常用口令和它们的MD5的对照表（彩虹表），就能反查到原始口令，我们可以采取措施来抵御，方法是对每个口令额外添加随机数，这个方法称之为加盐。 电子签名 - 使用 MD5算法就可以为任何文件（不管其大小、格式、数量）产生一个独一无二的数字指纹，借助这个数字指纹，通过检查文件前后 MD5 值是否发生了改变，就可以知道源文件是否被改动。 基于密钥的哈希算法 HMAC:类似“加盐”的MD5，Hmac本质上就是把安全key混入摘要的算法。\n可逆算法 对称加密 加密：明文 -\u0026gt; 密钥加密 -\u0026gt; 密文。\n解密：密文 -\u0026gt; 密钥解密 -\u0026gt; 明文。\n经典加密算法有三种 ：\nDES(Data Encryption Standard)：数据加密标准(现在用的比较少，因为它的加密强度不够，能够暴力破解) 3DES：原理和DES几乎是一样的，只是使用3个密钥，对相同的数据执行三次加密，增强加密强度。(缺点：要维护3个密钥，大大增加了维护成本) AES(Advanced Encryption Standard)：高级加密标准，目前美国国家安全局使用的，苹果的钥匙串访问采用的就AES加密。是现在公认的最安全的加密方式，是对称密钥加密中最流行的算法。 加密模式 ：\nECB模式（默认）：电码本模式 Electronic Codebook Book，就是每个块都是独立加密 CBC模式：密码分组链接模式 Cipher Block Chaining，使用一个密钥和一个初始化向量(IV)对数据执行加密转换 CTR模式：计算器模式 Counter CFB模式：密码反馈模式 Cipher FeedBack OFB模式：输出反馈模式 Output FeedBack 加密模式是加密过程对独立数据块的处理。对于较长的明文进行加密需要进行分块加密，在实际开发中，推荐使用CBC的，ECB的要少用。\n非对称加密RSA 发送公钥 -\u0026gt; 对方用公钥加密 -\u0026gt; 收到密文、私钥解密\n常见的非对称加密算法有：RSA、DSA(美国国家标准局提出)、ECC(椭圆曲线密码学)、DH等。\nECC 算法比 RSA、DSA 速度更快，基于 ECC 的签名算法主要有两种：ECDSA 与 EdDSA， EdDSA 比 ECDSA 更简洁更快一点，因此现在通常更推荐使用 EdDSA 算法。目前 EdDSA 有两个方案：Ed25519 和 Ed448。\n","date":"2023-08-13T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/encrypt/","title":"加密算法"},{"content":"想要体验二合一笔记本，大约有这些选择：\nsurface pro ROG 幻X，高配显卡反而拉低续航，二合一的屏幕尺寸也不适合打游戏 Chromebook，折腾。 x-station？ 目前结论：\n推荐Surface Pro 11 ，兼容性最好，性能现在也挺强了。但这个价格很多人也会考虑买性能强大、也算轻便的Mac（少了触屏）。\nChromebook duet5 硬件尚可，续航高，但Chrome OS还不成熟，不适配的bug很多，体验不佳。不过使用其它Android平板或Ipad体验也很一般，只轻度使用（电子书、视频等）可以尝试。\nChromebook duet5 开启开发者模式 首先SSTap分享网络登录进去（参考前文）。\n从主机上取下可拆卸键盘，按住[提高音量]+[降低音量]+[电源按钮]约 10 秒钟，然后松开，您应该看到恢复模式屏幕。（Chromebook duet5和其他机型的方法有所不同）\n音量键可以切换语言，然后选中高级-\u0026gt;开发者模式-\u0026gt;从内部磁盘启动，系统将发出哔哔声重新启动并开始设置。\n双拼输入法 项目地址\n谷歌插件商店，先安装IME UI控件 ，然后再安装IME Decoder(chrome \u0026gt; 102) 。\n系统设置-\u0026gt;语言与输入法-\u0026gt;添加输入法,找到\u0026quot;中文双拼输入法\u0026quot;添加并选择启用输入。\n","date":"2023-04-16T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/chromebook/","title":"二合一笔记本"},{"content":"购买vps一般需要注意性能、带宽和线路。\n性能是根据自身需要的，一般只需要看内存，跑代理512M足够了（考虑到有邻居还是建议1G），跑业务最好在2G以上。\n带宽只要搜一下商家的测评，注意共享带宽的实际速度、晚高峰速度就行了。\n线路却是一个相对复杂的问题。不仅海内外线路繁多，不同运营商、不同省市的情况也不同，所以最好自己测试（测试方法见下文）。如果不想测，可以去主机测评网等网站看测评，或者电信用CN2、联通用AS9929、移动用CMI。\n使用机场最好用IPLC/IEPL线路，几乎不会断连，有名的telegram测评频道前女友们用过的机场可以参考。用机场隐私泄露风险较高。\n常见线路 国内运营商 IPLC/IEPL国际私用出租线路\n电信的163骨干网自治系统编号 AS4134\n电信的CN2骨干网自治系统编号 AS4809 （优秀）\n联通的169骨干网自治系统编号 AS4837\n联通的A网骨干网自治系统编号 AS9929 （优秀）\n移动的CMNET境内骨干网自治系统编号 AS9808\n移动的CMI境外骨干网自治系统编号 AS58453\nCERNET（教育网，主用于高校）骨干网自治系统编号 AS4538\nCSTNET（科技网）骨干网自治系统编号 AS7497\nBGP 边界网关协议，主要是用来连接网络上的独立系统的路由选择协议。主要功能是在传输过程中会选择最优的路由线路。比一般线路要好，但不使用cn2这种最优质线路。\n国外运营商 日本 常见线路：NTT、KDDI、IIJ、SoftBank（软银）、Telstra、PCCW\n新加坡 常见线路：NTT、Tata通信、Telstra、PCCW、sg.gs\n韩国 常见线路：KT、SK、LG\n香港 常用线路：PCCW、Telstra、HKBN、HKT、HGC、NTT（香港）、Azure、Google Cloud Platform、Gcorelabs、Tata通信\n俄罗斯 常见线路：RosTelecom（俄罗斯电信）、TTK（俄罗斯铁通）、MTS、Megfon、RETN\n英国 常见线路：Telia、Cogentco、Level3、Zayo、Tata通信\n实际体验（以往返总延迟排序） 最优： 香港IPLC/IEPL、日本IPLC/IEPL、香港CN2 GIA：价格高。\n日本SoftBank（推荐）：约100+ms。\n次优： 新加坡CN2：约200ms，价格稍高。\n日本IIJ：约200+ms。\n香港CMI：约200+ms。移动网可能好用（我不是），有高峰期。\n新加坡NTT：约300+ms。慎买。\n美国CN2\\美国AS9929（推荐）：约500ms。性价比高，网络审查宽松，且访问的大多服务器设在美国。\n差线路： racknerd等很廉价，绕路线路，但适合测试用。\n优质VPS推荐 BandwagonHost（搬瓦工）：日本软银$169/年（高配）。香港 CN2 GIA最低$899.99/年。\nv.ps(需实名):日本软银特价款约39、49欧元/年（经常缺货）。\nDMIT：美国CN2特价款$36.90/年（经常缺货）。\nZgoCloud（2021年新商家）：美国AS9929特价款$38.90/年。\nvmiss（2022年新商家）：有日本IIJ， 美国CN2、9929的平价大带宽产品。需要注意，他家IP虽然可以解锁大多服务，但使用的是广播ip。\n其它卖优质VPS的商家还有Vultr、Linode、digitalocean等。\n提示：\n机场很可能跑路，用机场一定要月付。\n北方地区日本线路表现更好。\n有些商家线路会绕路欧美，最好自测。\n香港vps：很可能有高峰期，便宜商家的机房容易受到攻击。认准口碑商家，否则不要买。\n韩国vps：用过1次，一个月后要求韩国身份实名，不知道是不是都这样。\n推荐：美国、新加坡vps表现好价格合适。日本vps极少数小问题，不影响使用。\n测试线路 测试全国到VPS的延迟 ipip.net的ping工具输入ip，选择中国，然后ping。\n路由跟踪 去程路由跟踪 方式一：下载BestTrace软件，点路由跟踪，输入ip，开始。\n方式二：ipip.net的traceroute工具选地区，输入ip，查看。\n回程路由跟踪 回程跟踪需要连接到VPS，执行以下命令\nyum install -y wget unzip \u0026amp;\u0026amp; wget https://cdn.ipip.net/17mon/besttrace4linux.zip \u0026amp;\u0026amp; unzip best ./besttrace [你的本地ip] -g cn ","date":"2023-03-13T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/vps/","title":"VPS 选购"},{"content":"排列组合 1.特殊元素和特殊位置优先策略 例 1. 由 0,1,2,3,4,5 可以组成多少个没有重复数字五位奇数？\n解析\r先排末位共有 $C_3^1$, 然后排首位共有 $C_4^1$, 最后排其它位置共有 $A_4^3$, 由分步计数原理得 $C_4^1 C_3^1 A_4^3=288$ 。\n2.相邻问题捆绑法: 题目中规定相邻的几个元素捆绑成一个组，当作一个大元素参与排列.\n例 1. A,B,C,D,E 五人并排站成一排，如果 A,B必须相邻且 B在 A的右边，则不同的排法有（ ）\nA、60 种 B、48 种 C、36 种 D、24 种\n解析\r把 A,B 视为一人，且 B 固定在 A 的右边，则本题相当于 4 人的全排列，$A_4^4$=24 种， 答案： D .\n例 2. 7 人站成一排 ,其中甲乙相邻且丙丁相邻,共有多少种不同的排法.\n解析\r可先将甲乙两元素捆绑成整体并看成一个复合元素，同时丙丁也看成一个复合元素，再与其它元素进行排列，同时对相邻元素内部进行自排。由分步计数原理可得共有 $A_5^5$$A_2^2$$A_2^2$= 480种不同的排法\n3.相离问题插空策略: 元素相离（即不相邻）问题，可先把无位置要求的几个元素全排列，再把规定的相离的几个 元素插入上述几个元素的空位和两端.\n例 1. 七人并排站成一行，如果甲乙两个必须不相邻，那么不同的排法种数是（ ）\nA、1440 种 B、3600 种 C、4820 种 D、4800 种\n解析\r除甲乙外，其余 5 个排列数为$A_5^5$种，再用甲乙去插 6 个空位有$A_6^2$种，不同的排法种数是$A_5^5$$A_6^2$=3600 种， 选 B.\n例 2. 某人射击八枪,命中四枪,四枪中恰好有三枪连在一起的情形的不同种数为?\n解析\r把连续命中的三枪看做一个整体a,剩下命中的一枪看做一个整体b,用插空法,把a,b两个元素按一定顺序插到剩下四枪形成的5个空隙里,是$A_5^2$=20\n4.定序问题: 例 1. 7 人排队，其中甲乙丙 3 人顺序一定（可以不相邻），共有多少不同的排法?\n解析\r(倍缩法) 对于某几个元素顺序一定的排列问题，可先把这几个元素与其他元素一起进行排列，然后用总排列数除以这几个元素之间的全排列数，则共有不 同排法种数是: $A_7^7 / A_3^3$\n(空位法) 设想有7把椅子让除甲乙丙以外的四人就坐共有$A_7^4$ 种方法，其余的三个位置甲乙丙共有（1）种坐法，则共有$A_7^4$ 种方法。\n5.有序分配问题逐分法: 有序分配问题指把元素分成若干组，可用逐步下量分组法.\n例 1. 有甲乙丙三项任务，甲需 2 人承担，乙丙各需一人承担，从 10 人中选出 4 人承担这三项任务，不同的选法种数是（ ）\nA、1260 种 B、2025 种 C、2520 种 D、5040 种\n解析\r先从 10 人中选出 2 人承担甲项任务，再从剩下的 8 人中选 1 人承担乙项任务，第三步从另外的 7 人中选1 人承担丙项任务，不同的选法共有 $C_{10}^{2}$$C_8^1$$C_7^1$=2520 种，选 C.\n例 2. 12 名同学分别到三个不同的路口进行流量的调查，若每个路口 4 人，则不同的分配方案有（ A）\nA、$C_{12}^{4}$$C_8^4$$C_4^4$ 种 B、3$C_{12}^{4}$$C_8^4$$C_4^4$ 种 C、$C_{12}^{4}$$C_8^4$$A_3^3$ 种 D、$\\frac{C_{12}^{4}C_8^4C_4^4}{A_3^3}$ 种\n6.元素不同的分配问题先选后排: 例 1. 4 名优秀学生全部保送到 3 所学校去，每所学校至少去一名，则不同的保送方案有多少种？\n解析\r把四名学生分成 3 组有 $C_4^2$ 种方法，再把三组学生分配到三所学校有 $A_3^3$ 种，故共有 $C_4^2$$A_3^3$=36 种方法.\n例 2. 5 本不同的书，全部分给 4 个学生，每个学生至少一本，不同的分法种数为（ ）\nA、480 种　B、240 种 C、120 种 D、96 种\n解析\rB. $C_5^3$$A_4^4$=240\n7.元素相同的分配问题隔板法: 例 1： 10 个三好学生名额分到 7 个班级，每个班级至少一个名额，有多少种不同分配方案？\n解析\r10 个名额分到 7 个班级，就是把 10 个名额看成 10 个相同的小球分成 7 堆，每堆至少一个，可以在 10 个小球的 9 个空位中插入 6 块木板，每一种插法对应着一种分配方案，故共有不同的分配方案为$C_9^6$=84 种.\n例 2： 若x+y+z+w=100,求这个方程组的自然数解的组数.\n解析\r我们认为0是自然数，所有存在0+0+0+100=100的情况，所以这里的元素 个数应为104个，即3个 0和100个1，这104个元素间有103个空位，中间插入 4个隔板，就会把这104个元素分成4堆，每堆对应 x,y,x,w,而挡板的放置方法有$C_{103}^{3}$\n8.限制条件的分配问题分类法: 例 1. 某高校从某系的 10 名优秀毕业生中选 4 人分别到西部四城市参加中国西部经济开发建设，其中甲同学不到银川，乙不到西宁，共有多少种不同派遣方案？\n解析\r因为甲乙有限制条件，所以按照是否含有甲乙来分类，有以下四种情况： ①若甲乙都不参加，则有派遣方案 $A_8^4$ 种；②若甲参加而乙不参加，先安排甲有 3 种方法，然后安排其余学生有 $A_8^3$方法，所以共有 3$A_8^3$；③若乙参加而甲不参加同理也有 3$A_8^3$种；④若甲乙都参加，则先安排甲乙，有 7 种方法， 然 后 再 安 排 其 余 8 人 到 另 外 两 个 城 市 有 $A_8^2$种 ， 共 有 7$A_8^2$方 法 . 所 以 共 有 不 同 的 派 遣 方 法 总 数 为 $A_8^4$ + 3$A_8^3$ + 3$A_8^3$ + 7$A_8^2$=4088 种.\n9.多元问题分类法： 例 1 （1）由数字 0，1，2，3，4，5 组成没有重复数字的六位数，其中个位数字小于十位数字的共有（ ）\nA、210 种 B、300 种 C、464 种 D、600 种\n（2）从 1，2，3…，100 这 100 个数中，任取两个数，使它们的乘积能被 7 整除，这两个数的取法（不计顺序）共有多少种？\n（3）从 1，2，3，…，100 这 100 个数中任取两个数，使其和能被 4 整除的取法（不计顺序）有多少种？\n解析\r（1）按题意，个位数字只可能是 0，1，2，3，4 共 5 种情况，分别有 $A_5^5$个，$A_4^1$$A_3^1$$A_3^3$ , $A_3^1$$A_3^1$$A_3^3$ , $A_2^1$$A_3^1$$A_3^3$ , $A_3^1$$A_3^3$个，合并总计 300 个,选 B.\n（2）被取的两个数中至少有一个能被 7 整除时，他们的乘积就能被 7 整除，将这 100 个数组成的集合视为全集I,能被 7 整除的数的集合记做 $\\overline{A}$ = { 7，14，21，$\\cdots$，98 } 共有 14 个元素,不能被 7 整除的数组成的集合记做 $\\overline{A}$ = { 1，2，3，4,$\\cdots$，100 } 共有 86 个元素；由此可知，从 A中任取 2 个元素的取法有 $C_{14}^{2}$，从 A中任取一个，又从$\\overline{A}$中任取一个共有 $C_{14}^{1}$$C_{86}^{1}$，两种情形共符合要求的取法有 $C_{14}^{2}$ + $C_{14}^{1}$$C_{86}^{1}$=1295 种.\n（3）将 I = { 1,2,3,$\\cdots$，100 } 分成四个不相交的子集，能被 4 整除的数集 A = { 4,8,12,$\\cdots$，100 }；能被 4 除余 1 的数集B = { 1,5,9,$\\cdots$，97 } ，能被 4 除余 2 的数集 C = { 2,6,$\\cdots$，98 } ，能被 4 除余 3 的数集 D = { 3,7,11,$\\cdots$，99 } ，易见这四个集合中每一个有 25 个元素；从 A中任取两个数符合要；从B,D 中各取一个数也符合要求；从 C中任取两个数也符合要求；此外其它取法都不符合要求；所以符合要求的取法共有 $C_{25}^{2}$ + $C_{25}^{1}$$C_{25}^{1}$ + $C_{25}^{2}$ 种.\n10.交 叉 问 题 集 合 法 ： 例 1. 从 6 名运动员中选出 4 人参加 4×100 米接力赛，如果甲不跑第一棒，乙不跑第四棒，共有多少种不同的参赛方案？\n解析\r设全集= {6 人中任取 4 人参赛的排列} ，A={甲跑第一棒的排列} ，B={乙跑第四棒的排列} ，根据求集合元素个数的公式得参赛方法共有： n(I)-n(A)-n(B)+n(A $\\cap$ B ) = $A_6^4$-$A_5^3$-$A_5^3$+$A_4^2$ = 252\n11.配对问题： 例 1. 5双相异的鞋共10只,现随机地取出6只,恰好能配成2双鞋的取法是多少?\n解析\r$C_{5}^{2} C_{6}^{1} C_{4}^{1}$=240\n12.多排问题单排法: 例 1. 8人排成前后两排，每排4人，其中甲乙在前排，丙在后排，共有多少排法？\n解析\r看成一排，某 2 个元素在前半段四个位置中选排 2 个，有 $A_4^2$种，某 1 个元素排在后半段的四个位置中选一个有 $A_4^1$种，其余 5 个元素任排 5 个位置上有 $A_5^5$种，故共有 $A_4^2$$A_4^1$$A_5^5$=5760 种排法.\n13.“至少”“至多”问题用间接排除法或分类法: 例 1. 从 4 台甲型和 5 台乙型电视机中任取 3 台，其中至少要甲型和乙 型电视机各一台，则不同的取法共有（ ）\nA、140 种 B、80 种 C、70 种 D、35 种\n解析\r至少要甲型和乙 型电视机各一台可分两种情况：甲型 1 台乙型 2 台；甲型 2 台乙型 1 台；故不同的取法有 $C_5^2$$C_4^1$ + $C_5^1$$C_4^2$ =70 台,选 C.\n14.部分合条件问题排除法: 例 1. （1）以正方体的顶点为顶点的四面体共有（ ）\nA、70 种 B、64 种 C、58 种 D、52 种\n（2）四面体的顶点和各棱中点共 10 点，在其中取 4 个不共面的点，不同的取法共有（ ）\nA、150 种 B、147 种 C、144 种 D、141 种\n解析\r（1）正方体 8 个顶点从中每次取四点，理论上可构成 $C_8^4$四面体，但 6 个表面和 6 个对角面的四个顶点共面都不能构成四面体，所以四面体实际共有$C_8^4$-12= 58 个.\n（2）10 个点中任取 4 个点共有 $C_{10}^{4}$种，其中四点共面的有三种情况：①在四面体的四个面上，每面内四点共面的情况为 $C_6^4$，四个面共有 4$C_6^4$个；②过空间四边形各边中点的平行四边形共 3 个；③过棱上三点与对棱中点的三角形共 6 个.所以四点不共面的情况的种数是 $C_{10}^{4}$ - 4$C_6^4$ -3-6=141 种.\n15.可重复的排列求幂法: 例 1. 把 6 名实习生分配到 7 个车间实习共有多少种不同方法？\n解析\r完成此事共分 6 步，第一步；将第一名实习生分配到车间有 7 种不同方案，第二步：将第二名实习生分配到车间也有 7 种不同方案，依次类推，由分步计数原理知共有 $A_{7}^{6}$种不同方案.\n16.上楼梯问题: 例 1. 10级台阶，某人可一步跨一级，也可跨两级，也可跨三级。 （1）他6步就可上完台阶的方法数是多少？ （2）他上完台阶的方法总数是多少？\n解析\r（1）按照 3，3，1，1，1，1 的走法有 $C_{6}^{2}$ 种，按照 3，2，2，1，1，1 的走法有 $C_{6}^{1} C_{5}^{2}$ 种，按照 2，2，2，2，1，1 的走法有 $C_{6}^{4}$ 种，所以恰好6步上完台阶的方法种数是 $C_{6}^{2}$+$C_{6}^{1} C_{5}^{2}$+$C_{6}^{4}$=15+60+15=90 .\n（2）上楼梯问题是典型的斐波那契数列，设爬n级台阶的解法总数为f(n)，因为规定每一步只能跨一级或两级或三级，则f(n)=f(n-1)+f(n-2)+f(n-3)。易知f(1)=1，f(2)=2，f(3)=4,递推可得f(4)=7,f(5)=13,f(6)=24,f(7)=44,f(8)=81,f(9)=149,f10)=274\n17.元素个数较少的排列组合问题可以考虑枚举法: 例 1. 设有编号为 1，2，3，4，5 的五个球和编号为 1，2，3，4，5 的盒子现将这 5 个球投入 5 个盒子要求每个盒子放一个球，并且恰好有两个球的号码与盒子号码相同，问有多少种不同的方法？\n解析\r从 5 个球中取出 2 个与盒子对号有 $C_5^2$种，还剩下 3 个球与 3 个盒子序号不能对应，利用枚举法分析，如果剩下 3，4，5 号球与 3，4，5 号盒子时，3 号球不能装入 3 号盒子，当 3 号球装入 4 号盒子时，4，5 号球只有1 种装法，3 号球装入 5 号盒子时，4，5 号球也只有 1 种装法，所以剩下三球只有 2 种装法，因此总共装法数为2$C_5^2$= 20 种.\n28.复杂的排列组合问题也可用分解与合成法: 例 1.（1）30030 能被多少个不同偶数整除？\n（2）正方体 8 个顶点可连成多少队异面直线？\n解析\r（1）先把 30030 分解成质因数的形式：30030=2×3×5×7×11×13；依题意偶因数 2 必取，3，5，7，11，13这 5 个因数中任取若干个组成成积，所有的偶因数为$C_5^0$+$C_5^1$+$C_5^2$+$C_5^3$+$C_5^4$+$C_5^5$= 32 个.\n（2）因为四面体中仅有 3 对异面直线，可将问题分解成正方体的 8 个顶点可构成多少个不同的四面体，从正方体 8 个顶点中任取四个顶点构成的四面体有$C_8^4$-12= 58 个，所以 8 个顶点可连成的异面直线有 3×58=174 对.\n19.利用对应思想转化法: 例 1. （1）圆周上有 10 点，以这些点为端点的弦相交于圆内的交点有多少个？\n（2）某城市的街区有 12 个全等的矩形组成，其中实线表示马路，从 A到 B的最短路径有多少种？\n解析\r（1）因为圆的一个内接四边形的两条对角线相交于圆内一点，一个圆的内接四边形就对应着两条弦相交于圆内的一个交点，于是问题就转化为圆周上的 10 个点可以确定多少个不同的四边形，显然有 $C_{10}^{4}$个，所以圆周上有10 点，以这些点为端点的弦相交于圆内的交点有 $C_{10}^{4}$个.\n（2）可将图中矩形的一边叫一小段，从 A到 B最短路线必须走 7 小段，其中：向东 4 段，向北 3 段；而且前一段的尾接后一段的首，所以只要确定向东走过 4 段的走法，便能确定路径，因此不同走法有 $C_{7}^{4}$种.\n20.全错位排列问题公式法: 例 1. 分别编有 1，2，3，4，5 号码的人与椅，其中i 号人不坐i 号椅（i = 1,2,3,4,5）的不同坐法有多少种？\n解析\r全错位排列是组合数学中的经典问题之一，使用公式不容易出错： $$ D(n)=(n-1) \\cdot[D(n-1)+D(n-2)] . $$ 又易知, $D(1)=0, D(2)=1$. 由递推公式可得: $D(3)=2, D(4)=9，D(5)=44$\n21.环排问题 例 1. 8 人围桌而坐,共有多少种坐法?\n解析\r$\\mathrm{n}$ 个不同元素作圆形排列,共有 $(\\mathrm{n}-1)$!种排法.即7! 如果从 $\\mathrm{n}$ 个不同元素中取出 $\\mathrm{m}$ 个元素作圆形排列共有 $\\frac{1}{n} A_n^m$ 。\n22.正难则反策略 例 1. 从 0,1,2,3,4,5,6,7,8,9 这十个数字中取出三个数，使其和为不小于 10 的 偶数,不同的取法有多少种？\n解析\r这问题中如果直接求不小于 10 的偶数很困难, 可用总体淘汰法。这十个数字 中有 5 个偶数 5 个奇数, 所取的三个数含有 3 个偶数的取法有 $C_5^3$, 只含有 1 个偶数 的取法有 $C_5^1 C_5^2$, 和为偶数的取法共有 $C_5^1 C_5^2+C_5^3$ 。再淘汰和小于 10 的偶数共 9 种, 符合条件的取法共有 $C_5^1 C_5^2+C_5^3-9$\n23.平均分组问题 例 1. 6 本不同的书平均分成 3 堆,每堆 2 本共有多少分法？\n解析\r分三步取书得 $C_6^2 C_4^2 C_2^2$ 种方法, 但这里出现重复计数的现象, 不妨记 6 本书为 $A B C D E F$, 若第一步取 $A B$, 第二步取 $C D$, 第三步取 $E F$ 该分法记为 (AB, $C D, E F)$, 则 $C_6^2 C_4^2 C_2^2$ 中还有 (AB, $\\left.\\mathrm{EF}, \\mathrm{CD}\\right)$, (CD, AB, $\\mathrm{EF}$ ), (CD, EF, AB) (EF, CD, AB), (EF, AB, CD) 共有 $A_3^3$ 种取法, 而这些分法仅是 ( $\\left.\\mathrm{AB}, \\mathrm{CD}, \\mathrm{EF}\\right)$ 一种分法, 故共有 $C_6^2 C_4^2 C_2^2 / A_3^3$ 种分法。\n24.分类与分步策略 例 1. 有红、黄、兰色的球各 5 只,分别标有 A、B、C、D、E 五个字母,现从中取 5 只,要求各字母均有且三色齐备,则共有多少种不同的取法\n解析\r按颜色分有1 1 3和1 2 2 两种，各3种方案。2.分字母，1 1 3对应有$C_5^1$$C_4^1$$C_3^3$共20种，1 2 2对应$C_5^1$$C_4^2$$C_2^2$共30种，320+330=150\n例 2. 在一次演唱会上共 10 名演员,其中 8 人能能唱歌,5 人会跳舞,现要演出一个 2 人唱歌 2 人伴舞的节目,有多少选派方法？\n解析\r10 演员中有 5 人只会唱歌, 2 人只会跳舞 3 人为全能演员。选上唱歌人员为 标准进行研究只会唱的 5 人中没有人选上唱歌人员共有 $C_3^2 C_3^2$ 种, 只会唱的 5 人中只 有 1 人选上唱歌人员 $C_5^1 C_3^1 C_4^2$ 种, 只会唱的 5 人中只有 2 人选上唱歌人员有 $C_5^2 C_5^2$ 种, 由分类计数原理共有 $C_3^2 C_3^2+C_5^1 C_3^1 C_4^2+C_5^2 C_5^2$ 种。\n","date":"2022-12-10T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/math/","title":"数学"},{"content":"Let’s Encrypt 是一个免费的，自动化的，开放的证书颁发机构（CA），为公众的利益而运行。 它是一项由 Internet Security Research Group（ISRG）提供的服务。\nacme.sh 则是实现了 acme 协议, 可以从 letsencrypt 生成免费的证书。\nLet’s Encrypt 速率限制 每个注册网域(Registered Domain) 的凭证颁发数量，限制为每周50 张 更新凭证受到重复凭证限制，一个星期内仅能颁发5 张重复的凭证。 网域验证失败限制，对于每个帐号每域名每小时5 次的限制。 每个IP 位置每3 个小时最多能建立10 个帐号。 如果你达到速率限制，你只能等待一个星期直到速率限制结束。\nacme申请证书 安装 acme.sh curl https://get.acme.sh | sh sudo apt install socat # 安装socat 选择默认 CA Zerossl 从 acme.sh v 3.0.0 开始，acme.sh 使用 Zerossl 作为默认 ca，您必须先注册帐户（一次），然后才能颁发新证书。\n~/.acme.sh/acme.sh –register-account -m xxxx@xxxx.com Let\u0026rsquo;s Encrypt 如果需要更换Let\u0026rsquo;s Encrypt可以使用如下命令：\n~/.acme.sh/acme.sh --set-default-ca --server letsencrypt 通过 http 方式申请证书 Webroot模式 这种方式需要你的服务器上面已经部署了网站环境。Acme 自动在你的网站根目录下放置一个文件,来验证你的域名所有权,完成验证. 然后就可以生成证书了.\n# 生成 RSA 证书： ~/.acme.sh/acme.sh --issue -d example.com -w /var/www/_letsencrypt/ # 生成 ECC 证书： ~/.acme.sh/acme.sh --issue -d example.com -w /var/www/_letsencrypt/ --keylength ec-256 /var/www/_letsencrypt/ 为 example.com 站点下的 /.well-known/acme-challenge/ 证书请求目录。\n80 端口空闲的证书申请方式 ~/.acme.sh/acme.sh --issue -d example.com --standalone 安装证书到指定文件夹 # 把密钥和证书安装到 /root 目录，并改名为 private.key 和 cert.crt。 ~/.acme.sh/acme.sh --installcert -d mydomain.com --key-file /root/cert/private.key --fullchain-file /root/cert/cert.crtchmod -R 755 /root/cert 更新（后续操作） 更新证书 手动更新 ~/.acme.sh/acme.sh --renew -d example.com --force 自动更新 安装 acme.sh 时会自动创建一个 cronjob，每天定期检查所有证书，如果证书需要更新会自动更新证书。 通过 crontab -l 查看 crontab 任务:\n46 0 * * * \u0026#34;/root/.acme.sh\u0026#34;/acme.sh --cron --home \u0026#34;/root/.acme.sh\u0026#34; \u0026gt; /dev/null 更新 Acme 脚本 升级 Acme.sh 到最新版本\n~/.acme.sh/acme.sh --upgrade 如果你不想手动升级, 可以开启自动升级:\n~/.acme.sh/acme.sh --upgrade --auto-upgrade DNS 申请证书(通常只支持付费域名) 几个 CA 的简单对比\n功能 LE Buypass ZeroSSL SSL.com Google Public CA 有效期 90 天 180 天 90 天 90 天 90 天 多域名 支持 支持，最多 5 个 支持 收费支持 支持 泛域名 支持 不支持 支持 收费支持 支持 Rate Limit 有 有 收费无 未知 有 GUI 管理 否 否 有 有 无 ECC 证书链 否 否 有 未知 无 客户支持 社区 收费 收费 收费 收费 cloudflare 使用全局 API 密钥，您需要登录您的 Cloudflare 帐户以获取您的API 密钥\nexport CF_Key=\u0026#34;sdfsdfsdfljlbjkljlkjsdfoiwje\u0026#34; export CF_Email=\u0026#34;xxxx@sss.com\u0026#34; 颁发证书：\n./acme.sh --issue --dns dns_cf -d example.com -d www.example.com 阿里云 DNS 申请方式 export Ali_Key=\u0026#34;abcd\u0026#34; export Ali_Secret=\u0026#34;xxxxxxxxxx\u0026#34; # RSA 证书 acme.sh --issue --dns dns_ali -d example.com -d *.example.com # ECC 证书 acme.sh --issue --dns dns_ali -d example.com -d *.example.com --keylength ec-256 Ali_Key 和 Ali_Secret 需要从阿里云RAM访问控制中获取。\nDNSPod 申请方式 export DP_Id=\u0026#34;1234\u0026#34; export DP_Key=\u0026#34;xxxxxxxxxxx\u0026#34; acme.sh --issue --dns dns_dp -d example.com -d www.example.com 文档 如何颁发证书\n使用 DNS API\n选项和参数\n","date":"2022-10-24T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/acme/","title":"acme.sh 申请证书"},{"content":"前言 云是我们常用的服务，aws是头部厂商，但我们还有更多选择，以降低价格。即使aws有高昂且复杂的定价，仍有很多人使用，所以本文也将介绍。\n目前我在使用的云存储是Backblaze B2（兼容S3 API），价格仅为 Amazon S3、Microsoft Azure 和 Google Cloud 的1/4。\n我们同样需要一个CDN缓存加速（cloudflare 与传统 CDN 不同，CloudFlare 处理对网站的所有请求，能够阻止针对网站的攻击，可以再加到传统CDN前作为防护），CDN在用户第一次请求后，会在接近用户的区域缓存源服务器的静态资源（没人请求不缓存，不主动和服务器保持同步），后续访问就更加快速，并降低服务器压力，可以使用cloudfront免费套餐，如果每月传出超过 1T 数据，可以考虑使用 bunny CDN。\nS3 Bucket桶 桶就类似于根文件夹，其命名必须全局性唯一。也就是说，如果别人已经创建了命为X的Bucket，你就不能再用X作为桶的名字了。\nEvents事件 在S3中，可以定义很多事件及其处理函数。比如当文件被创建，修改，删除，复制时，触发Lambda。这样就可以构建Event Driven Architecture，比如：新文件到S3 -\u0026gt; 触发Lambda处理函数 -\u0026gt; 处理结束后通知AppSync/GraphQL API -\u0026gt; 通知用户文件已经处理完毕。\nS3费用决定因素 官方：存储和管理数据时需要考虑六大 Amazon S3 成本组成：存储定价、请求和数据检索定价、数据传输和传输加速定价、数据管理和分析定价、复制定价以及使用 S3 Object Lambda 处理数据的价格。\n通常我们关注存储类型、储存数据量、请求量、数据传输的费用。\n存储类型 S3 标准 S3 标准是一种通用对象存储平台，提供较低的延迟和较高的吞吐量，因此非常适合各种使用案例，包括云应用程序、动态网站、内容分发、移动和游戏应用程序以及大数据分析。\nS3 智能分层 ——通用选它 S3 智能分层可自动识别并将不常访问的数据（30天内未访问的数据）移动到成本较低的基础架构中。当访问不频繁层中的对象时，它会自动移回更高性能层，并且30天时钟重新启动。在访问模式发生变化时，在两个访问层（频繁访问层和不频繁访问层）之间移动数据来实现自动节省成本，非常适用于访问模式未知或不断变化的数据。\nS3标准-IA（不频繁访问）——备份选它 S3 Standard-IA 适用于不常访问（超过30天访问一次）、但在需要时要求快速访问的数据。提供与“S3 标准”相同的高持久性、高吞吐量和低延迟，成本较低且性能出色使得“S3标准–IA”很适合长期存储和备份，以及用作灾难恢复文件的数据存储。\nS3 单区域 - IA（不频繁访问） S3标准-IA 的单区域存储，此类别不会自动在至少三个AZ上存储数据。\nS3 Glacier 即时检索 Amazon S3 Glacier Instant Retrieval 是一种归档存储类，可以为很少访问（超过90天访问一次）且需要毫秒级检索速度的长期数据提供最低成本的存储。\nS3 Glacier 灵活检索（前称为 S3 Glacier） S3 Glacier Flexible Retrieval 为每年访问 1—2 次且异步检索的归档数据提供低成本存储，数据检索时间可配置，从数分钟到数小时不等。\nAmazon S3 Glacier 深度档案 支持长期保留和数字化保存一年可能访问一到两次的数据，数据检索时间为 12 小时以内。\ncloudfront Origin domain ：源域，选S3 存储桶需配置Alternate Domain Names作为加速站点，写自己解析过的域名即为加速的站点\nAmazon S3 存储桶– DOC-EXAMPLE-BUCKET.s3.us-west-2.amazonaws.com\n配置为网站的 Amazon S3 存储桶– https://DOC-EXAMPLE-BUCKET.s3-website.us-west-2.amazonaws.com\nMediaStore 容器– examplemediastore.data.mediastore.us-west-1.amazonaws.com\nMediaPackage 端点– examplemediapackage.mediapackage.us-west-1.amazonaws.com\n亚马逊 EC2 实例– ec2-203-0-113-25.compute-1.amazonaws.com\nElastic Load Balancing 负载均衡器– example-load-balancer-1234567890.us-west-2.elb.amazonaws.com\n您自己的网络服务器– https://www.example.com\n自选ip失败经历 查看官方公布的ip段（我们只需要边缘节点ip-\u0026ldquo;CLOUDFRONT_REGIONAL_EDGE_IP_LIST\u0026rdquo;，因为GLOBAL站点会自动判断离边缘节点最近的区域和进行健康检查，再连到边缘节点） 由于给的ip是CIDR格式，我们需要转换。先JSON转列表。然后CIDR转ip（因为在线转不支持批量转换，所以建议下载这个工具），重命名为cidr2ip.exe，新建cidrs.txt，把列表复制进去，cmd执行cidr2ip -f cidrs.txt可得很大一列ip。最后ip批量查询，下载后可以看到ip地区，复制你所需地区的ip（查询速度会很慢，我的vps是日本的，排在最前面，运气很好没有查询很久）。\n创建Cloud front测速链接\naws首页搜索cloud front 创建分配\n源域填写能测速的地址：cachefly.cachefly.net 协议：匹配查看器\n自动压缩对象：No 缓存键和源请求（选择第二项）：Legacy cache settings 创建\n复制得到的域名 打开显示为测速地址即可（需要等到部署完成）\n使用CloudflareSpeedTest](https://github.com/XIU2/CloudflareSpeedTest)优选ip， cmd输入CloudflareST.exe -url xxxxxxxxxxx.cloudfront.net/100mb.test发现ip全部不能用。 aws查看vcpu ","date":"2022-10-07T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/cloud-service/","title":"云服务"},{"content":"本文建议只阅读前4小节。主要参考文章https://kalacloud.com/blog/postman-tutorial。\nAPI API的英文即 Application Programming Interface 首字母的缩写，直译过来的意思就是：程序之间的接口。我更倾向于把API理解为，程序之间的合约。有关 API 是什么及它的意义这里就不展开讲了。\nchrome浏览器开发者工具\n勾选上谷歌开发者工具的preserve log，保留上一个页面接口调用信息，从而方便我们查看\nPostman 界面导航说明 请求：\nparams：get请求传参。\nAuthrization：鉴权\nHeaders：请求头\naccept:客户端接收的数据类型。\ncontent-type:客户端发送给服务器的数据类型\nuser-agent:客户端的类型\nxmlhttprequest:异步请求\nBody：Post请求传参\nnone：没有参数\nform-data：文件上传（包含键值对和文件上传）\nx-www-from-urlencodeed：表单请求（键值对）\nraw：使用原始数据格式请求（JSON，XML，HTML，Text，Javascript）\nbinary：二进制文件上传。\nPre-request-script：请求之前的脚本。\nTests；请求之后的脚本。\nSetting：设置\nCookies：用于自动管理Cookie的功能\n响应：\nBody：返回的信息\nPretty（各种格式查看返回数据）\nRaw（文本格式）\nPreview（网页）\nCookie：响应Cookie\ntoken鉴权码：\ncsrf_token：一般情况下有效期是7-15天。\naccess_token：一般情况下有效期是10分钟-2小时\nHeaders：响应头\nTestResults：测试结果\n200 响应码\nGET 请求 GET 请求基本操作 （1）点击主界面「+」号，新建一个请求页\n（2）选择 GET 请求命令\n（3）输入 API 地址\n在 GoRest API 设计中 GET 请求无需鉴权，所有我们直接点击「Send」即可远程调取服务器信息。\n如果我们只想看调取其中一位用户的信息应该怎么办呢？我们可以在 API URL 中带上参数。\n带参数的 GET 请求 如果我们想查询 ID 为 2043 的用户信息，我们只需要在请求页面中的 Params(参数) 标签页的 KEY - VALUE 内填写对应的参数即可，之后 Postman 会自动在 API URL 中生成你填写的参数，使 URL 带上参数 GET 请求。\nhttps://gorest.co.in/public/v1/users?id=2043 设置完成后，点击「Send」\n我们可以看到，返回值中仅包含我们请求的 user id 为 2043 的用户信息。\nGET 请求中的多条件查询 有时，我们需要使用 API 进行多条件查询操作，比如想找 name 值为 kalacloud.com ，同时 gender 值为 male 的用户。（特别提示：此格式是通用写法，但最终要看 API 的开发者如何约定调用方式）\nBaseURL + ResourceName + ? + key1 = value1 + \u0026amp; + key 2 = value 2 …… 主 URL 之后使用 ? 连接参数，参数与参数之间使用 \u0026amp; 连接符连接。\nhttps://gorest.co.in/public-api/users/?name=kalacloud.com\u0026amp;gender=male 当然，我们可以直接在 Postman 的 Params 中直接填写 KEY - VALUE\n让 Postman 帮我们生成，然后点击「Send」\n可以看到 API GET 调取了我们设定的两个 VALUE 值的 data 信息。\n特别提示，你可以点击右上角的「Bulk Edit」进行参数的批量编辑\nPOST 请求 POST 方式一：模仿浏览器\n在发送一个get请求之后，postman会自动保存cookis，我们只需复制 Payload 的数据格式到 body ，复制 x-csrf-token 到 Headers ，发送这个 POST 请求\n自动方式可以参考\nPOST 方式二：鉴权 在 Authorization 中添加鉴权方式和密钥，postman会自动添加到Headers，按照api写入所需body，发送这个 POST 请求\n用 Postman 发送第一个 PUT 更新请求 PUT 请求一般用于更新服务器已有资源，如果服务器中没有对应的资源，那么 PUT 会创建相应的资源（特别提醒：虽然 PUT 有创建新资源的功能，但是否能创建成功，最终取决于你调用的 API 是否支持此功能）\n打开你的 Postman 我们来创建一个 PUT 请求。\n点击「+」号，新建一个请求页\n请求类型选择「PUT」\n根据第6节我们使用 POST 请求创建的资源 ID 为 1475 ，又根据 GoRest API 的文档得知，修改资源的 API 地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PUT 修改 ID 为 1475 资源的请求地址应该写：\nhttps://gorest.co.in/public/v1/users/1475 选择在 Body 标签中填写 JSON 格式的资源修改信息。我们将 1475 中的邮箱由\nJiangChuan@kalacloud.com 修改为 Hi@kalacloud.com，所以我们在 Body 中填写以下代码。\n{ \u0026#34;name\u0026#34;: \u0026#34;kalacloud\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;Male\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;Hi@kalacloud.com\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;Active\u0026#34; } 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 PUT 请求 如上图所示，可以看到红4位置 响应代码返回 200 ，这说明 PUT 请求已经执行成功。 返回的 Body 信息中，email 字段已经更新为 Hi@kalacloud.com 用 Postman 发送第一个 PATCH 更新请求 PATCH 请求一般用于服务器资源的部分更新，它相对于 PUT 提交的数据更少，不用提整个数据，只需要提交需要修改的字段即可。有关 PUT 和 PATCH 的更多区别，可查看本文第9节。\n打开你的 Postman 我们来创建一个 PATCH 请求。\n点击「+」号，新建一个请求页\n请求类型选择「PATCH」\n根据第6节我们使用 POST 请求创建的资源 ID 为 1475 ，又根据 GoRest API 的文档得知，修改资源的 API 地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PATCH 修改 ID 为 1475 资源的请求地址应该写，到这里都和 PUT 请求修改资源的方法一样。\nhttps://gorest.co.in/public/v1/users/1475 选择在 Body 标签中填写 JSON 格式的资源修改信息。上一节我们已经将 ID 为 1475 资源的邮箱改为 Hi@kalacloud.com ，接着我们用 PATCH 请求把这个邮箱改为\nHelloWord@kalacloud.com { \u0026#34;email\u0026#34;:\u0026#34;HelloWord@kalacloud.com\u0026#34; } 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 PATCH 请求 如上图所示，可以看到红4位置 响应代码返回 200 ，这说明 PATCH 请求已经执行成功。\n返回的 Body 信息中，email 字段已经更新为\nHelloWord@kalacloud.com PUT 和 PATCH 的区别 在 HTTP 协议中，PUT 和 PATCH 都是用于更新服务器资源的命令，但他们有着不同的格式和用途。\nPUT 请求：一般用于更新服务器已有资源，如果服务器中没有对应的资源，那么 PUT 会创建相应的资源（特别提醒：虽然 PUT 有创建新资源的功能，但是否能创建最终取决于你调用的 API 是否支持此功能）\nPATCH 请求：用于局部更新服务器现有资源，它不用像 PUT 更新资源中的一点点也要提交所有字段信息，PATCH 更新哪个字段就提交哪个字段的更新信息即可。\n举例说明PUT 和 PATCH 的区别：\n同样是更新资源中的 Email 信息，PUT 需要带上资源中的所有信息，然后在更新（上图）\n而 PATCH 则仅需要提交更新部分，即仅提交邮箱信息即可（下图）\n那么，如果 PUT 像 PATCH 一样仅提交资源的局部信息会发生什么呢？会 400 报错。\nPUT 不论修改多少，必须把修改资源的全部字段写全，否则会 400 报错。\n用 Postman 发送第一个 DELETE 删除请求 我们在上文讲了获取(GET)，创建(POST)，更新(PUT / PATCH) 请求，接着我们来说说删除(DELETE) 请求。顾名思义，DELETE 请求执行可删除整个资源。我们来直接实践一次你就明白了。\n打开你的 Postman ，跟随本教程一起创建一个 DELETE 请求。\n点击「+」号，新建一个请求页\n请求类型选择「DELETE」\n我们来把上文刚刚创建的 ID 为 1475 的资源彻底删掉。根据 GoRest API 的文档得知，删除资源的 API 请求地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PATCH 删除 ID 为 1475 资源的请求地址应该写：\nhttps://gorest.co.in/public/v1/users/1475 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 DELETE 请求，删除对应的资源。 如上图所示，提交 DELETE 请求后，响应代码为 204 ，返回的 body 为空，删除成功。\n特别提示：在 GoRest 的文档说明中，特别说了 DELETE 删除返回值的状态。\nAPI 返回状态具体是怎么样的，还要看 API 的开发者是如何约定的，并非只有返回 200 才是成功的。\nPostman 中的全局变量、环境变量、集合变量的设置 Postman 设置变量的意义 Postman 里有多种变量，我们可以把某些重要的值抽象出来变成变量，方便我们做场景 / 条件切换。比如，我们可以把 baseURL 抽出来，在环境变量里设置「生产环境变量」和「测试环境变量」，之后，我们只需要切换标签即可快速将数据从一个环境切换到另一个环境中，非常方便。\nPostman 常用的三种变量形式 全局变量：全局变量一旦声明，即可应用到 Postman 中所有测试的 API 中。任何请求都可以直接使用全局变量，它的作用域是全局的。 环境变量：Postman 的环境变量可以理解为一组选项，当这组环境变量选项被选中时，才会生效，特别适合「生产环境」和「测试环境」之间的切换等应用场景。 集合变量：集合变量是针对集合（Collections）生效的，一个集合下可能有 N 条 API 请求，集合变量可以一次修改集合下的所有变量数值。 以上三种变量的作用域从大到小为 全局 集合 环境，当三个变量形式同时作用于一个 API 测试条时，Postman 会优先使用最小作用域变量。\n如何在 Postman 设置全局变量与环境变量 新建一个请求页，点击右上角的「小眼睛」进入变量设置页。 页面上方为「环境变量」，我们点击编辑设置环境变量名为「卡拉云_API 测试环境」 VARIABLE 设置为 baseURL，INITIAL VALUE 设置为 https://gorest.co.in ，保存之后我们就可以使用 {{baseURL}} 变量来替代 API URL 了。 页面下方为「全局变量」，VARIABLE 设置为 kalacloud_id，INITIAL VALUE 设置为 2312 (2312 为 GoRest 中的一个已存在的用户信息 ID)，保存后我们就可以使用 {{kalacloud_id}} 变量来替代 ID 值了。 我们来一起测一下刚刚设置好的「全局变量」和「环境变量」是否生效。\n新建一个 GET 请求页，地址栏填入： {{baseURL}}/public/v1/users?id={{kalacloud_id}} 点击「Send」 返回响应代码为 200 说明请求成功，返回的 Body 信息是 ID 为 2312 的用户信息，说明全局和环境变量已生效。\n如何在 Postman 设置集合变量 集合变量是指应用在整个集合所有请求中的变量，集合变量优先与其他变量应用与请求，也就是说如果有集合变量，那么其他变量与集合变量相冲突的化，优先执行集合变量。\n集合变量很适合临时修改整个集合中的变量，来针对集合进行测试。\n打开你的 Postman，我们一起操作一遍。\n选中一个集合，点击集合标题右侧「\u0026hellip;」选择编辑。 进入集合设置页，选择 Variables 设置集合变量 此时，整个集合下所有请求页，都应用了此集合变量。 如何使用 Postman Pre-request scripts 预请求脚本 Pre-request scripts 预请求脚本是在 API 请求之前执行的脚本，我们可以临时更改请求的某些变量。一般预请求脚本有这么两种常见的应用场景。(1)设置动态请求头信息。 (2)设置动态请求参数信息。比如，当我们要请求一个与时间有关的资源时，我们可以在预请求脚本中添加 timestamp 字段，这是一个动态值，我们可以通过前置请求脚本来实现。\n举例说明：比如我们要在 header 中包含一个时间戳，我们可以这样操作\n在 Pre-request scripts 中添加获取时间戳的代码 pm.environment.set(\u0026#34;TimeStampHeader\u0026#34;,new Date()); 在 header 中添加预脚本中的变量 TimeStampHeader 当请求时，Postman 会先执行预脚本获取时间戳，然后再将时间戳赋予到 header 中 timestamp 值中。 接着我们来执行这条 GET 请求，打开控制控制台，在控制台中，可以看到 Request Headers 中包含我们刚刚设置的时间戳 「timestamp」特别提示：有关控制台的讲解，在本教程第14节。 附：常用的 Pre-request scripts ：\n获取变量\n//通用语法 postman.getGlobalVariable(\u0026#34;key\u0026#34;); //获取全局变量 postman.getEnvironmentVariable(\u0026#34;key\u0026#34;); //获取环境变量 //postman native app 特有语法 pm.globals.get(\u0026#34;key\u0026#34;); //获取全局变量 pm.environment.get(\u0026#34;key\u0026#34;); //获取环境变量 设置变量\n//通用语法 postman.setGlobalVariable(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置全局变量 postman.setEnvironmentVariable(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置环境变量 //postman native app 特有语法 pm.globals.get(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置全局变量 pm.environment.get(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置环境变量 清除变量\n//通用语法 postman.clearGlobalVariable(\u0026#34;key\u0026#34;); //清除全局变量 postman.clearEnvironmentVariable(\u0026#34;key\u0026#34;); //清除环境变量 //postman native app 特有语法 pm.globals.unset(\u0026#34;key\u0026#34;); //清除全局变量 pm.environment.unset(\u0026#34;key\u0026#34;); //清除环境变量 将数组、嵌套对象存储到全局\u0026amp;环境变量中\n//将数组储存到环境变量中 var array = [1, 2, 3, 4]; postman.setEnvironmentVariable(\u0026#34;array\u0026#34;, JSON.stringify(array)); //将嵌套对象储存到环境变量中 var obj = { a: [1, 2, 3, 4], b: { c: \u0026#39;val\u0026#39; } }; postman.setEnvironmentVariable(\u0026#34;obj\u0026#34;, JSON.stringify(obj)); //从环境变量中获取数组对象 var array = JSON.parse(postman.getEnvironmentVariable(\u0026#34;array\u0026#34;)); //从环境变量中获取嵌套对象/json对象 var obj = JSON.parse(postman.getEnvironmentVariable(\u0026#34;obj\u0026#34;)); 如何创建 Postman Tests 测试脚本 - Postman 断言功能 在 Postman 中 Pre-request 和 Tests 是两兄弟，一个是在调用前执行（Pre-request），一个是在调用后执行（Tests），我们可以在 Tests 中使用 JavaScript 校验代码协助我们验证结果，可以说 Tests 是 Postman 的断言功能\nPostman Tests 断言的实际应用 Postman 状态类断言 1.我们首先创建一个 GET 请求，然后点击 Postman 中 Tests 标签，进入断言设置。\n2.我们可以在右侧已经预设好的断言代码，我们先点击「Status code: Code is 200」，可以看到预设的代码直接写入编辑框。这段代码的意思是，如果执行调用，服务器返回响应代码为 200 时，判断为 PASS 即调用成功。\n3.点击「Send」执行 GET 请求，返回的断言可以在 Test Results 中看到结果。\n4.绿色的 PASS，说明服务器返回的响应代码为 200 ，调用成功。\nPostman 结果比较类断言 我们再添加一条带有变量的 JavaScript 断言设置，比较预期结果和实际返回结果之间是否一致。\n我们刚刚 GET 请求了 ID 2312 的用户信息，其中 name 的值为 kalacloud\n那么我们接下来写一个 JS 判断预期与返回结果是否一致。即预期为 name 的值为「kalacloud」，写断言自动判断返回结果的name值是否也是「kalacloud」\n1.在 Tests 选项卡右侧选择「Response body:JSON value check」，我们来检测 ID 为 2312 的返回值中，name 的值是否为 kalacloud\n2.我们将「Your Test Name」替换为「检查 ID 为 2312 的 name 返回值为 kalacloud」让这条测试的名字直接反应出我们想测试的内容。\n3.使用\njsonData.data[0].name 代替jsonData.value ，即检测第一个返回值中的 name 的 value\n4.检测返回值：在 to.eql() 中输入待检测值 \u0026quot;kalacloud\u0026quot;，即需要检测的 text。\n5.代码如下，你可以复制并根据你的情况简单修改，然后在 Postman 中，跟随教程一起测试。\n特别注意：这里的 ID = 2312 是我这里的情况，你需要根据你的情况进行相应修改。\npm.test(\u0026#34;Status code is 200\u0026#34;, function () { pm.response.to.have.status(200); }); pm.test(\u0026#34;检查 ID 为 2312 的 name 返回值为 kalacloud\u0026#34;, function () { var jsonData = pm.response.json(); pm.expect(jsonData.data[0].name).to.eql(\u0026#34;kalacloud\u0026#34;); }); 如何在 Postman 中使用控制台 控制台可以非常直观的显示当前调用的一系列信息，我们可以在「菜单 → view → Show Postman Console」或者点击 Postman 左下角的「Console」图标，打开控制台。\n我们可以在 Tests 测试脚本中加入 console.log 来显示我们需要在控制台显示的调用信息。\n如上图，我们在 Test 脚本中加入以下代码\nconsole.log(\u0026#34;本次测试 id 值为\u0026#34;,pm.variables.get(\u0026#34;kalacloud_id\u0026#34;)); 可以显示隐藏在变量下面的具体变量值，方便我们测试时，进行相应的判断。\n如何使用 Runner 批量执行测试，批量更换变量测试 当我们有一组 API 且这一组之间相互关联的关系，使用手动测试效率非常低。这时，我们就要用到 Postman 的批量执行（Runner）功能，Runner 不仅可以批量执行 API 调用，还可以批量更换变量。掌握此方法，大幅度提升 API 测试效率。\n打开你的 Postman ，跟随本教程一起操作一遍吧。\n本次批量 API 测试，我们先导入一个 CSV 文件，文件中包含四组等待新建的用户信息，将 CSV 文件导入 Runner 中待用。 新建 POST 调用页，在 Body 里写上创建用户所需信息，所有值使用变量替代，这些变量将从 CSV 中读取。 新建 GET 调用页，使用 email 作为查询 KEY 进行查询，如果上一步 POST 执行成功，那么 GET 就能成功查询到新建用户对应的 email，查询到表示 POST 创建成功。 在「卡拉云_kalacloud.com_批量测试」这个集合中设置 Tests 中设置全局断言，每当一个调用执行完毕时，进行 Tests 一次判断。 pm.test(\u0026#34;Status code is 200\u0026#34;, function () { pm.response.to.have.status(200); }); 打开「卡拉云_kalacloud.com_批量测试」合集的「Run Collection」的设置页 Iterations：这是测试组，我们 CSV 文件中有 4 组测试条目 Delay：延迟，一般填 2000 毫秒，太密集的请求，容易被服务器拒绝 Data：这里选择我们刚刚的 CSV 文件：kalacloud_users.csv 导入测试数据 点击 RUN 蓝色按钮开始执行批量测试 从上图可以看到，Postman 按顺序提交了 POST 请求和 GET 请求，并连续测试了从 CSV 文件导入的 4 组数据。一键批量测试，相当高效。\n","date":"2022-08-04T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/test/","title":"测试接口"},{"content":"购买配件 配件 用途 mq2 pro 续航版 提升头戴舒适度，可以按照自己需要选择没有续航的 磁吸镜片 近视适用 USB3.0串流线 玩steam的游戏需要和电脑串流 网络 国内quest2用户应该已经具备上外网的条件，不再赘述。\nquest2需要无线网络链接，解决网络问题一般有以下方式：\n软路由openwrt 刷路由器，这个方式比较直接，我认为日常不适用的场景较多，所以没有用。 电脑开个VMware虚拟机安装OpenWrt,有点麻烦。参考文章 电脑热点 sstap方法(推荐) 打开科学上网，注意用全局模式并且允许局域网连接。\n下载sstap，我使用的1.0.9.9版本。\n配置并打开sstap 打开热点，并打开 网络和Internet设置 -\u0026gt; 更改适配器选项 -\u0026gt; 右键 SSTAP 1 -\u0026gt; 属性 -\u0026gt; 共享 ，然后就可以连热点了。 TUN模式方法 如果你的电脑同时有网线和无线网卡，clash和v2rayN的TUN模式开热点应该也可以。\n注册，接受邀请领取30美金奖励 只玩破解版无需受邀，无需此步骤！\n使用outlook、gmail等邮箱和原生ip至少提前1天注册facebook账号。\n接受邀请比较麻烦，有需要直接去找别人代操作受邀！\n以下方式成本过高，仅作为邀请别人的参考！\n我试了多地vps，原生ip也全都出现Ineligible Country​，原因是服务器厂商用的数据中心ip（type为hosting），会被识别屏蔽。所以要用住宅代理（type为isp），由于成本高，服务器厂商几乎不用，只有代理厂商的住宅代理和部分静态住宅代理才可以接受邀请。我搜索了多家代理厂商，价格便宜的只有 911s5 和 iproyal\n代理厂商 特点 价格 911s5 自有软件，pc端指定软件代理，使用简单，ip质量差，部分可以邀请使用 最低28美元/150ip，每ip可用24小时 iproyal 直接给地址端口和用户，所以在国内必须自己搭建国外节点并且中转才能使用，但是ip质量较好、使用舒适。必须实名，不实名很多网站不能访问（包括facebook），而且实名较为耗时 3美元/GB ，paypal入金最低20美元 “以xui为例的中转配置文件”\r// 直接修改\u0026#34;servers\u0026#34;即可使用 { \u0026#34;api\u0026#34;: { \u0026#34;services\u0026#34;: [ \u0026#34;HandlerService\u0026#34;, \u0026#34;LoggerService\u0026#34;, \u0026#34;StatsService\u0026#34; ], \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 62789, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;Socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;proxy.iproyal.com\u0026#34;, \u0026#34;port\u0026#34;: 12325, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34; }, { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: {} }, { \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;blocked\u0026#34; } ], \u0026#34;policy\u0026#34;: { \u0026#34;system\u0026#34;: { \u0026#34;statsInboundDownlink\u0026#34;: true, \u0026#34;statsInboundUplink\u0026#34;: true } }, \u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;inbound-12325\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;ip2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, \u0026#34;protocol\u0026#34;: [ \u0026#34;bittorrent\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;stats\u0026#34;: {} } “配置文件详解”\r// 配置文件详解 { \u0026#34;api\u0026#34;: { // api: 提供了一些 API 接口供远程调用 \u0026#34;services\u0026#34;: [ // services: [string] 开启的 API 列表 \u0026#34;HandlerService\u0026#34;, // HandlerService:添加、删除一个入站、出站代理在一个入站代理中添加、删除一个用户 \u0026#34;LoggerService\u0026#34;, // 内置Logger \u0026#34;StatsService\u0026#34; // 内置的数据统计服务 ], \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; // tag: string api中的tag是**出站**代理标识 }, \u0026#34;inbounds\u0026#34;: [ // 入站 -\u0026gt; 路由 不用修改 { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 62789, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, // 任意门,可以监听一个本地端口 \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ], \u0026#34;outbounds\u0026#34;: [ // 出站 ##################此处开始添加################## { // 添加出站节点 \u0026#34;protocol\u0026#34;: \u0026#34;Socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 12325, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34; }, #################此处结束添加################### { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, // 向任意网络发送（正常的）TCP 或 UDP 数据 \u0026#34;settings\u0026#34;: {} }, { \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, // 禁止访问 \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;blocked\u0026#34; } ], \u0026#34;policy\u0026#34;: { \u0026#34;system\u0026#34;: { \u0026#34;statsInboundDownlink\u0026#34;: true, \u0026#34;statsInboundUplink\u0026#34;: true } }, \u0026#34;routing\u0026#34;: { // 路由 -\u0026gt; 出站 \u0026#34;rules\u0026#34;: [ ##################此处开始添加################## { // 添加路由，xui的\u0026#34;inboundTag\u0026#34;规则是\u0026#34;inbound-port\u0026#34; \u0026#34;inboundTag\u0026#34;: [ \u0026#34;inbound-12325\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;ip2\u0026#34;, // -\u0026gt; \u0026#34;outbounds\u0026#34;: {\u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34;} \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, #################此处结束添加################### { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, // -\u0026gt; \u0026#34;api\u0026#34;: {\u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34;} \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, // -\u0026gt; 禁止访问 \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, // -\u0026gt; 禁止访问 \u0026#34;protocol\u0026#34;: [ \u0026#34;bittorrent\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;stats\u0026#34;: {} } 激活 下载Oculus App，quest2联网后配对，配对成功就说明Quest2激活成功了。\n安装第三方应用 便携方式 87vr助手安装热门游戏和应用，安卓apk可以通过QQ发送直接安装。 更多破解应用可以看看极客VR（1元注册）、VR魔趣网。\n常规方式 首先需要开启开发者模式。在Oculus开发者网站创建一个开发者组织，再去Oculus APP菜单 -\u0026gt; 设备 -\u0026gt; 开发者模式 -\u0026gt; 打开 。 下载SideQuest并安装。 下载Oculus ADB驱动。右键单击android_winusb.inf选择“安装”。然后用USB线将头显和电脑连接起来，在头显中点击“允许”。 然后就可以安装apk了。 如果apk附带文件夹，就拖入obb文件夹。 进入头显的未知来源就可以使用了。 SKYBOX 《SkyBox VR》是最优秀的vr视频播放器，而且可以使用电脑的本地网络播放电脑上的影片。\nvr影片体积超过10G的很常见，quest2装不了多少，所以放在pc，局域网共享。\n电脑设置开启共享。 无密码的共享 有密码的共享（选择有密码保护的共享），找到用户名和改密码\n共享存放影片的文件夹 右键文件夹 -\u0026gt; 属性 -\u0026gt; 共享 -\u0026gt; 选择用户或新建用户everyone\n删除共享：右键文件夹 -\u0026gt; 授予访问权限 -\u0026gt; 删除访问\n去quest2 SKYBOX 本地网络查看。 常见问题 恢复出厂设置 手机配对后在app菜单 -\u0026gt; 设备 -\u0026gt; 高级设置 -\u0026gt; 恢复出场设置\n登陆Oculus官网 -\u0026gt; 点头像 -\u0026gt; Oculus settings -\u0026gt; Devices DELETE -\u0026gt; DEVICE DATA\n截图 按住右手柄Oculus Home键（椭圆键） + 扳机按键（食指键）\n","date":"2022-05-14T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/quest2/","title":"quest2入门使用"},{"content":"安装 java版本控制（jvms） 我们可能需要多个java版本，主要是为了兼容Gradle版本。\n下载，解压到想要的路径 管理员身份打开cmd，cd到在jvms.exe所在的目录下，执行jvms init jvms.exe rls可列出java版本，如果失败，打开https://site.ip138.com/raw.Githubusercontent.com/查看ip，在C:\\Windows\\System32\\drivers\\etc\\hosts末尾添加一行[ip] raw.githubusercontent.com 安装jvms install [version] jvms.exe ls列出已安装JDK版本 jvms.exe switch [version]切换版本 java -version jvms.exe remove [version]删除某个版本 Android Studio 安装配置Android Studio\n下载地址\nAndroid SDK Tools:\npath:C:\\Users\\[username]\\AppData\\Local\\Android\\Sdk\\tools Android SDK Platform-Tools:\npath:C:\\Users\\[username]\\AppData\\Local\\Android\\Sdk\\platform-tools Android SDK\nTools -\u0026gt; SDK Manager -\u0026gt; 编辑Android SDK Location（默认即可）\nSDK Platforms：推荐Android 7.0及以上 SDK Tools 下载安装 -\u0026gt; Intel x86 Emulator Accelerator (HAXM installer)-Deprecated（模拟器支持） Android SDK Command-line Tools flutter版本控制（fvm） 安装 fvm，命令行运行以下命令： choco install fvm 查看当前有哪些版本可用 fvm releases 安装指定版本 // 有可能缺失，建议手动下载 fvm install [version] 列出所有已安装的 Flutter SDK 版本。 fvm list VS Code配置 在项目中创建一个.vscode文件夹，然后创建一个名为settings.json的文件并添加：\n{ \u0026#34;dart.flutterSdkPath\u0026#34;: \u0026#34;.fvm/flutter_sdk\u0026#34;, // Remove .fvm files from search \u0026#34;search.exclude\u0026#34;: { \u0026#34;**/.fvm\u0026#34;: true }, // Remove from file watching \u0026#34;files.watcherExclude\u0026#34;: { \u0026#34;**/.fvm\u0026#34;: true } } 切换版本 全局切换：fvm global [version] 项目中切换（每次都要）：项目目录下，终端运行fvm use [version]，重启vscode 运行上述命令后，项目中创建了一个名为.fvm 的文件夹，文件夹中有 flutter SDK，如果不希望提交此文件夹，在.gitignore文件中添加.fvm/flutter_sdk\n删除某个版本 fvm remove [version] 直接安装（不推荐） 安装 JDK 下载地址\n安装flutter(windows) flutter安装\nset PUB_HOSTED_URL=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/dart-pub\u0026#34; #配置国内镜像 set FLUTTER_STORAGE_BASE_URL=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/flutter\u0026#34; 配置环境变量 Dart: 无需配置，flutter现在自带dart。\nFlutter:\npath:C:\\flutter\\bin Java:\nJAVA_HOME:C:\\Program Files\\Java\\jdk-1.8\npath:%JAVA_HOME%\\bin\npath:%JAVA_HOME%\\jre\\bin (如果是jdk-17则不需要配置jre)\n删除自动配置的环境变量path：\nC:\\Program Files\\Common Files\\Oracle\\Java\\javapath C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath 不推荐设置系统环境变量classpath，始终建议通过-cp命令传入，JVM默认的classpath为.，即当前目录。\n创建 Flutter 项目 构建 构建项目工具是必学内容，也是项目容易报错的部分，所以放在前面。\nGradle是Android官方工具，比Maven更灵活高效，它具有高度可定制性，以适应不同的项目。\nGradle 注意不同版本的Gradle存在差异，一般情况下Android项目使用Android Gradle Plugin(AGP)的版本。新项目请检查AGP对应gradle版本，flutter SDK也有它自己对应的gradle版本。clone的java项目下载相应gradle到项目目录，在Settings -\u0026gt; Build Tools -\u0026gt; Distribution:Local installation使用。\n更新AGP：Tools -\u0026gt; AGP upgrade assistant\n更改项目/模块gradle版本：File -\u0026gt; Project Structure -\u0026gt; Project/Modules\n参考：文档、示例：https://docs.gradle.org/[version]/samples/index.html#java\n基础 项目 build.gradle：配置项目整体属性，比如指定的代码仓库、依赖 buildscript { repositories { // gradle脚本执行需要的依赖 google() // 引用google上的开源项目 jcenter() // 引用 jcenter上的开源项目 } dependencies { // 依赖的jar包 classpath \u0026#39;com.android.tools.build:gradle:3.0.0\u0026#39; } } allprojects { // 项目本身需要的依赖 repositories { google() jcenter() } } task clean(type: Delete) { // 执行task任务：删除根目录中的build目录 delete rootProject.buildDir } 模块 build.gradle：配置当前Module的编译参数 // 使用插件 apply plugin: \u0026#39;com.android.application\u0026#39; android { compileSdk 34 // 设置编译时用的Android版本 defaultConfig { applicationId \u0026#34;com.example.myapplication\u0026#34; // 项目的包名（子模块不能指定） minSdkVersion 15 // 最低兼容的版本 targetSdk 34 // 目标版本 versionCode 1 // 版本号 versionName \u0026#34;1.0\u0026#34; // 版本名称 // 使用AndroidJUnitRunner进行单元测试 testInstrumentationRunner \u0026#34;android.support.test.runner.AndroidJUnitRunner\u0026#34; } buildTypes { release { // 生产环境 buildConfigField(\u0026#34;boolean\u0026#34;, \u0026#34;LOG_DEBUG\u0026#34;, \u0026#34;false\u0026#34;) // 配置Log日志 buildConfigField(\u0026#34;String\u0026#34;, \u0026#34;URL_PERFIX\u0026#34;, \u0026#34;\u0026#34;https://release.cn/\u0026#34;\u0026#34;) // 配置URL前缀 minifyEnabled false // 是否对代码进行混淆 //指定混淆的规则文件 proguardFiles getDefaultProguardFile(\u0026#39;proguard-android.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; signingConfig signingConfigs.release // 设置签名信息 pseudoLocalesEnabled false // 是否在APK中生成伪语言环境，帮助国际化 zipAlignEnabled true // 是否对APK包进行ZIP对齐优化 applicationIdSuffix \u0026#39;test\u0026#39; // 在applicationId 中添加了一个后缀，一般使用的不多 versionNameSuffix \u0026#39;test\u0026#39; // 在applicationId 中添加了一个后缀，一般使用的不多 } debug { // 测试环境 buildConfigField(\u0026#34;boolean\u0026#34;, \u0026#34;LOG_DEBUG\u0026#34;, \u0026#34;true\u0026#34;) // 配置Log日志 buildConfigField(\u0026#34;String\u0026#34;, \u0026#34;URL_PERFIX\u0026#34;, \u0026#34;\u0026#34;https://test.com/\u0026#34;\u0026#34;) // 配置URL前缀 minifyEnabled false //是否对代码进行混淆 //指定混淆的规则文件 proguardFiles getDefaultProguardFile(\u0026#39;proguard-android.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; signingConfig signingConfigs.debug // 设置签名信息 debuggable false // 是否支持断点调试 jniDebuggable false // 是否可以调试NDK代码 renderscriptDebuggable false // 是否开启渲染脚本 zipAlignEnabled true // 是否对APK包执行ZIP对齐优化 pseudoLocalesEnabled false // 是否在APK中生成伪语言环境，帮助国际化 applicationIdSuffix \u0026#39;test\u0026#39; // 在applicationId 中添加了一个后缀，一般使用的不多 versionNameSuffix \u0026#39;test\u0026#39; // 在applicationId 中添加了一个后缀，一般使用的不多 } } } dependencies { //项目的依赖关系 👉// 本地jar包依赖：新建 Project\\app\\libs 文件夹，粘贴 jar implementation fileTree(include: [\u0026#39;*.jar\u0026#39;], dir: \u0026#39;libs\u0026#39;) testImplementation \u0026#39;junit:junit:4.12\u0026#39; // 声明测试用例库 implementation \u0026#39;com.android.support:appcompat-v7:26.1.0\u0026#39; // 远程依赖 implementation project(\u0026#39;:library\u0026#39;) // 项目本地的Library模块 } 其他配置\randroid { signingConfigs { // 自动化打包配置 release { // 线上环境 keyAlias \u0026#39;test\u0026#39; keyPassword \u0026#39;123456\u0026#39; storeFile file(\u0026#39;test.keystore\u0026#39;) storePassword \u0026#39;123456\u0026#39; } debug { // 开发环境 keyAlias \u0026#39;test\u0026#39; keyPassword \u0026#39;123456\u0026#39; storeFile file(\u0026#39;test.keystore\u0026#39;) storePassword \u0026#39;123456\u0026#39; } } sourceSets { // 目录指向配置 main { jniLibs.srcDirs = [\u0026#39;libs\u0026#39;] // 指定lib库目录 } } packagingOptions{ // 当有重复文件时 ,使用第一个匹配的文件打包进apk pickFirsts = [\u0026#39;META-INF/LICENSE\u0026#39;] // 当出现重复文件时 合并重复的文件打包进apk merge \u0026#39;META-INF/LICENSE\u0026#39; // 同时使用butterknife、dagger2框架处理 （常用） exclude \u0026#39;META-INF/services/javax.annotation.processing.Processor\u0026#39; } productFlavors { wandoujia { // 豌豆荚渠道包配置 manifestPlaceholders = [UMENG_CHANNEL_VALUE: \u0026#34;wandoujia\u0026#34;] } xiaomi { manifestPlaceholders = [UMENG_CHANNEL_VALUE: \u0026#34;xiaomi\u0026#34;] applicationId \u0026#34;com.wiky.gradle.xiaomi\u0026#34; // 配置包名 } _360 { manifestPlaceholders = [UMENG_CHANNEL_VALUE: \u0026#34;_360\u0026#34;] } //... } lintOptions { // 关闭检查lint（有错误会停止build） abortOnError false // 即使报错也不会停止打包 checkReleaseBuilds false // 打包release版本的时候进行检测 } buildFeatures { // true表示生成build/app/generated/source/buildConfig/release/com/example/app/BuildConfig.java，不需要手动维护版本号、渠道等常量 buildConfig = false } } gradle-wrapper-properties：配置 Gradle Wrapper gradle-properties：配置 Gradle编译参数，详见文档 setting.gradle：配置 Gradle 的多项目管理 local.properties：存放 Android 项目的私有属性配置，如 SDK 路径 multiDexKeep.pro、proguard-rules.pro：可选的混淆文件，用于配置放置在主 Dex 的类、声明避免混淆的类 java插件 参考\n简介\nAndroid App：APK文件，新建时选择Empty Views Activity Android Library：ARR文件，在目录结构上与Android App相同，包含构建APP所需的一切。当你需要构建不同的APK时，具有通用的模块（如账户管理），可以将library添加为每个APP模块的依赖项 Java or Kotlin Library（插件）：JAR文件，打包可重用的代码，不含资源文件，如res中的图片 使用\n生成jar\\arr Android Studio 打开右侧的 Gradle，选择需要打包的module —\u0026gt; Tasks —\u0026gt; build, 双击 assemble\n生成jar\\arr到Project\\build\\library\\libs或outputs\\aar，移到Project\\app\\libs\n在模块gradle添加\nimplementation fileTree(dir: \u0026#39;libs\u0026#39;, include: [\u0026#39;*.aar\u0026#39;]) implementation fileTree(dir: \u0026#39;libs\u0026#39;, include: [\u0026#39;*.jar\u0026#39;]) 自定义插件的三种方式\nbuild script：在build.gradle脚本中直接编写，只能在本文件内使用 buildSrc项目：新建一个名为buildSrc的Module，Gradle会自动编译和测试，只能在本项目中使用 独立项目：在独立的项目中编写插件，发布到本地或者远程jcenter、maven仓库供其他项目使用 独立项目打包jar到maven：\n在项目中新建File -\u0026gt; New -\u0026gt; New Module -\u0026gt; Java or Kotlin Library\n修改build.gradle：\n// Gradle插件 apply plugin: \u0026#39;groovy\u0026#39; apply plugin: \u0026#39;maven\u0026#39; apply plugin: \u0026#39;java-gradle-plugin\u0026#39; // 依赖 dependencies { implementation gradleApi() //Groovy DSL implementation localGroovy() //Gradle DSL } // 仓库 repositories { mavenCentral() } // 配置插件id和映射类（生成resources文件夹储存) gradlePlugin { plugins { greeting { // 插件id id = \u0026#39;CustomPlugin\u0026#39; // 插件实现类 implementationClass = \u0026#39;com.group.myplugin.CustomPlugin\u0026#39; } } } def group=\u0026#39;com.group.myplugin\u0026#39; def artifactId=\u0026#39;myplugin\u0026#39; def version=\u0026#39;1.0.0\u0026#39; // 指定本地maven的路径，在插件目录下 def uploadRepo = \u0026#39;../myplugin\u0026#39; // 打包到本地maven仓库 uploadArchives { repositories { mavenDeployer { pom.groupId = group pom.artifactId = artifactId pom.version = version repository(url: uri(uploadRepo)) } } } 新建CustomPlugin.groovy文件写插件：实现Plugin接口 package com.group.myplugin import org.gradle.api.Plugin import org.gradle.api.Project class CustomPlugin implements Plugin\u0026lt;Project\u0026gt; { @Override void apply(Project project) { println(\u0026#34;Hello gradle plugin\u0026#34;) } } 将插件发布到本地 Maven 仓库的2种方式： 执行./gradlew uploadArchives命令\n可视化界面的 uploadArchives Task 点击发布\n故障排除 配置 配置build.gradle(project:android) allprojects { repositories { google() jcenter() maven { url \u0026#34;https://storage.googleapis.com/download.flutter.io\u0026#34; } } } 更新 flutter flutter upgrade flutter doctor 报错 查看错误信息 控制台Terminal：./gradlew assembleDebug --info\n常见错误\n更新Android Studio 重新建项目 \\android\\app\\build.gradle compileSdkVersion 33 minSdkVersion 21 其他错误\nAttribute application@label value=(Dormitory) from AndroidManifest.xml 解决：进入\\android\\app\\src\\main\\AndroidManifest.xml\n\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; // 添加此行 package=\u0026#34;com.example.model_dev\u0026#34;\u0026gt; \u0026lt;application tools:replace=\u0026#34;android:label\u0026#34; // 添加此行 android:label=\u0026#34;model_dev\u0026#34; android:name=\u0026#34;${applicationName}\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34;\u0026gt; \u0026lt;activity Gradle threw an error while downloading artifacts from the network 解决：Gradle损坏，进入 C:\\Users\\username 删除 .gradle 文件夹\ndart 变量 # 创建一个变量并将其初始化 var name = \u0026#39;Bob\u0026#39;; # 指定类型 String name = \u0026#39;Bob\u0026#39;; # 如果对象(name)不局限于单一的类型(例如String),可以将其指定为 Object（或 dynamic）类型 Object name = \u0026#39;Bob\u0026#39;; ? 可空类型 int? a=123; // int? 表示a是一个可空类型 int? a; // 未初始化变量的初始值为null ! 类型断言 a! // a不为空 late 延迟初始化:字段被第一次访问时延迟运行，而不是在实例化后立即运行。 class Weather { late int _temperature = _readThermometer(); } final 已经实例化的final对象不能指向另一个不同的对象，但其字段可以更改。 final name = \u0026#39;Bob\u0026#39;; final String nickname = \u0026#39;Bobby\u0026#39;; const 编译时常量：一经定义就会在编译期间对其进行初始化，const对象及其字段无法更改。 类型 常规类型 注意首字母大小写\nint 整数值 double 浮点数字 String 字符串 bool 布尔类型 List 列表类型 Map 字典型 List 属性：\nlength　长度 reversed　翻转 isEmpty　是否为空 isNotEmpty　是否不为空 方法：\nadd()　增加 addAll()　拼接数组 indexOf()　查找 传入具体值 remove()　删除 传入具体值 removeAt()　删除 传入索引值 fillRange()　修改 insert(index,value);　指定位置插入 insertAll(index,list)　指定位置插入List toList()　其他类型转换成List join()　List转换成字符串 split()　字符串转化成List forEach() map() 示例：List\u0026lt;Widget\u0026gt;.from(MyMap.keys.map((item) =\u0026gt; SomeWidget(item)).toList()); map()可以传入List或Map的每项数据，toList()转换成List，List.from接收Iterable（[Map.keys]、[List] 和 [Set] 都是 Iterable），返回widget List。 where() any() every() Map 属性：\nkeys　获取所有的key值 values　获取所有的value值 isEmpty　是否为空 isNotEmpty　是否不为空 方法：\nremove(key)　删除指定key的数据 addAll({\u0026hellip;})　合并映射 给映射内增加属性 containsValue()　查看映射内的值 返回true/false forEach() map() where() any() every() 其它类型 enum　枚举类型,用于表示固定数量的常量值。在switch语句中运行良好。\nObject　对象类型，允许任何类型。\ndynamic　动态类型，不仅接受所有对象，而且还允许所有操作\nvoid main() { dynamic foo=\u0026#34;bar\u0026#34;; print(foo); foo=123; print(foo); } Set　无序集合，主要的功能就是去除数组重复内容 void main(){ List myList=[\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;,\u0026#39;西瓜\u0026#39;,\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;,\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;]; var s=new Set(); s.addAll(myList); print(s); print(s.toList()); } Future　用于异步支持。 Stream　用于异步支持。 Iterable　用在for-in 循环和同步生成器函数中。 Never　表示表达式永远无法成功完成计算。最常用于总是抛出异常的函数。 void　表示从未使用过某个值。通常用作返回类型。 (value1, value2)　记录（需dart3） Null　空值 不常用的类型 runes 暴露了字符串的 Unicode 代码点（Unicode 为每个字母、数字和符号定义了一个唯一的数值）。例如，用于表情符号，(😆) 是\\u{1f606}。经常被 \u0026ldquo;characters\u0026rdquo; API 取代。\nSymbol 表示标识符，例如#。\nvoid main() { assert(Symbol(\u0026#39;bar\u0026#39;)==#bar); } // true 类型转换 myint = int.parse(myString); // String -\u0026gt; int myString = myint.toString(); // int -\u0026gt; String mydouble = double.parse(myString); // String -\u0026gt; double myString = 3.14159.toStringAsFixed(2); // double -\u0026gt; String (myString = \u0026#39;3.14\u0026#39;) mynum.member = mynum.values.byName(myString); // String -\u0026gt; enum myString = mynum.member.name; // enum -\u0026gt; String 函数 bool isNoble(int atomicNumber) { // bool:返回类型 return _nobleGases[atomicNumber] != null; } 箭头函数 =\u0026gt;\n=\u0026gt; expr 是 { return expr; }的简写\n参数 命名参数（可传可不传） String printUserInfo(String username, {int age = 0, String sex = \u0026#39;男\u0026#39;}) {//行参，用大括号 if (age != 0) { return \u0026#34;姓名:$username---性别:$sex--年龄:$age\u0026#34;; } return \u0026#34;姓名:$username---性别:$sex--年龄保密\u0026#34;; } print(printUserInfo(\u0026#39;张三\u0026#39;)); //实参 print(printUserInfo(\u0026#39;张三\u0026#39;, age: 20, sex: \u0026#39;未知\u0026#39;)); //实参,命名参数的实参必须传入参数名age: sex: 位置参数（可传可不传） String printUserInfo(String username,[String sex=\u0026#39;男\u0026#39;,int age=0]){ //行参，用中括号 if(age!=0){ return \u0026#34;姓名:$username---性别:$sex--年龄:$age\u0026#34;; } return \u0026#34;姓名:$username---性别:$sex--年龄保密\u0026#34;; } print(printUserInfo(\u0026#39;张三\u0026#39;)); //实参 print(printUserInfo(\u0026#39;小李\u0026#39;,\u0026#39;女\u0026#39;,30)); //实参 运算符 算术运算符\n+(加)　–(减)　-(负)　*(乘)　/(除)　~/(取整)　%（取余）\n关系运算符\n==　！=　\u0026gt;　\u0026lt;　\u0026gt;=　\u0026lt;=\n逻辑运算符\n!(取反)　\u0026amp;\u0026amp;(与)　||(或)\n赋值运算符\n基础赋值运算符　=　??=(为 null 的变量赋值)\n复合赋值运算符　+=　-=　*=　/=　%=　~/=\n其他运算符 ()　使用一个方法\n[]　访问 List\n?[]　访问 List,左侧/?表示可以为null\n.　访问成员\n?.　访问成员,左侧/?表示可以为null\n.. 级联，可以在同一个对象上访问实例成员和调用多个实例方法\nif-else的表达式：\ncondition ? expr1 : expr2 如果条件为真，则计算expr1（并返回其值）；否则，计算并返回expr2的值。\nexpr1 ?? expr2 如果expr1不为 null，则返回其值；否则，计算并返回expr2的值。\n类 方法 实例变量和方法 实例变量:\nclass Point { double? x; // Declare instance variable x, initially null. double? y; // Declare y, initially null. double z = 0; // Declare z, initially 0. } 实例方法可以访问实例变量和 this\nimport \u0026#39;dart:math\u0026#39;; class Point { final double x; final double y; Point(this.x, this.y); double distanceTo(Point other) { var dx = x - other.x; var dy = y - other.y; return sqrt(dx * dx + dy * dy); } } 静态变量和方法 使用关键字 static 可以声明类变量或类方法。静态成员可以通过类名称直接访问（不需要实例化），提高性能。静态方法不能访问非静态成员，非静态方法可以访问静态成员，不能使用this关键字。\nget 和 set 特殊方法:实例对象的每一个属性都有一个隐式的 Getter 方法，非 final 属性还会有一个 Setter 方法。\n通过get和set修饰的方法不带小括号，可以使访问方法像访问属性一样，简便我们的使用、访问 set：传入属性，get：访问属性。 class Rectangle { double left, top, width, height; Rectangle(this.left, this.top, this.width, this.height); double get right =\u0026gt; left + width; set right(double value) =\u0026gt; left = value - width; } void main() { var rect = Rectangle(3, 4, 20, 15); // 通过getter访问 right assert(rect.right == 23); // 通过setter修改 right 属性 rect.right = 12; assert(rect.left == -8); } 抽象类、抽象方法 抽象类常用于定义接口，抽象类常常会包含抽象方法\nabstract class Doer { // Define instance variables and methods... void doSomething(); // Define an abstract method. } class EffectiveDoer extends Doer { void doSomething() { // Provide an implementation, so the method is not abstract here... } } call() 在别人项目经常看到此方法，看其解释感觉可以省略不写。\n所有 Dart函数（具有函数类型而不是类/接口类型的对象）都有一个call方法。\n该call方法与函数本身具有相同的函数类型，并且在调用它时它的行为完全相同。您甚至可以说调用函数就是隐式调用其call方法。如果您编写函数调用e1(e2, e3)，那么编译器会检查是否e1有call方法，如果有，则将其转换为方法调用e1.call(e2, e3)。\n构造函数 特点： 实例化类时会被自动触发\n一般用于初始化操作\n没有返回值\n普通构造函数 构造函数方法名和类名相同\nclass Point { num x, y; Point(num x, num y) { // There\u0026#39;s a better way to do this, stay tuned. this.x = x; this.y = y; } } 简化形式：\nclass Point { num x, y; // Syntactic sugar for setting x and y // before the constructor body runs. Point(this.x, this.y); } 命名构造函数 命名构造函数(类名.函数名)可以实现多个构造器。\nclass Point { num x, y; Point(this.x, this.y); // 命名构造函数 Point.origin() { x = 0; y = 0; } } 请记住，命名构造函数不可继承，如果子类想要有 和父类一样的命名构造函数，那就写个同名的（通常也会在子类的命名构造函数里，调用父类的同名命名构造函数）\n调用父类构造函数 如果你的类，继承于父类，那么子类的构造函数，势必要调用父类的构造函数，这时候就要分两种情况：\nDart语言帮你调用父类的无参数构造函数 代码中显式调用父类的构造函数 默认调用调用父类的无参数构造函数 如果你没有显式调用父类的构造函数，并且父类有一个无参数构造函数，那么Dart就会帮你在子类的构造函数方法体的最前面，调用父类的无参数构造函数。当然，后面我们会说道，构造函数分成好几部分来初始化成员变量，调用的顺序如下：\n初始化列表 父类的无参数构造函数 子类的无参数构造函数 当然，如果父类没有无参数构造函数，或者Dart这种隐式调用无法满足你的要求，那就需要显式调用父类的构造函数了\n显式调用父类构造函数 显式调用父类构造函数，应该在初始化列表中完成\nclass Person { String firstName; Person.fromJson(Map data) { print(\u0026#39;in Person\u0026#39;); } } class Employee extends Person { // Person does not have a default constructor; // you must call super.fromJson(data). Employee.fromJson(Map data) : super.fromJson(data) { print(\u0026#39;in Employee\u0026#39;); } } main() { var emp = new Employee.fromJson({}); // Prints: // in Person // in Employee } 初始化列表 在构造函数后加上: x = , y = 可以在构造函数中设置属性的默认值\n在构造函数体执行之前执行\n可以调用超类的构造函数\n// Initializer list sets instance variables before // the constructor body runs. Point.fromJson(Map\u0026lt;String, num\u0026gt; json) : x = json[\u0026#39;x\u0026#39;], y = json[\u0026#39;y\u0026#39;] { print(\u0026#39;In Point.fromJson(): ($x, $y)\u0026#39;); } 尤其是初始化那些final修饰的成员变量时，初始化列表很有用，因为在方法体中，不能给final修饰的成员变量赋值，因为在执行方法体的时候，final修饰的成员变量已经不能变了。这个地方很多人犯错。\nimport \u0026#39;dart:math\u0026#39;; class Point { final num x; final num y; final num distanceFromOrigin; Point(x, y) : x = x, y = y, distanceFromOrigin = sqrt(x * x + y * y); } main() { var p = new Point(2, 3); print(p.distanceFromOrigin); } 重定向构造函数 定义构造函数的时候，除了一个普通构造函数，还可以有若干命名构造函数，这些构造函数之间，有时候会有一些相同的逻辑，如果分别书写在各个构造函数中，会有些多余，所以构造函数可以传递。\nclass Point { num x, y; // The main constructor for this class. Point(this.x, this.y); // Delegates to the main constructor. Point.alongXAxis(num x) : this(x, 0); } 传递构造函数，没有方法体，会在初始化列表中，调用另一个构造函数。\n常量构造函数 class ImmutablePoint { static final ImmutablePoint origin = const ImmutablePoint(0, 0); final num x, y; const ImmutablePoint(this.x, this.y); } 如果你的类，创建的对象永远不会改变，你可以在编译期就创建这个常量实例，并且定义一个常量构造函数，并且确保所有的成员变量都是final的。\n工厂构造函数/单例模式 在构造函数前加上factory\n只实例化一次，节省相同实例化带来的消耗\n第一次调用命名构造函数进入工厂函数中实例化，后续调用就用缓存中现成的实例\n工厂构造函数，没有权利访问this\nclass Logger { final String name; bool mute = false; // _cache is library-private, thanks to // the _ in front of its name. static final Map\u0026lt;String, Logger\u0026gt; _cache = \u0026lt;String, Logger\u0026gt;{}; factory Logger(String name) { if (_cache.containsKey(name)) { return _cache[name]; } else { final logger = Logger._internal(name); # 调用构造函数 _cache[name] = logger; return logger; } } Logger._internal(this.name); # 定义命名构造函数 void log(String msg) { if (!mute) print(msg); } } main() { var logger = Logger(\u0026#39;UI\u0026#39;); logger.log(\u0026#39;Button clicked\u0026#39;); } 上例的意思是，类中又一个静态缓存_cache保存着一些Logger类实例，创建实例时，给工厂构造函数传递的name，如果在缓存中已经存在，就用缓存中现成的实例，如果没有，就新建一个实例，并且也放到缓存中。\n如此，我们可以创建名字为UI / SYS / API 等的实例，然后在debug的时候，如果设置名字为UI的Logger实例的mute为true，就不会打印UI相关的log，而不影响其它两个名字的log。\n回调函数 回调函数本质上是把函数作为参数传递给小部件的函数，当按钮按下时调用此函数。\n官方实现：\n/// Signature of callbacks that have no arguments and return no data. typedef VoidCallback = void Function(); /// Signature for callbacks that report that an underlying value has changed. /// See also: /// * [ValueSetter], for callbacks that report that a value has been set. typedef ValueChanged\u0026lt;T\u0026gt; = void Function(T value); 示例：\nimport \u0026#39;package:flutter/material.dart\u0026#39;; void main() { runApp(const MyApp()); } class MyApp extends StatefulWidget { const MyApp({Key? key}) : super(key: key); @override State\u0026lt;MyApp\u0026gt; createState() =\u0026gt; _MyAppState(); } class _MyAppState extends State\u0026lt;MyApp\u0026gt; { String topic = \u0026#34;Packages\u0026#34;; callback(varTopic) { // setState:通知内部状态已更改从而重建UI setState(() { topic = varTopic; }); } @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: AppBar( title: const Text(\u0026#34;Learning Flutter\u0026#34;), ), body: Column( children: [ Container( width: double.maxFinite, height: 70, margin: const EdgeInsets.only( top: 50, left: 40, right: 40, bottom: 20), decoration: BoxDecoration( color: Colors.lightBlue, borderRadius: BorderRadius.circular(20)), child: Center( child: Text( \u0026#34;We are learning Flutter $topic\u0026#34;, style: const TextStyle(fontSize: 20, color: Colors.white), ), ), ), MyButtons(topic: \u0026#34;Cubit\u0026#34;, callbackFunction: callback), MyButtons(topic: \u0026#34;BLoc\u0026#34;, callbackFunction: callback), MyButtons(topic: \u0026#34;GetX\u0026#34;, callbackFunction: callback) ], ), ), ); } } class MyButtons extends StatelessWidget { final String topic; final Function callbackFunction; const MyButtons( {Key? key, required this.topic, required this.callbackFunction}) : super(key: key); @override Widget build(BuildContext context) { return GestureDetector( onTap: () { callbackFunction(topic); }, child: Container( width: double.maxFinite, height: 70, margin: const EdgeInsets.only(top: 20, left: 40, right: 40, bottom: 20), decoration: BoxDecoration( color: Colors.lightBlue, borderRadius: BorderRadius.circular(20)), child: Center( child: Text( topic, style: const TextStyle(fontSize: 20, color: Colors.white), ), ), ), ); } } Function class Function是所有函数类型的超类。\nFunction有一些没有声明的特殊功能：\nFunction 静态类型的值仍然可以像函数一样被调用（这样的调用是动态调用,编译器无法在编译时检查类型的正确性,在运行时将执行检查以确保参数类型一致）。 Function f = (int x) =\u0026gt; \u0026#34;$x\u0026#34;; print(f(1)); // Prints \u0026#34;1\u0026#34;. f(\u0026#34;not\u0026#34;, \u0026#34;one\u0026#34;, \u0026#34;int\u0026#34;); // Throws! No static warning. widgets之间的通信 https://medium.com/flutter-community/flutter-communication-between-widgets-f5590230df1e\n扩展 扩展类 extends Extends是典型的OOP类继承。如果 a类 扩展了 b类，则 a类 可以使用或覆盖 b类 中实现的所有属性、变量、函数 。在 Dart 中，一个类只能扩展一个类。 implements 创建另一个类或接口的实现。当 a类 实现 b类 时，必须实现 b类 中定义的所有功能(所有属性、变量、函数)。一个类可以实现多个接口。\nwith mixin使用with关键字，类似于继承，可以扩展多个类。mixins的类只能继承自Object，不能再继承其他类，且不能有构造函数。\n# extends只能扩展一个类，而mixin没有限制，可以一起使用 class Maestro extends Person with Musical, Aggressive, Demented { Maestro(String maestroName) { name = maestroName; canConduct = true; } } super super关键字用于调用父类的对象、方法、构造函数和子类中的属性。\n// 访问父类变量 super.variable_name; // 访问父类方法 super.method_name(); // 转发给超类的构造函数 const MyApp({Key? key}) : super(key: key); 扩展方法 // 扩展 num，就可以使用 num.attribute 和 num.method extension FancyNum on num { num plus(num other) =\u0026gt; this + other; num times(num other) =\u0026gt; this * other; } print(5.plus(3)); // Equal to \u0026#34;5 + 3\u0026#34;. print(5.times(8)); // Equal to \u0026#34;5 * 8\u0026#34;. print(2.plus(1).times(3)); // Equal to \u0026#34;(2 + 1) * 3\u0026#34;. 泛型 泛型常用于需要要求类型安全的情况，可以减少代码重复。 如果 T 是一个class，则表示传入该类型的参数。\n@override 注解来表示你重写了一个成员 异步 Isolate Isolate 是运行所有 Dart 代码的地方，在许多其他语言里（例如 C++），你可以让多个线程共享相同的内存，但是在 Dart 中，每个线程都有自己的 Isolate 和它自己的内存。\n如果你要运行的计算量太过庞大，在 main Isolate 中运行可能会导致丢帧，如果处理可能需要几百毫秒，则考虑创建单独的Isolate，例如：\n解码 JSON，HttpRequest 的结果 =\u0026gt; compute 加密可能非常耗时 处理图像（例如裁剪） 从 Web 加载图像 事件循环\nDart使用永不阻塞的单线程来处理所有事件。因此，它运行一个事件循环，它从事件队列中取得最先发生的事件，处理它，返回下一个事件进行处理，依此类推，直到事件队列清空为止。\nFuture 定义\nFuture\u0026lt;void\u0026gt; myVoidFuture() {} // 不返回任何内容，但可以在最终完成时通知调用者。 Future\u0026lt;bool\u0026gt; myTypedFuture() {} // 如果需要返回一个值，那么你传递给它一个类型。 Future 有三种状态：\nUncompleted: 你刚刚得到一个 Future，还未打开 首先，事件发生，事件循环获取事件，并调用你写的处理程序，得到一个返回的 Future，此时Future是关着的，此时 Future 未能完成，事件循环继续执行其他事件。 Completed with a value: 打开了，带有一个值 等到数据抵达时，Future 得到数据并打开它，如果Future 完成并带有一个值，此时会触发你的 then 回调。then 是你可以用来在每个 Future 上注册回调的实例方法，你可以用它创建一个函数，传入一个匹配 Future 类型的参数。 Completed with an error: 打开了，抛出一个异常 如果Future 在完成时没有带一个值，你可以使用 catchError注册另一个回调，catchError 的工作方式和 then 一样，唯一不同的是它捕获异常而不是值。你甚至可以给它一个test方法，你可以通过这种方式使用多个 catchError 方法，每种方法都会检查错误返回值的类型。 void main() { Future\u0026lt;int\u0026gt;.delayed ( Duration (seconds: 3), () { return 100; }, ).then((value) { print(value); }).catchError( (err) { print(\u0026#39;Caught $err\u0026#39;); }, test: (err) =\u0026gt; err.runtimeType == String, ).whenComplete (() { print(\u0026#39;All finished!\u0026#39;); }); print(\u0026#39;waiting...\u0026#39;); } Future方法\nFuture.value 如果你已经知道 Future 返回的值，你可以使用 Future.value 为构造函数命名，构建缓存服务时可以用这个\nFuture.error 它需要一个异常对象和一个可选的堆栈跟踪\nFuture.delayed 在运行函数和 Future 完成之前，指定等待时长，可以创建测试用的模拟网络服务\nStreams 每个 future 单一地传递错误，或者数据，Streams随着时间的推移，可以传送零个、多个值，或者是错误。\nasync await async 和 await 实际上只是 future 和 streams 的替代语法，可以帮助你编写更清晰、更易读的代码。在连续的Future中，每一处Future都需要定义、then、return，而await只需如下写：\nimport \u0026#39;dart:io\u0026#39;; void main() { createData(); } Future\u0026lt;ProcessedData\u0026gt; createData() async { try { final id = await _loadFromDisk(); final data = await _fetchNetworkData(id); return ProcessedData(data); } on HttpException catch (err) { print(\u0026#39;Network error: $err\u0026#39;); return ProcessedData.empty(); } finally { print(\u0026#39;All done!\u0026#39;); } } Future\u0026lt;int\u0026gt; _loadFromDisk() async { print(\u0026#39;loadFromDisk\u0026#39;); return 0; } Future\u0026lt;String\u0026gt; _fetchNetworkData(int id) async { print(\u0026#39;NetworkData\u0026#39;); return \u0026#39;NetworkData\u0026#39;; } class ProcessedData { ProcessedData(this.data); final String data; static Future\u0026lt;ProcessedData\u0026gt; empty() async { var empty = ProcessedData(\u0026#39;empty\u0026#39;); print(empty); return empty; } } 上面官方示例介绍了连续的 await，这是更清晰的使用示例：\nvoid main() async { print(getMeSomeFood()); print(await getMeSomethingBetter()); maybeSomethingSweet().then((String value) { print(value); }); print(\u0026#39;done\u0026#39;); } Future\u0026lt;String\u0026gt; getMeSomeFood() async { return \u0026#34;an apple\u0026#34;; } Future\u0026lt;String\u0026gt; getMeSomethingBetter() async { return \u0026#34;a burger?\u0026#34;; } Future\u0026lt;String\u0026gt; maybeSomethingSweet() async { return \u0026#34;a chocolate cake!!\u0026#34;; } // output: // Instance of ‘_Future\u0026lt;String\u0026gt;’ 不等待，返回一个future // a burger? 等待future完成 // done // a chocolate cake!! 不等待，先继续执行print(\u0026#39;done\u0026#39;)，future完成后再调用then Generator Single value Zero or more values Sync: int Iterable Async: Future Stream 当您需要延迟生成一系列值时，请考虑使用生成器函数。Dart 内置支持两种生成器函数：\n同步生成器：返回一个Iterable对象。 异步生成器：返回一个Stream对象。 实现一个同步生成器函数，将函数体标记为sync*，使用yield语句传递值：\nIterable\u0026lt;int\u0026gt; naturalsTo(int n) sync* { int k = 0; while (k \u0026lt; n) yield k++; } 实现异步生成器函数，将函数体标记为async*，使用yield语句传递值：\nStream\u0026lt;int\u0026gt; asynchronousNaturalsTo(int n) async* { int k = 0; while (k \u0026lt; n) yield k++; } 如果您的生成器是递归的，您可以使用以下方法提高其性能yield*：\nIterable\u0026lt;int\u0026gt; naturalsDownFrom(int n) sync* { if (n \u0026gt; 0) { yield n; yield* naturalsDownFrom(n - 1); } } flutter Widget生命周期 StatelessWidget生命周期源码图 Flutter 中万物皆为Widget，widget类继承自DiagnosticableTree。\nDiagnosticableTree即“诊断树”，主要作用是提供调试信息。\nFlutter 中的 UI 或一堆小部件组成，通常称为小部件树，根据 Widget 树生成一个 Element 树，Widget 和 Element 是一一对应的，根据 Element 树生成 Render 树（渲染树），真正的布局和渲染逻辑在 Render 树中。\nWidget.createElement() :创建一个Element实例，记为element。\nBuildContext是widget对应的Element，用于跟踪树中的每个小部件并定位它们及其在树中的位置。每个小部件的BuildContext都传递给它们的build方法。build方法返回小部件呈现的小部件树。\ncontext参数是BuildContext类的一个实例，表示当前 widget 在 widget 树中的上下文，每一个 widget 都会对应一个 context 对象。在很多时候我们都需要使用context，比如获取主题：Theme.of(context).colorScheme.primary。\nKey: [Key]是[Widget]、[Element]和[SemanticsNode]的标识符。Key可以保持组件之前的状态，比如在用户滑动时或者修改集合时，决定的条件在canUpdate()方法中。使用 GlobalKey时，Flutter 不仅会在树中查找与特定级别匹配的键，还会在整个应用程序中查找,GlobalKey就像全局变量。\ncanUpdate(...): newWidget与oldWidget的runtimeType和key同时相等时就会用new widget去更新Element对象的配置。如果 Type 相同但 Key 不同，则Element将被deactivated（释放，但它可能仍然存在）。如果 Type 不同，则Element将被disposed（永久删除）。\nelement.mount() :调用createRenderObject创建RenderObject，并使用attachRenderObject将RenderObject关联到Element上。\n使用 StatelessWidget 要求我们重写build方法,它将state作为输入并提供相应的 UI 显示在用户屏幕上：UI = build(state),当我们初始化一个StatelessWidget对象时会调用 build 方法。\nclass CounterWidget extends StatelessWidget { final bool isLoading; final int counter; const CounterWidget({ required this.isLoading, required this.counter, }); @override Widget build(BuildContext context) { return isLoading ? CircularProgressIndicator() : Text(\u0026#39;$counter\u0026#39;); } } StatefulWidget 要求我们重写createState功能:\nclass MyHomePage extends StatefulWidget { final bool isLoading; final int counter; const MyHomePage({ required this.isLoading, required this.counter, }); @override State\u0026lt;MyHomePage\u0026gt; createState() { return MyHomePageState(); } } createState()会为每一个StatefulElement创建一个State对象。示例中创建了MyHomePageState对象，当MyHomePageState初始化时，它会调用build函数。\nclass MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { @override Widget build(BuildContext context) { return Scaffold( body: Center( child: CounterWidget( isLoading: widget.isLoading, counter: widget.counter, ), ), ); } } widget.isLoading、widget.counter属性用于表示当前配置信息，并且在父级更新小部件时会被自动更新。setState是State的方法。当我们调用setState方法时，build方法将立即再次被调用。\n当你的组件是静态的，不需要更新自身状态,使用StatelessWidget。当你的组件需要根据事件或交互来动态更新自身状态,使用StatefulWidget。\nGetx 状态管理 介绍 分类 状态管理器 消耗RAM 结论 无状态页面 GetView 最少 相当于StatelessWidget,性能最好，最常用 简单的状态管理（一个页面的状态管理） GetBuilder 较少 相当于StatefulWidget,性能较好 反应式状态管理（全局的状态管理） Obx 稍多 反应式的基础层，较Getx简洁 GetX 较多 可以灵活使用的反应式状态管理 混合态管理 MixinBuilder 最多 在GetBuilder中插入一个Obx，既可以响应式更新、也可以手动更新 Controller Getx状态管理的代码结构都可以分为GetXController（控制器层）和view（界面层），GetXController 可以进一步分为state（状态层/变量层），logic（逻辑层）。\n└── sinup ├── controller.dart ──┤─ ─ logic.dart │ │─ ─ state.dart ├── view.dart 生命周期 在 StatefulWidget 中，使用initState或dispose()，而在 Controller 中我们可以使用相对应的操作：\nonStart（开始）[不可覆盖]：组件在内存分配的时间点就会被调用，完成后会调用onInit方法 onInit（初始化）：组件在内存分配后会被马上调用，适用于初始化 Controller（例如一些成员属性的初始化），详见Workers小节 onReady（加载完成）：在 onInit 一帧后被调用，适合做一些导航进入的事件（例如对话框提示、SnackBar）或异步网络请求 onClose（控制器被释放）：在 onDelete 方法前调用、用于销毁 controller 使用的资源（例如关闭事件监听，关闭流对象、动画）或者销毁可能造成内存泄露的对象（例如 TextEditingController，AniamtionController）。也适用于将数据进行离线持久化。 onDelete（删除）[不可覆盖]：在 controller销毁前调用，将控制器从内存中删除 反应状态管理 反应变量 使用反应状态管理需要声明反应变量，你有3种方法可以把一个变量变成是 \u0026ldquo;可观察的\u0026rdquo;。\n1 - 第一种是使用 Rx{Type}。\n// 建议使用初始值，但不是强制性的 final name = RxString(\u0026#39;\u0026#39;); final isLogged = RxBool(false); final count = RxInt(0); final balance = RxDouble(0.0); final items = RxList\u0026lt;String\u0026gt;([]); final myMap = RxMap\u0026lt;String, int\u0026gt;({}); 2 - 第二种是使用 Rx，规定泛型 Rx\u0026lt;Type\u0026gt;。\nfinal name = Rx\u0026lt;String\u0026gt;(\u0026#39;\u0026#39;); final isLogged = Rx\u0026lt;Bool\u0026gt;(false); final count = Rx\u0026lt;Int\u0026gt;(0); final balance = Rx\u0026lt;Double\u0026gt;(0.0); final number = Rx\u0026lt;Num\u0026gt;(0) final items = Rx\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;([]); final myMap = Rx\u0026lt;Map\u0026lt;String, int\u0026gt;\u0026gt;({}); // 自定义类 - 可以是任何类 final user = Rx\u0026lt;User\u0026gt;(); 3 - 第三种更实用、更简单和首选的方法，只需添加 .obs 作为value的属性。\nfinal name = \u0026#39;\u0026#39;.obs; final isLogged = false.obs; final count = 0.obs; final balance = 0.0.obs; final number = 0.obs; final items = \u0026lt;String\u0026gt;[].obs; final myMap = \u0026lt;String, int\u0026gt;{}.obs; // 自定义类 - 可以是任何class, literally final user = User().obs; 使用value // controller final count1 = 0.obs; final count2 = 0.obs; int get sum =\u0026gt; count1.value + count2.value; // 由于.obs把变量换成`Rx{Type}`类型，所以需要用.value取值 // 视图 GetX\u0026lt;Controller\u0026gt;( builder: (controller) { print(\u0026#34;count 1 rebuild\u0026#34;); return Text(\u0026#39;${controller.count1.value}\u0026#39;); }, ), GetX\u0026lt;Controller\u0026gt;( builder: (controller) { print(\u0026#34;count 2 rebuild\u0026#34;); return Text(\u0026#39;${controller.count2.value}\u0026#39;); }, ), GetX\u0026lt;Controller\u0026gt;( builder: (controller) { print(\u0026#34;count 3 rebuild\u0026#34;); return Text(\u0026#39;${controller.sum}\u0026#39;); }, ), Obx class StateObxView extends StatelessWidget { StateObxView({Key? key}) : super(key: key); final count = 0.obs; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\u0026#34;Obx(...)\u0026#34;), ), body: Center( child: Column( children: [ Obx(() =\u0026gt; Text(\u0026#34;count1 -\u0026gt; \u0026#34; + count.toString())), Obx(() =\u0026gt; Text(\u0026#34;count2 -\u0026gt; \u0026#34; + count.toString())), // Divider(), ElevatedButton( onPressed: () { count.value++; }, child: Text(\u0026#39;add\u0026#39;), ), ], ), ), ); } } GetX Controller\nclass CountController extends GetxController { final _count = 0.obs; set count(value) =\u0026gt; this._count.value = value; get count =\u0026gt; this._count.value; final _count2 = 0.obs; set count2(value) =\u0026gt; this._count2.value = value; get count2 =\u0026gt; this._count2.value; add() =\u0026gt; _count.value++; add2() =\u0026gt; _count2.value++; } View\nclass StateGetxView extends StatelessWidget { StateGetxView({Key? key}) : super(key: key); final controller = CountController(); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\u0026#34;Getx\u0026#34;), ), body: Center( child: Column( children: [ GetX\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetX - 1\u0026#34;); return Text(\u0026#39;value 1 -\u0026gt; ${_.count}\u0026#39;); }, ), GetX\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetX - 2\u0026#34;); return Text(\u0026#39;value 2 -\u0026gt; ${_.count}\u0026#39;); }, ), Divider(), // GetX\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetX - 3\u0026#34;); return Column( children: [ Text(\u0026#39;value 3 -\u0026gt; ${_.count}\u0026#39;), ElevatedButton( onPressed: () { _.add(); }, child: Text(\u0026#39;count1\u0026#39;), ) ], ); }, ), Divider(), // count2 GetX\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetX - 4\u0026#34;); return Text(\u0026#39;value 4 -\u0026gt; ${_.count2}\u0026#39;); }, ), Divider(), // 按钮 ElevatedButton( onPressed: () { controller.add(); }, child: Text(\u0026#39;count1\u0026#39;), ), ElevatedButton( onPressed: () { controller.add2(); }, child: Text(\u0026#39;count2\u0026#39;), ), ], ), ), ); } } 简单状态管理 GetBuilder Controller同Getx\nView\nclass StateGetBuilderView extends StatelessWidget { StateGetBuilderView({Key? key}) : super(key: key); final controller = CountController(); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\u0026#34;GetBuilder\u0026#34;), ), body: Center( child: Column( children: [ GetBuilder\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 1\u0026#34;); return Text(\u0026#39;value -\u0026gt; ${_.count}\u0026#39;); }, ), GetBuilder\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 2\u0026#34;); return Text(\u0026#39;value -\u0026gt; ${_.count}\u0026#39;); }, ), Divider(), // GetBuilder\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 3\u0026#34;); return Column( children: [ Text(\u0026#39;value -\u0026gt; ${_.count}\u0026#39;), ElevatedButton( onPressed: () { _.add(); }, child: Text(\u0026#39;GetBuilder -\u0026gt; add\u0026#39;), ) ], ); }, ), Divider(), // count2 GetBuilder\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 4\u0026#34;); return Text(\u0026#39;value count2 -\u0026gt; ${_.count2}\u0026#39;); }, ), Divider(), // id2 标记一个 `builder` ，触发方式`controller.update([\u0026#34;id2\u0026#34;]);` ，可传多个 `Array` 类型。 GetBuilder\u0026lt;CountController\u0026gt;( id: \u0026#34;id2\u0026#34;, init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 4\u0026#34;); return Text(\u0026#39;id2 -\u0026gt; value count2 -\u0026gt; ${_.count2}\u0026#39;); }, ), Divider(), // 按钮 ElevatedButton( onPressed: () { controller.add(); }, child: Text(\u0026#39;add\u0026#39;), ), ElevatedButton( onPressed: () { controller.add2(); }, child: Text(\u0026#39;add2\u0026#39;), ), ElevatedButton( onPressed: () { controller.update(); }, child: Text(\u0026#39;controller.update()\u0026#39;), ), ElevatedButton( onPressed: () { controller.update([\u0026#34;id2\u0026#34;]); }, child: Text(\u0026#39;controller.update(id2)\u0026#39;), ), ], ), ), ); } } Workers Workers可以精确控制事件发生时触发回调，常用于Controller的onInit中：\nclass CountController extends GetxController { final _count = 0.obs; set count(value) =\u0026gt; this._count.value = value; get count =\u0026gt; this._count.value; add() =\u0026gt; _count.value++; @override void onInit() { super.onInit(); // 每次_count变化时调用 ever(_count, (value) { print(\u0026#34;ever -\u0026gt; \u0026#34; + value.toString()); }); // 第一次被改变时才会被调用。 once(_count, (value) { print(\u0026#34;once -\u0026gt; \u0026#34; + value.toString()); }); // 防DDos - 每当用户停止输入1秒时调用 debounce( _count, (value) { print(\u0026#34;debounce -\u0026gt; \u0026#34; + value.toString()); }, time: Duration(seconds: 1), ); // 忽略1秒内的所有变化。 interval( _count, (value) { print(\u0026#34;interval -\u0026gt; \u0026#34; + value.toString()); }, time: Duration(seconds: 1), ); } } 路由管理 普通路由 // 导航到新的页面。 Get.to(NextScreen()); // 要导航到下一条路由，并在返回后立即接收或更新数据。 var data = await Get.to(Payment()); // 关闭SnackBars、Dialogs、BottomSheets或任何你通常会用Navigator.pop(context)关闭的东西。 Get.back(); // 在另一个页面上，发送前一个路由的数据。并使用它。 Get.back(result: \u0026#39;success\u0026#39;); if(data == \u0026#39;success\u0026#39;) madeAnything(); // 进入下一个页面，但没有返回上一个页面的选项（用于SplashScreens，登录页面等）。 Get.off(NextScreen()); // 进入下一个界面并取消之前的所有路由（在购物车、投票和测试中很有用）。 Get.offAll(NextScreen()); 别名路由 普通路由管理起来比较麻烦,通常我们使用别名路由。\n// 导航到下一个页面 Get.toNamed(\u0026#34;/NextScreen\u0026#34;); // 传递参数 Get.toNamed(\u0026#34;/NextScreen\u0026#34;, arguments: \u0026#34;Hello\u0026#34;); // 浏览并删除前一个页面。 Get.offNamed(\u0026#34;/NextScreen\u0026#34;); // 浏览并删除所有以前的页面。 Get.offAllNamed(\u0026#34;/NextScreen\u0026#34;); // 动态URL Get.offAllNamed(\u0026#34;/NextScreen?device=phone\u0026amp;id=354\u0026amp;name=Enzo\u0026#34;); 示例 1\n注册时跳到到Pin页面，路由传参：\n// RegisterController Get.offNamed( RouteNames.systemRegisterPin, arguments: UserRegisterReq( username: userNameController.text, email: emailController.text, password: password, ), ); 从路由接收参数：\n// RegisterPinController UserRegisterReq? req = Get.arguments; 依赖注入 Get.put()： 不使用控制器实例也会被创建\nGet.put(CountController()); Get.lazyPut()： 懒加载方式创建实例，只有在使用时才创建\nGet.lazyPut\u0026lt;CountController\u0026gt;(() =\u0026gt; CountController()); Get.putAsync()： Get.put()的异步版版本\nGet.putAsync\u0026lt;CountController\u0026gt;(() async =\u0026gt; await CountController()); Get.create()： 每次使用都会创建一个新的实例\nGet.find()： 你可以实例化100万个控制器，Get总会找到你所需的控制器\nGet.find\u0026lt;CountController\u0026gt;(); 其他 GetView 一个已注册Controller的const StatelessWidget。\nGetxService 这个类就像一个GetxController，需要在应用程序的生命周期绝对持久化类实例，使用GetxService。\n其他高级 API https://github.com/jonataslaw/getx#other-advanced-apis\ndio 原理 # dio_mixin.dart 文件中 DioMixin 实现了 Dio abstract class DioMixin implements Dio { @override Future\u0026lt;Response\u0026lt;T\u0026gt;\u0026gt; post\u0026lt;T\u0026gt;( String path, { # path： 请求的url链接 data, # data： 请求数据，例如上传用到的FromData Map\u0026lt;String, dynamic\u0026gt;? queryParameters, # data： 请求数据，例如上传用到的FromData Options? options, # queryParameters： 查询参数 CancelToken? cancelToken, # cancelToken： 用来取消发送请求的token ProgressCallback? onSendProgress, # onSendProgress： 网络请求发送的进度 ProgressCallback? onReceiveProgress, # onSendProgress： 网络请求发送的进度 }) { return request\u0026lt;T\u0026gt;( # 返回request方法 path, data: data, options: checkOptions(\u0026#39;POST\u0026#39;, options), queryParameters: queryParameters, cancelToken: cancelToken, onSendProgress: onSendProgress, onReceiveProgress: onReceiveProgress, ); } } get() post() 等调用时，返回request方法，request 方法对请求参数处理，并返回 fetch 方法，fetch 进行响应数据设定、构建请求流、添加拦截器、请求分发。\nWebView WebView是应用内显示网页的功能，查看项目的官网、文档、条款等经常用到。推荐使用flutter_inappwebview，比官方webview_flutter有更丰富的功能和详尽的文档。主要功能：\nInAppWebView：是一个内嵌原生 WebView 小部件，集成到 Flutter 小部件树中。\nContextMenu：WebView 的快捷菜单。例如长按网页文本后的复制。 HeadlessInAppWebView：无头模式下的 WebView。在没有界面或UI的情况下运行WebView。它可以在没有用户界面的情况下执行网页加载和渲染操作，而不需要在用户界面中显示网页，用于后台处理网页数据、自动化测试、网络爬虫等。 InAppBrowser\nInAppBrowser：显示在 Flutter 应用程序顶部的原生 WebView，它没有集成到 Flutter 小部件树中。 ChromeSafariBrowser：Android 上的 Chrome 自定义选项卡和 iOS 上的SFSafariViewController。 InAppLocalhostServer：这个类允许你在 http://localhost:[port] 上创建一个简单的服务器。默认端口值为 8080。能够在本地服务器上缓存 js，html等资产文件，优化加载时间。\nCookieManager：此类实现了一个单例对象（共享实例），该对象管理 WebView 实例使用的 cookie。\nHttpAuthCredentialDatabase：此类实现管理共享 HTTP 身份验证凭据缓存的单例对象（共享实例）。\nWebStorageManager：这个类实现了一个单例对象（共享实例），它管理 WebView 实例使用的 Web 存储。\nService Worker：Service Worker 是 PWA 的基本组成部分。它们支持快速加载（无论网络如何）、离线访问、推送通知和其他功能。\nInAppWebView官方示例注释\rimport \u0026#39;dart:async\u0026#39;; import \u0026#39;package:flutter/foundation.dart\u0026#39;; import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:flutter_inappwebview/flutter_inappwebview.dart\u0026#39;; import \u0026#39;package:url_launcher/url_launcher.dart\u0026#39;; Future main() async { WidgetsFlutterBinding.ensureInitialized(); // 如果是Android，则对加载到 WebView 中的 Web内容（HTML/CSS/JavaScript）启用调试 if (!kIsWeb \u0026amp;\u0026amp; defaultTargetPlatform == TargetPlatform.android) { await InAppWebViewController.setWebContentsDebuggingEnabled(true); } runApp(const MaterialApp(home: MyApp())); } class MyApp extends StatefulWidget { const MyApp({super.key}); @override State\u0026lt;MyApp\u0026gt; createState() =\u0026gt; _MyAppState(); } class _MyAppState extends State\u0026lt;MyApp\u0026gt; { final GlobalKey webViewKey = GlobalKey(); InAppWebViewController? webViewController; InAppWebViewSettings settings = InAppWebViewSettings( // 能够监听 WebView.shouldOverrideUrlLoading（URL即将加载时）的事件。 useShouldOverrideUrlLoading: true, // 设置为 true 以防止 HTML5 音频或视频自动播放。 mediaPlaybackRequiresUserGesture: false, // 允许 HTML5 媒体播放在屏幕布局中内嵌显示，即让媒体播放器嵌入到网页的其他内容中一起显示 allowsInlineMediaPlayback: true, // 根据请求的来源定义了哪些功能可供使用（例如，访问麦克风、摄像头、电池、网络共享等） iframeAllow: \u0026#34;camera; microphone\u0026#34;, // 如果 iframe 可以通过调用 requestFullscreen() 方法激活全屏模式，则设置为 true。 iframeAllowFullscreen: true ); PullToRefreshController? pullToRefreshController; String url = \u0026#34;\u0026#34;; double progress = 0; final urlController = TextEditingController(); @override void initState() { super.initState(); // 在 WebView 中开启下拉刷新 pullToRefreshController = kIsWeb ? null : PullToRefreshController( settings: PullToRefreshSettings( color: Colors.blue, ), onRefresh: () async { if (defaultTargetPlatform == TargetPlatform.android) { webViewController?.reload(); } else if (defaultTargetPlatform == TargetPlatform.iOS) { webViewController?.loadUrl( urlRequest: URLRequest(url: await webViewController?.getUrl())); } }, ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text(\u0026#34;Official InAppWebView website\u0026#34;)), body: SafeArea( child: Column(children: \u0026lt;Widget\u0026gt;[ TextField( decoration: const InputDecoration(prefixIcon: Icon(Icons.search)), controller: urlController, keyboardType: TextInputType.url, onSubmitted: (value) { var url = WebUri(value); if (url.scheme.isEmpty) { url = WebUri(\u0026#34;https://www.google.com/search?q=$value\u0026#34;); } webViewController?.loadUrl(urlRequest: URLRequest(url: url)); }, ), Expanded( child: Stack( children: [ InAppWebView( key: webViewKey, // 初始化URL initialUrlRequest: URLRequest(url: WebUri(\u0026#34;https://inappwebview.dev/\u0026#34;)), // 初始化设置 initialSettings: settings, // 下拉刷新 pullToRefreshController: pullToRefreshController, // 创建 WebView 时触发的事件 onWebViewCreated: (controller) { webViewController = controller; }, // 当 WebView 开始加载 url 时触发的事件。 onLoadStart: (controller, url) { setState(() { this.url = url.toString(); urlController.text = this.url; }); }, // 请求无访问权限资源 时触发的事件。 onPermissionRequest: (controller, request) async { return PermissionResponse( resources: request.resources, action: PermissionResponseAction.GRANT); }, // 让APP有机会在 URL即将加载 时进行控制。 shouldOverrideUrlLoading: (controller, navigationAction) async { var uri = navigationAction.request.url!; if (![ \u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;, \u0026#34;file\u0026#34;, \u0026#34;chrome\u0026#34;, \u0026#34;data\u0026#34;, \u0026#34;javascript\u0026#34;, \u0026#34;about\u0026#34; ].contains(uri.scheme)) { if (await canLaunchUrl(uri)) { // Launch the App await launchUrl( uri, ); // and cancel the request return NavigationActionPolicy.CANCEL; } } return NavigationActionPolicy.ALLOW; }, // 完成加载 url 时触发的事件。 onLoadStop: (controller, url) async { pullToRefreshController?.endRefreshing(); setState(() { this.url = url.toString(); urlController.text = this.url; }); }, // 加载请求时遇到错误 时触发的事件。 onReceivedError: (controller, request, error) { pullToRefreshController?.endRefreshing(); }, // 更改正在加载的页面 时触发的事件。 onProgressChanged: (controller, progress) { if (progress == 100) { pullToRefreshController?.endRefreshing(); } setState(() { this.progress = progress / 100; urlController.text = url; }); }, // APP更新其访问的链接 时触发的事件。 onUpdateVisitedHistory: (controller, url, androidIsReload) { setState(() { this.url = url.toString(); urlController.text = this.url; }); }, // WebView收到控制台报错 时触发的事件。 onConsoleMessage: (controller, consoleMessage) { if (kDebugMode) { print(consoleMessage); } }, ), // 进度指示器 progress \u0026lt; 1.0 ? LinearProgressIndicator(value: progress) : Container(), ], ), ), ButtonBar( alignment: MainAxisAlignment.center, children: \u0026lt;Widget\u0026gt;[ // 后退按钮 ElevatedButton( child: const Icon(Icons.arrow_back), onPressed: () { webViewController?.goBack(); }, ), // 前进按钮 ElevatedButton( child: const Icon(Icons.arrow_forward), onPressed: () { webViewController?.goForward(); }, ), // 刷新按钮 ElevatedButton( child: const Icon(Icons.refresh), onPressed: () { webViewController?.reload(); }, ), ], ), ]) ) ); } } FlexColorPicker FlexColorPicker 是 Fl​​utter 的可定制颜色选择器。可以使用 Material 2 和 Material 3。\n// 属性 ColorPicker( color: selectedColor, // 启用tab栏选择器:both, primary, accent, bw, custom, wheel pickersEnabled: const \u0026lt;ColorPickerType, bool\u0026gt;{ ColorPickerType.both: true, ColorPickerType.primary: false, ColorPickerType.accent: false, ColorPickerType.bw: false, ColorPickerType.custom: false, ColorPickerType.wheel: true, }, // 自定义颜色 // customColorSwatchesAndNames: customSwatches, // 定制tab标签 pickerTypeLabels: \u0026lt;ColorPickerType, String\u0026gt;{ ColorPickerType.both: \u0026#39;preset\u0026#39;.tr, ColorPickerType.wheel: \u0026#39;custom\u0026#39;.tr, }, // 在选择主要颜色后，基于所选颜色为您提供一组它的深浅颜色,禁用时才需要此属性 // enableShadesSelection:false, // 生成所选颜色的 15 种色调的 Material 3 色调调色板 enableTonalPalette: true, // 颜色不透明度滑块 enableOpacity: true, // 显示所选颜色名称 showMaterialName: true, materialNameTextStyle: Theme.of(context).textTheme.bodySmall, showColorName: true, colorNameTextStyle: Theme.of(context).textTheme.bodySmall, // 显示所选颜色的 RGB 颜色值 showColorCode: true, // colorCodeHasColor: true, // showColorValue: true, colorCodeTextStyle: Theme.of(context).textTheme.bodyMedium, colorCodePrefixStyle: Theme.of(context).textTheme.bodySmall, // 显示最近选择的颜色 // showRecentColors: true, // maxRecentColors: 8, // recentColors: , // onRecentColorsChanged: , // 标题 title: Text( \u0026#39;ColorPicker\u0026#39;, style: Theme.of(context).textTheme.headline6, ), heading: Text( \u0026#39;Select color\u0026#39;, style: Theme.of(context).textTheme.headline5, ), subheading: Text( \u0026#39;Select color shade\u0026#39;, style: Theme.of(context).textTheme.headline1, ), wheelSubheading: Text( \u0026#39;Selected color and its shades\u0026#39;, style: Theme.of(context).textTheme.headline1, ), opacitySubheading: Text( \u0026#39;Opacity\u0026#39;, style: Theme.of(context).textTheme.headline1, ), recentColorsSubheading: Text( \u0026#39;Selected color and its color swatch\u0026#39;, style: Theme.of(context).textTheme.headline1, ), // 各个颜色小部件的大小、形状和间距以及色轮和不透明度滑块大小的属性。 width: 40, height: 40, borderRadius: 4, spacing: 5, runSpacing: 5, hasBorder: false, // borderColor: Theme.of(context).dividerColor, elevation: 0, // 轮盘直径、宽度和边框 wheelDiameter: 155, wheelWidth: 16, wheelHasBorder: false, // borderColor: Theme.of(context).dividerColor, // 颜色元素的间距、对齐方式和填充 crossAxisAlignment: CrossAxisAlignment.center, padding: const EdgeInsets.all(16), columnSpacing: 0, // 复制按钮,确定按钮,取消按钮,关闭按钮 enableTooltips: ture, // Dialog“确定”和“取消”操作按钮以及样式 actionButtons: const ColorPickerActionButtons(...), // 颜色的复制粘贴行为 copyPasteBehavior: const ColorPickerCopyPasteBehavior( // 颜色代码后缀复制按钮 editFieldCopyButton: ture, // 键盘快捷键 ctrlC: ture, ctrlV: ture, // 工具栏按钮 copyButton: ture, copyIcon: ture, copyTooltip: MaterialLocalizations.of(context).copyButtonLabel, pasteButton: ture, pasteIcon: ture, pasteTooltip: MaterialLocalizations.of(context).pasteButtonLabel, // 从选取器复制颜色并将颜色粘贴 longPressMenu: ture, secondaryMenu: ture, secondaryOnDesktopLongOnDevice: ture, // 颜色代码格式和粘贴解析 copyFormat: ColorPickerCopyFormat.dartCode， parseShortHexCode: ture, editUsesParsedPaste: ture, snackBarParseError: ture, snackBarMessage: ture, snackBarDuration: const Duration(milliseconds: 1800), feedbackParseError: false, ), // 回调 // 当选择具有所选新颜色值的新颜色时调用 onColorChanged: (Color color) { selectedColor = color; }, // 开始颜色选择时调用 onColorChangeStart: , // 结束颜色选择时调用 onColorChangeEnd: , // 返回最近选择的颜色的当前列表 onRecentColorsChanged: , ), // dialog方法： // 在对话框打开时跟踪 ColorPicker 的不同onChange回调 ColorPicker(...).showPickerDialog; // dialog函数： // 只需传入对话框的构建上下文以及所需的起始颜色值，并等待它在对话框关闭时返回选定的颜色 showColorPickerDialog(...) Widgetbook(仅作了解) 使用Widgetbook可以管理组件、使用不同设备尺寸测试组件、实时修改组件参数、协作共享。\nWindows配置 确保安装Visual Studio，及其应用： 从https://www.nuget.org/downloads下载最新的nuget.exe,并放入任意文件夹（我的在C:\\Program Files\\Microsoft Visual Studio），配置系统环境变量。\n使用 在pubspec.yaml安装 widgetbook 组件 注意是放在 dev_dependencies 下面\ndev_dependencies: flutter_test: sdk: flutter flutter_lints: ^2.0.0 widgetbook: ^3.0.0-beta.14 新建lib/app.widgetbook.dart import \u0026#39;package:flutter/material.dart\u0026#39;; // ignore: depend_on_referenced_packages import \u0026#39;package:widgetbook/widgetbook.dart\u0026#39;; import \u0026#39;你的组件\u0026#39;; void main() { runApp(const HotReload()); } class HotReload extends StatelessWidget { const HotReload({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return Widgetbook.material( // Widgetbook 属性选择 addons: [ // 主题 // buildMaterialThemeAddon(), // 字体大小 // buildTextScaleAddon(), ], // 可以容纳包、文件夹、类别、组件和用例 directories: [ // buildWidgetbookCategory(), // //buildWidgetbookCategory2(), ], ); } TextScaleAddon buildTextScaleAddon() { return TextScaleAddon( setting: TextScaleSetting.firstAsSelected( textScales: [1.0, 1.25, 1.5, 1.75, 2])); } MaterialThemeAddon buildMaterialThemeAddon() { return MaterialThemeAddon( setting: MaterialThemeSetting.firstAsSelected(themes: [ WidgetbookTheme(name: \u0026#34;dark\u0026#34;, data: ThemeData.dark()), WidgetbookTheme(name: \u0026#34;light\u0026#34;, data: ThemeData.light()), ])); } WidgetbookCategory buildWidgetbookCategory() { return WidgetbookCategory( // 分类名 name: \u0026#39;公共组件\u0026#39;, children: [ WidgetbookComponent( // 组件名 name: \u0026#39;Spinkit加载\u0026#39;, useCases: [ WidgetbookUseCase.center( // 组件用例名 name: \u0026#34;SpinKitFadingCircle\u0026#34;, child: mySpinkit(), ), ], ), ], ); } } Plugin Flutter Plugin是可以插入到主程序中，扩展功能的独立组件，我们实现原生平台的功能就需要用到。\n创建\n使用 Android Studio 创建 Flutter 项目，项目类型选 plugin 。目录如下\nproject ├── android // 原生代码 ├── example // 运行调试 ├── android // 创建插件后用Android Studio运行此目录 ├── ios // 原生代码 ├── lib // 依赖： 由于该项目作为 Flutter 插件加载，不能识别Android依赖，在 Android Studio 中打开 Tools -\u0026gt; Flutter -\u0026gt; Open For Editing In Android Studio 可以看到依赖。缺java本地依赖请回看本文gradle小节。\nFlutter Flutter有三种类型的Channel:\nBasicMessageChannel:用于传递字符串和半结构化的信息。持续通信，收到消息后可以回复此次消息，如：Native将遍历到的文件信息陆续传递到Dart。 MethodChannel:用于传递方法调用(method invocation)。一次性通信：如Flutteri调用Native拍照； EventChannel:用于数据流(event streams)的通信。持续通信，收到消息后无法回复此次消息，通过长用于Native向Dat的通信，如：手机电量变化，网络连接变化，陀螺仪，传感器等； Channel支持的数据类型：\nDart Android ios null null nil (NSNull when nested) bool java.lang.Boolean NSNumber numberWithBool: int java.lang.Integer NSNumber numberWithInt: int, if 32 bits notenough java.lang.Long NSNumber numberWithLong: double java.lang.Double NSNumber numberWithDouble: String java.lang.String NSString Uint8List byte[] FlutterStandardTypedData typedDataWithBytes: Int32List int][] FlutterStandardTypedData typedDataWithInt32: Int64List long[] FlutterStandardTypedData typedDataWithInt64: Float64List double[] FlutterStandardTypedData typedDataWithFloat64: List java.util.ArrayList NSArray Map java.util.HashMap NSDictionary Android Java 访问修饰符 访问范围 private default protected public 同一类中 √ √ √ √ 同一包中(子类和非子类) × √ √ √ 不同包中的子类 × × √ √ 不同包中的非子类 × × × √ 进程和线程 进程\nAndroid系统会为每个应用程序创建一个进程 如果该应用程序的进程已经存在（已有组件已经在运行），那么刚启动的组件会在已有的进程和线程中启动运行 组件可以运行在指定的其他线程，在AndroidManifest文件中的每种组件标签都支持设置 android:process 属性 系统会依据进程的“importance hierarchy”等级清除进程，这是为了回收系统资源和新建进程 Binder/Socket用于进程间通信 线程\n系统会为应用程序创建一个名为“main”的主线程，不会为每个组件的实例创建单独的线程 通常实现Runnable接口来定义线程的执行逻辑，然后将其传递给Thread类来启动线程 Handler用于同进程的线程间通信，子线程运行并生成Message，Looper获取message并传递给Handler，Handler逐个获取子线程中的Message 概念 定义 作用 主线程 (UI线程、Main Thread) 当应用程序启动时，会自动开启1条主线程 处理与UI相关的事件(如更新、操作等) 子线程 (工作线程) 人为手动开启的线程 执行耗时操作(如网络请求、数据加载等) 消息 (Message) 线程间通讯的数据单元 (即Handler接受\u0026amp;处理的消息对象) 存储需操作的通信信息 消息队列 (Message Queue) 一种数据结构(存储特点：先进先出) 存储Handler发送过来的消息(Message) 处理者 (Handler) 主线程与子线程的通信媒介线程消息的主要处理者 * 添加消息(Message)到消息队列(Message Queue) *处理循环器(Looper)分派过来的消息(Message) 循环器 (Looper) 消息队列(Message Queue)与处理者(Handler)的通信媒介 每个线程中只能拥有1个Looper，多个线程可往1个Looper所持有的MessageQueue 中发送消息，提供了线程间通信的可能 * 消息获取：循环取出消息队列(Message Queue)的消息(Message) * 消息分发：将取出的消息(Message)发送给对应的处理者(Handler) View.post() View类中的方法，适用于任何View对象 * 将Runnable对象添加到View的事件队列中 * 获取View的宽高等属性值 ThreadLocal 提供线程本地变量 ThreadLocal为每一个线程开辟了一个独立的存储器，只有对应的线程才能够访问其数据 runOnUiThread() Activity类中的方法，仅适用于Activity 将Runnable对象添加到Activity的事件队列中，可以确保其在当前主线程中执行 参考：Handler、Android多线程\n生命周期 View的生命周期方法\n英文原表\n类别 方法 描述 \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td rowspan=\u0026quot;2\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;创建\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;构造函数\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;构造函数有两种形式，一种是在通过代码创建视图时调用的，另一种是在通过布局文件填充视图时调用的。第二种形式解析并应用布局文件中定义的属性。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onFinishInflate()\u0026quot;\u0026gt;onFinishInflate()\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;在视图及其所有子视图都从 XML 中映射后调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td rowspan=\u0026quot;3\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;布局\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onMeasure(int,%20int)\u0026quot;\u0026gt;onMeasure(\u0026lt;wbr\u0026gt;int,\u0026lt;wbr\u0026gt; int)\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;调用来确定此视图及其所有子视图的尺寸要求。 \u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onLayout(boolean,%20int,%20int,%20int,%20int)\u0026quot;\u0026gt;onLayout(\u0026lt;wbr\u0026gt;boolean,\u0026lt;wbr\u0026gt; int,\u0026lt;wbr\u0026gt; int,\u0026lt;wbr\u0026gt; int,\u0026lt;wbr\u0026gt; int)\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;当此视图必须为其所有子视图分配大小和位置时调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onSizeChanged(int,%20int,%20int,%20int)\u0026quot;\u0026gt;onSizeChanged(\u0026lt;wbr\u0026gt;int,\u0026lt;wbr\u0026gt; int,\u0026lt;wbr\u0026gt; int,\u0026lt;wbr\u0026gt; int)\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;当此视图的大小改变时调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;绘画\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onDraw(android.graphics.Canvas)\u0026quot;\u0026gt;onDraw(\u0026lt;wbr\u0026gt;Canvas)\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;当视图必须呈现其内容时调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td rowspan=\u0026quot;4\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;事件处理\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onKeyDown(int,%20android.view.KeyEvent)\u0026quot;\u0026gt;onKeyDown(\u0026lt;wbr\u0026gt;int,\u0026lt;wbr\u0026gt; KeyEvent)\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;当发生按键事件时调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onKeyUp(int,%20android.view.KeyEvent)\u0026quot;\u0026gt;onKeyUp(\u0026lt;wbr\u0026gt;int,\u0026lt;wbr\u0026gt; KeyEvent)\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;当发生按键释放事件时调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onTrackballEvent(android.view.MotionEvent)\u0026quot;\u0026gt;onTrackballEvent(\u0026lt;wbr\u0026gt;MotionEvent)\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;当轨迹球运动事件发生时调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onTouchEvent(android.view.MotionEvent)\u0026quot;\u0026gt;onTouchEvent(\u0026lt;wbr\u0026gt;MotionEvent)\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;当发生触摸屏运动事件时调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td rowspan=\u0026quot;2\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;焦点\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onFocusChanged(boolean,%20int,%20android.graphics.Rect)\u0026quot;\u0026gt;onFocusChanged(\u0026lt;wbr\u0026gt;boolean,\u0026lt;wbr\u0026gt; int,\u0026lt;wbr\u0026gt; Rect)\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;当视图获得或失去焦点时调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onWindowFocusChanged(boolean)\u0026quot;\u0026gt;onWindowFocusChanged(\u0026lt;wbr\u0026gt;boolean)\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;当包含视图的窗口获得或失去焦点时调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td rowspan=\u0026quot;3\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;附加\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onAttachedToWindow()\u0026quot;\u0026gt;onAttachedToWindow()\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;当视图附加到窗口时调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onDetachedFromWindow()\u0026quot;\u0026gt;onDetachedFromWindow()\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;当视图与其窗口分离时调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;code translate=\u0026quot;no\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;file:///C:/reference/android/view/View#onWindowVisibilityChanged(int)\u0026quot;\u0026gt;onWindowVisibilityChanged(\u0026lt;wbr\u0026gt;int)\u0026lt;/a\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;\u0026lt;font style=\u0026quot;vertical-align: inherit;\u0026quot;\u0026gt;当包含视图的窗口的可见性发生改变时调用。\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; Activity的启动\nActivity 调用onCreate方法，将资源 ID R.layout.main_activity 更改为 setContentView() Activity 调用onWindowAttributesChanged 方法，而且这个方法连续调用多次 View 调用构造方法 View 调用onFinishInflate方法，说明这个时候View已经填充完毕，但是还没开始触发绘制过程 Activity 调用onstart方法， 进入“已启动”状态 Activity 再次调用 onWindowAttributesChanged 方法 Activity 调用onResume，“已恢复”状态，进行后面初始化步骤，并进入与用户互动的状态 Activity 调用onAttachedToWindow，Activity跟Window进行绑定 View 调用onAttachedToWindow，View跟Window进行绑定 View 调用 onWindowVisibilityChanged(int visibility)，参数变为 View.VISIABLE View 调用onMeasure，开始测量 View 调用onSizeChanged，表示测量完成，尺寸发生了变化 View 调用onLayout，开始摆放位置 View 调用 onDraw，开始绘制 Activity 调用onWindowFocusChanged(boolean hasFocus)，此时为true，代表窗体已经获取了焦点 View 调用 onWindowFocusChanged(boolean hasWindowFocus)，此时为true，代表当前的控件获取了Window焦点，当调用这个方法后说明当前Activity中的View才是真正的可见了 Activity的退出\nActivity 调用 onPause，中断时的暂停状态 View 调用 onWindowVisibilityChanged(int visibility)，参数变为 View.GONE，View中对应的Window隐藏 Activity 调用onWindowFocusChanged(boolean hasFocus)，此时为false，说明Actvity所在的Window已经失去焦点 Activity 调用 onStop，此时Activity已经切换到后台 Activity 调用 onDestory，此时Activity开始准备销毁，实际上并不代表Activity已经销毁 View 调用 onDetachedFromWindow，此时View 与Window解除绑定 Activity 调用 onDetathedFromWindow ，此时Activity 与Window 解除绑定 View即将被销毁，可以在 onDetachedFromWindow 方法中做一些资源释放，防止内存泄漏 android四大组件 1、activity （1）一个Activity通常就是一个单独的屏幕（窗口）。\n（2）Activity之间通过Intent进行通信。\n（3）android应用中每一个Activity都必须要在AndroidManifest.xml配置文件中声明，否则系统将不识别也不执行该Activity。\n2、service （1）service用于在后台完成用户指定的操作。service分为两种：\n（a）started（启动）：当应用程序组件（如activity）调用startService()方法启动服务时，服务处于started状态。\n（b）bound（绑定）：当应用程序组件调用bindService()方法绑定到服务时，服务处于bound状态。\n（2）startService()与bindService()区别：\n（a）started service（启动服务）是由其他组件调用startService()方法启动的，这导致服务的onStartCommand()方法被调用。当服务是started状态时，其生命周期与启动它的组件无关，并且可以在后台无限期运行，即使启动服务的组件已经被销毁。因此，服务需要在完成任务后调用stopSelf()方法停止，或者由其他组件调用stopService()方法停止。\n（b）使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。\n（3）开发人员需要在应用程序配置文件中声明全部的service，使用标签。\n（4）Service通常位于后台运行，它一般不需要与用户交互，因此Service组件没有图形用户界面。Service组件需要继承Service基类。Service组件通常用于为其他组件提供后台服务或监控其他组件的运行状态。\n3、content provider （1）android平台提供了Content Provider使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过ContentResolver类从该内容提供者中获取或存入数据。\n（2）只有需要在多个应用程序间共享数据是才需要内容提供者。例如，通讯录数据被多个应用程序使用，且必须存储在一个内容提供者中。它的好处是统一数据访问方式。\n（3）ContentProvider实现数据共享。ContentProvider用于保存和获取数据，并使其对所有应用程序可见。这是不同应用程序间共享数据的唯一方式，因为android没有提供所有应用共同访问的公共存储区。\n（4）开发人员不会直接使用ContentProvider类的对象，大多数是通过ContentResolver对象实现对ContentProvider的操作。\n（5）ContentProvider使用URI来唯一标识其数据集，这里的URI以content://作为前缀，表示该数据由ContentProvider来管理。\n4、broadcast receiver （1）你的应用可以使用它对外部事件进行过滤，只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力，例如闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。\n（2）广播接收者的注册有两种方法，分别是程序动态注册和AndroidManifest文件中进行静态注册。\n（3）动态注册广播接收器特点是当用来注册的Activity关掉后，广播也就失效了。静态注册无需担忧广播接收器是否被关闭，只要设备是开启状态，广播接收器也是打开着的。也就是说哪怕app本身未启动，该app订阅的广播在触发时也会对它起作用。\nChannel 创建Channel\n三种Channel 的构造十分相似：\nBasicMessageChannel(BinaryMessenger messenger,String name,MessageCodec\u0026lt;T\u0026gt; codec) MethodChannel(BinaryMessenger messenger,String name,MethodCodec codec) EventChannel(BinaryMessenger messenger,String name,MethodCodec codec) BinaryMessenger messenger 消息的发送与接收的工具； String name Channel的名字； MessageCodec\u0026lt;T\u0026gt; codec 消息的编解码器，它有几种不同类型的实现： BinaryCodec 最为简单的一种Codec,因为其返回值类型和入参的类型相同，均为二进制格式(Android中为ByteBuffer,.iS中为NSData)。实际上，BinaryCodec在编解码过程中什么都没做，只是原封不动将二进制数据消息返回而已。或许你会因此觉得BinaryCodec没有意义，但是在某些情况下它非常有用，比如使用BinaryCodec可以使传递内存数据块时在编解码阶段免于内存拷贝； StringCodec 用于字符串与二进制数据之间的编解码，其编码格式为UTF-8; JSONMessageCodec 用于基础数据与二进制数据之间的编解码，其支持基础数据类型以及列表、字典。其在iOS端使用了NSJSONSerialization作为序列化的工具，而在Android端则使用了其自定义的JSONUtil.与StringCodec作为序列化工具； StandardMessageCodec 是BasicMessageChannel的默认编解码器，其支持基础数据类型、二进制数据、列表、字典； 接收/发送消息 接收Dart发来的消息：\n// BasicMessageChannel setMessageHandler(MessageHandler\u0026lt;T\u0026gt; handler) // MethodChannel setMethodCallHandler(MethodCallHandler handler) // EventChannel void setstreamHandler(EventChannel.StreamHandler handler) 其参数：\n// BasicMessageChannel // var1 是消息内容 // var2 是回复此消息的回调函数 public interface MessageHandler\u0026lt;T\u0026gt; { void onMessage(T var1, BasicMessageChannel.Reply\u0026lt;T\u0026gt; var2); } // MethodChannel // var1.methed 表示 var1方法名的String // var1.arguments 表示 var1方法的参数 // var2：提供 var2.success、 var2.error、 var2.notImplemented 三种回复 public interface MethodCallHandler { void onMethodCall(MethodCall var1,Result var2); } // EventChannel // args 是传递的参数 // eventSink 提供 success、error、endOfStream 三个回调方法 // onCancel 取消监听时调用 public interface StreamHandler { void onListen(Object args,EventChannel.Eventsink eventsink); void onCancel(Object o); } 向dart发送消息：\nvoid send(T message) // dart不回复 void send(T message,BasicMessageChannel.Reply\u0026lt;T\u0026gt; callback) //dart回复 AndroidManifest.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; \u0026lt;!-- 应用的包名、版本 --\u0026gt; package=\u0026#34;com.example.app\u0026#34; android:versionCode=\u0026#34;1\u0026#34; android:versionName=\u0026#34;1.0.1\u0026#34;\u0026gt; \u0026lt;!-- 权限设置 ---\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34;/\u0026gt; \u0026lt;!---访问网络\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34;/\u0026gt; \u0026lt;!---网络连接是否有效\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34;/\u0026gt; \u0026lt;!--读写外部存储器\u0026gt; \u0026lt;application \u0026lt;!---参考：https://juejin.cn/post/7006296858494500877--\u0026gt; android:allowBackup=\u0026#34;true\u0026#34; \u0026lt;!---允许app数据备份--\u0026gt; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; \u0026lt;!--图标--\u0026gt; android:label=\u0026#34;@string/app_name\u0026#34; \u0026lt;!--标题--\u0026gt; android:name=\u0026#34;.App\u0026#34; \u0026lt;!--应用程序开始的类名--\u0026gt; android:theme=\u0026#34;@style/AppTheme\u0026#34; \u0026gt; \u0026lt;!--主题--\u0026gt; \u0026lt;activity android:name=\u0026#34;.ui.activities.MainActivity\u0026#34; \u0026lt;!--activity名称--\u0026gt; android:screenOrientation=\u0026#34;portrait\u0026#34; \u0026lt;!--限制此页为竖屏显示--\u0026gt; android:label=\u0026#34;@string/app_name\u0026#34; \u0026gt; \u0026lt;!--标签名称--\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;!--Main point--\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;!--启动时有效--\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;activity android:name=\u0026#34;.ui.activities.LoginActivity\u0026#34; android:screenOrientation=\u0026#34;portrait\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; \u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;service android:name=\u0026#34;com.csr.csrmesh2.MeshService\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;false\u0026#34; \u0026gt; \u0026lt;!--禁止此服务被其他组件调用和交互--\u0026gt; \u0026lt;/service\u0026gt; \u0026lt;receiver android:name=\u0026#34;.events.ConnectionChangeReceiver\u0026#34; android:label=\u0026#34;ConnectionChangeReceiver\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.net.conn.CONNECTIVITY_CHANGE\u0026#34; /\u0026gt; \u0026lt;!--网络连接发生变化--\u0026gt; \u0026lt;!-- \u0026lt;action android:name=\u0026#34;android.net.wifi.WIFI_STATE_CHANGED\u0026#34; /\u0026gt;--\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; \u0026lt;!--组件相关配置--\u0026gt; \u0026lt;meta-data android:name=\u0026#34;com.facebook.sdk.ApplicationId\u0026#34; android:value=\u0026#34;@string/facebook_app_id\u0026#34;/\u0026gt; \u0026lt;meta-data android:name=\u0026#34;com.facebook.sdk.ApplicationName\u0026#34; android:value=\u0026#34;@string/app_name\u0026#34; /\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 常用权限（查看权限大全）\n\u0026lt;!--网络--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_WIFI_STATE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.CHANGE_WIFI_STATE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.MODIFY_AUDIO_SETTINGS\u0026#34; /\u0026gt; \u0026lt;!--文件读写--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_EXTERNAL_STORAGE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34; /\u0026gt; \u0026lt;!--录音机--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.RECORD_AUDIO\u0026#34; /\u0026gt; \u0026lt;!--读取手机状态，获取IMEI --\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_PHONE_STATE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.MANAGE_EXTERNAL_STORAGE\u0026#34;/\u0026gt; \u0026lt;!--蓝牙--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.BLUETOOTH\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.BLUETOOTH_ADMIN\u0026#34; /\u0026gt; \u0026lt;!--相机，及硬件支持--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.CAMERA\u0026#34; /\u0026gt; \u0026lt;uses-feature android:name=\u0026#34;android.hardware.camera\u0026#34; /\u0026gt; \u0026lt;uses-feature android:name=\u0026#34;android.hardware.camera.autofocus\u0026#34; /\u0026gt; \u0026lt;!--接收彩信--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.RECEIVE_MMS\u0026#34; /\u0026gt; \u0026lt;!--访问GMail账户列表--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.GET_ACCOUNTS\u0026#34; /\u0026gt; \u0026lt;!--精确位置、粗略位置--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_FINE_LOCATION\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; /\u0026gt; \u0026lt;!--以下不太常用--\u0026gt; \u0026lt;!--读写日历--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_CALENDAR\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_CALENDAR\u0026#34; /\u0026gt; \u0026lt;!--读写通讯录--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_CONTACTS\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_CONTACTS\u0026#34; /\u0026gt; \u0026lt;!--读取电话号码，Android11及以上使用READ_PHONE_NUMBERS--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_PHONE_STATE\u0026#34; android:maxSdkVersion=\u0026#34;29\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_PHONE_NUMBERS\u0026#34; /\u0026gt; \u0026lt;!--获取传感器（心率等）信息--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.BODY_SENSORS\u0026#34; /\u0026gt; \u0026lt;!--收发短信--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.RECEIVE_SMS\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.SEND_SMS\u0026#34; /\u0026gt; \u0026lt;!--悬浮窗、在其他应用上显示--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.SYSTEM_ALERT_WINDOW\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.SYSTEM_OVERLAY_WINDOW\u0026#34; /\u0026gt; 存储权限\n参考\nXML视图 gravity属性值 说明 top 不改变控件大小，对齐到容器顶部 bottom 不改变控件大小，对齐到容器底部 left 不改变控件大小，对齐到容器左侧 right 不改变控件大小，对齐到容器右侧 center_vertical 不改变控件大小，对齐到容器纵向中央位置 center_horizontal 不改变控件大小，对齐到容器横向中央位置 center 不改变控件大小，对齐到容器中央位置 fill_vertical 若有可能，纵向拉伸以填满容器 fill_horizontal 若有可能，横向拉伸以填满容器 fill 若有可能，纵向横向同时拉伸填满容器 常用 API： FlutterPluginBinding: 向所有 FlutterEngine 注册的插件提供可用的资源。\nActivityPluginBinding : 绑定使ActivityAware插件可以访问关联的Activity和Activity的生命周期方法。\nActivityAware: FlutterPlugin 把 Activity生命周期事件 关联到 FlutterEngine中运行的Activity\nFlutterView: 在 Android 设备上显示 Flutter UI\nNotificationManager：用于通知用户发生的事件\nResources: 用于访问应用程序资源的类。\n调试 VS Code debug 参考\n运行前提\n当前编程语言环境 当前编程语言用于调试的扩展，例如Java Extension Pack 配置文件launch.json 按钮介绍\n继续：跳到下一个断点\n单步跳过：跳过当前语句（调用其他文件夹的所有语句），运行下一行\n单步调试：进入当前函数内，运行下一行\n单步跳出：当debug陷入某个循环时，跳出循环并执行循环外的语句\n重启\n配置文件\nlaunch.json是用于调试的配置文件，位于.vscode文件夹，大多数情况下会自动创建，也可以在左侧边栏Run and Debug点击create a launch.json file launch.json注释（无需了解）\r\u0026#34;configurations\u0026#34;: [ { // 正在调试的项目名称（左侧边栏下拉菜单） \u0026#34;name\u0026#34;: \u0026#34;flutter_project\u0026#34;, // 指定调试模式 // launch模式：支持断点调试 // attach模式：支持对运行中的程序（多为远程服务器)断点调试，点击Add Configuration，选择Attach to Process \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, // 编程语言 \u0026#34;type\u0026#34;: \u0026#34;dart\u0026#34; }, ] 断点类型\n在代码行左侧断点出右键看到3种类型：\nAdd Breakpoint：在断点处阻塞程序 Add Conditional Breakpoint：在条件为true时断点生效 Add Logpoint：程序运行中，以非阻塞的方式，记录调试日志 Inline Breakpoint：当一行代码中有多个函数，光标定位在函数前，Run -\u0026gt; New Breakpoint -\u0026gt; Inline Breakpoint，断点在当前函数之前生效，点击单步调试可以进入当前函数 布局调试 参考\n模拟器 开启hyper-v()\nWindows搜索 -\u0026gt; 启用与关闭Windows功能 -\u0026gt; hyper-v\n模拟器报错：找不到libandroid-emu-metrics.dll，重启hyper-v\nvscode连接第三方模拟器\n项目目录下执行：adb connect 127.0.0.1:[port]\nAI画图 Ai 设置：视图-\u0026gt;显示网格\n多边形变换：多边形工具-\u0026gt;自定义变换工具\n缩放：鼠标左键向右划放大、向左划缩小\n形状合成：选中区域-\u0026gt;形状生成器工具-\u0026gt;穿过需要的区域-\u0026gt;按住Alt穿过不要的区域\n渐变：双击圆圈弹出调色板\n动画 lottie需要用到Ae，rive是在线编辑。\n上架 包名 Android 是在 android ▸ app ▸ src ▸ main ▸ AndroidManifest.xml iOS 在 ios ▸ Runner ▸ Info.plist 应用名称 Android 是在 android ▸ app ▸ src ▸ main ▸ AndroidManifest.xml 中修改android:label=\u0026quot;XXX\u0026quot;; iOS 在 ios ▸ Runner ▸ Info.plist 中修改CFBundleName对应的Value 图标 Android 在android ▸ app ▸ src ▸ res ▸ mipmap-... 文件夹中替换相应图片 iOS 在 ios ▸ Runner ▸ Assets.xcassets ▸ AppIcon.appiconset文件夹中替换相应尺寸的图片， 如果使用不同的文件名，那还必须更新同一目录中的Contents.json文件。 启动图片 Android 在android ▸ app ▸ src ▸ res ▸ drawable ▸ launch_background.xml 通过自定义drawable来实现自定义启动界面。 iOS 在 ios ▸ Runner ▸ Assets.xcassets ▸ LaunchImage.imageset文件夹中替换相应尺寸的图片， 如果使用不同的文件名，那还必须更新同一目录中的Contents.json文件。 签名（安卓） 创建 android studio方法 以管理员身份运行 android studio -\u0026gt; 打开项目下的Android文件夹 -\u0026gt; Build -\u0026gt; Generate Signed Bundle / APK -\u0026gt; 选择 APK 点击 Next -\u0026gt; Create new\n命令行ketool方法（推荐） ketool容易修改密钥，参考Java8版官方文档或更多版本。\n使用：\n项目下的Android/app文件夹打开cmd\n// 创建keystore和密钥对 keytool -genkeypair -alias key -keyalg RSA -keysize 2048 -validity 10000 -keystore ./release.keystore.jks // 列出可用的证书别名（指定路径） keytool -list -v -keystore ./release.keystore.jks // 删除证书（指定别名、路径） keytool -delete -alias key -keystore ./release.keystore.jks 详细参数\r-genkeypair 生成密钥对（公钥和关联的私钥）。将该证书链和私钥存储在由alias标识的新密钥库条目中 -alias 别名，每个keystore都关联这一个独一无二的alias，这个alias通常不区分大小写 -keystore 密钥库位置 -keyalg 指定密钥的算法 (默认值：DSA) -keysize 指定密钥长度 （默认值取决于keyalg：RSA为2048，DSA为1024） -validity 指定创建的证书有效期多少天(默认 90) -storepass 指定密钥库的密码(获取keystore信息所需的密码) -keypass 指定别名条目的密码(私钥的密码) -dname 指定证书发行者信息 其中： “CN=名字与姓氏,OU=组织单位名称,O=组织名称,L=城市或区域名 称,ST=州或省份名称,C=单位的两字母国家代码” -list 显示密钥库中的证书信息 -export 将别名指定的证书导出到文件 keytool -export -alias 需要导出的别名 -keystore 指定keystore -file 指定导出的证书位置及证书名称 -storepass 密码 -file 参数指定导出到文件的文件名 -delete 删除密钥库中某条目 keytool -delete -alias 指定需删除的别 -keystore 指定keystore – storepass 密码 -printcert 查看导出的证书信息 keytool -printcert -file g:\\sso\\michael.crt -keypasswd 修改密钥库中指定条目口令 keytool -keypasswd -alias 需修改的别名 -keypass 旧密码 -new 新密码 -storepass keystore密码 -keystore sage -storepasswd 修改keystore口令 keytool -storepasswd -keystore g:\\sso\\michael.keystore(需修改口令的keystore) -storepass pwdold(原始密码) -new pwdnew(新密码) -import 将已签名数字证书导入密钥库 keytool -import -alias 指定导入条目的别名 -keystore 指定keystore -file 需导入的证书 中创建一个默认文件”.keystore”,还会产生一个mykey的别名，mykey中包含用户的公钥、私钥和证书(在没有指定生成位置的情况下,keystore会存在用户系统默认目录) 配置 为防止 build.gradle 协作时被修改、上线后反编译泄露，把密钥信息保存到 android/local.properties： storePassword=12345678 keyPassword=12345678 keyAlias=key storeFile=./release.keystore.jks local.properties默认不会被添加到Git提交到远程仓库。\n在android/app/build.gradle添加： // 读取 local.properties def mystoreFile = file(localProperties.getProperty(\u0026#39;storeFile\u0026#39;)) def mystorePassword = localProperties.getProperty(\u0026#39;storePassword\u0026#39;) def mykeyAlias = localProperties.getProperty(\u0026#39;keyAlias\u0026#39;) def mykeyPassword = localProperties.getProperty(\u0026#39;keyPassword\u0026#39;) // 签名配置 signingConfigs { release { keyAlias mykeyAlias keyPassword mykeyPassword storeFile mystoreFile storePassword mystorePassword } // // debug模式使用默认的 C:\\Users\u0026lt;用户名\u0026gt;.Android\\debug.keystore 进行签名，密码是 android // debug { // keyAlias \u0026#39;androiddebugkey\u0026#39; // keyPassword \u0026#39;android\u0026#39; // storeFile file(\u0026#39;C:\\\\Users\\\\90487\\\\.android\\\\debug.keystore\u0026#39;) // storePassword \u0026#39;android\u0026#39; // } } buildTypes { release { // TODO: Add your own signing config for the release build. // Signing with the debug keys for now, so `flutter run --release` works. signingConfig signingConfigs.release // // 混淆 // minifyEnabled false // // 混淆文件 // proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; } // debug { // signingConfig signingConfigs.debug // // // 包名后添加.debug，可以同时安装多个应用 // // applicationIdSuffix \u0026#39;.debug\u0026#39; // } } android studio验证配置：File -\u0026gt; Project Structure -\u0026gt; Modules -\u0026gt; Signing Configs\n参考：官方文档 buildTypes\n生成签名报告（可以获得md5） 点击右侧Gradle选项卡，android -\u0026gt; app -\u0026gt; Tasks -\u0026gt; android -\u0026gt; signingReport。\n如果 Gradle 面板目录中没有 signingReport 文件，进入设置项：File -\u0026gt; Settings -\u0026gt; Experimental -\u0026gt; 取消选中 Only include\u0026hellip;during Gradle Sync。然后同步一下：File -\u0026gt; Sync Project with Gradle Files。\n编译 apk 项目根目录下执行\nflutter build apk --split-per-abi bundles（google 平台需要 bundle 文件格式） 项目根目录下执行\nflutter build appbundle 输出 build/app/outputs/bundle/release/app-release.aab\n其他 double width = MediaQuery.of(context).size.width; 屏幕宽度\ndouble height = MediaQuery.of(context).size.height; 屏幕高度\n","date":"2022-04-30T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/flutter/","title":"flutter基础"},{"content":"root 前言：\n使用虚拟机 VMOS Pro，可以拥有大多应用权限，不必刷机。不同手机不同操作，刷机有变砖风险！\n步骤：\n解bl锁 各品牌手机解锁有所不同，三星、小米、一加、Google pixel等部分厂商官方给解锁。\n解锁困难的华为旧机：我用的是github的potatoNV短接解锁，如果其中没有你的手机，直接淘宝不要浪费时间。作者在youtube有教程，照做就好了（视频简介的USB com 1.0连接教程也要看，他的点击DriverSetup操作很快，不要漏了），短接点可以参考这里。获得解锁码搜华为工具箱即可解锁。\n刷入 TWRP (recovery)、刷rom（系统） 建议不要刷机软件一键刷机，都是一堆广告的系统。\n手机品牌官网下载对应机型的驱动，并在windows设备管理器确认连接。 twrp官网下载TWRP。（TWRP 类似于 windows PE，是修改系统的程序。也可以去https://unofficialtwrp.com下载，收录了全面的非官方TWRP，如果有广告拦截检测可以安装ublock插件。） 下载刷机软件和rom： 三星为例： 进入刷机模式，下载三星手机刷机的软件Odin和 tar格式的TWRP，然后用Odin（选择AP）刷进手机。可参考youtube视频。\n卡刷：在https://samfw.com/下载，放入手机存储，双清后安装即可。\n线刷：在https://samfirmtool.com/下载三星手机官方系统下载器SamFirm，然后使用Odin。\nSamFirm使用方法：\n小米为例： 在https://xiaomirom.com/下载刷机工具，下载酷安大神（例如：乌堆小透明）的ROM，或者欧版eu社区版ROM。然后按照此教程操作，安装选择默认即可，开机后卸载重装magisk。\n华为旧机为例： 在https://m.huaweirom.com/rom/找到对应机型的rom，我当时看到网站干净无广告就刷了，是可以用的。Fastboot模式运行run脚本就行了。\nroot github下载magisk放进手机储存卡（有人建议低版安卓用20.4版本），进入TWRP recovery安装，开机后安装magisk manager app即可。\n自动化 工具 识别方式 控件查找：可兼容所有机型，但是不能定位非原生安卓的对象（如 Unity3D 的游戏），或随机变化的控件（如安全键盘）。显然图像识别时必备的\n图像识别：可查找所有显示内容，且难以被检测。但可能有识别慢、识别结果不准确、多分辨率不兼容的问题，不过使用airtest可以缓解\n自动化工具有\nYyds.Auto：使用root深度掌控，内置yolo等ai模型，堪称最强方案，但部分app可能会对root设备监控 airtest：基于图像识别 appium：图像识别需自己实现 EasyClick：支持打包apk，收费 AutoX.js：支持打包apk，图像识别需自己实现 Hamibot：支持打包apk，可以浏览器远程控制 AiBote：办公自动化 Tasker、MacroDroid：单独app即可简单使用，收费 airtest（使用PC） 对于非专业任务，推荐使用airtest，支持自动化测试Android/Windows/iOS，详见官网及官方教程\n算法 Airtest算法介绍\n模板匹配 速度快 无法跨分辨率识别 屏幕没有结果也会匹配出不准确的结果 特征点匹配 跨分辨率识别（可跨设备） 不能识别纯文字、空白截图 技巧 截有特征的小图（多截空白背景图会使准确度下降） 有相同按钮时，把按钮全部截图再定位 基础 mumu模拟器连接示例 文件\u0026ndash;\u0026gt;新建脚本\u0026ndash;\u0026gt;.py纯Python(高级用户) Save Path： 文件保存路径 Log Directory： log保存路径 Devices：使用当前已连接的手机设备进行初始化 Project Root： 项目的父目录 坐标 相对坐标：打开IDE的选项\u0026ndash;\u0026gt;设置\u0026ndash;\u0026gt;Device，勾选实时坐标选项，可以实时显示出鼠标位置的坐标，再勾选相对坐标会显示出相对坐标，点击鼠标右键复制坐标信息 坐标切换 # 获取横屏电脑分辨率 height = G.DEVICE.display_info[\u0026#39;width\u0026#39;] width = G.DEVICE.display_info[\u0026#39;height\u0026#39;] # 已知相对坐标[0.3,0.55]，转换成绝对坐标 x2 = 0.3*width y2 = 0.55*height # 已知绝对坐标[311,1065]，转换成相对坐标 x1 = 311/width y1 = 1065/height 图像识别 touch(Template(r\u0026#34;tpl1598948415043.png\u0026#34;, target_pos=6)) # 参数 filename：截图路径 threshold：可信度，默认0.7 target_pos：点击位置，默认5（图像中心），1（左上角）~9（右下角） rgb：使用彩色识别 局部截图 from airtest.aircv import * screen = G.DEVICE.snapshot() # 局部截图，左上（0,160）右下（1067,551） part_screen = aircv.crop_image(screen,(0,160,1067,551)) # 保存局部截图到log文件夹中 try_log_screen(part_screen) API 点击：touch 滑动：swipe 等待截图出现：wait 存在某个截图：exists 文本输入：text 关键词操作：keyevent 截图：snapshot 等待：sleep 断言：assert_exists、assert_not_exists、assert_equal、assert_not_equal 文字识别 # 建议尝试Poco控件识别，小概率识别不准，就会影响程序运行 # 实际使用中，单纯文字识别准确率尚可，数字/符号识别不准（使用相应匹配规则也不行，需借助另外专业的库） import pytesseract from PIL import Image # 打开图片 image = Image.open(r\u0026#39;D:/test/score0.png\u0026#39;) # 识别 text = pytesseract.image_to_string(image) # 识别中文 text3 = pytesseract.image_to_string(image3,lang=\u0026#39;chi_sim\u0026#39;) # 点击ocr文字 def touch_ocr(target_text): # 已知相对坐标[0.13,0.01][0.27,0.04],局部截图 x1 = 0.13*height y1 = 0.01*width x2 = 0.27*height y2 = 0.04*width part_screen = aircv.crop_image(screen,(x1,y1,x2,y2)) # try_log_screen(part_screen) # 识别 text = pytesseract.image_to_string(part_screen,lang=\u0026#39;chi_sim\u0026#39;) # print(text) if target_text == text: x_center=(x1+x2)//2 y_center=(y1+y2)//2 touch(x_center,y_center) Tasker（使用andriod） 基础 Tasker终身许可$3.49，可app单独使用，需root才顺畅使用，否则锁屏都不能解决\n设置：\n防止系统清理：进入系统最近任务界面，点击应用旁边的小锁，锁定应用不被系统清理 忽略电池优化：依次打开系统设置，应用和通知，应用管理，设置，特殊访问权限，忽略电池优化（直接在设置搜索栏搜索电池也能找到），允许忽略应用 设置启动管理：依次打开系统设置，电池，启动管理，关闭应用自动管理后弹出的对话框中选中：允许自启动，允许关联启动，允许后台活动 权限全部打开 shell shell命令很方便定义操作（点击的坐标可以在手机开发者选项中打开指针位置）。shell命令摘录网站\n#按键事件 input text \u0026lt;string\u0026gt; #输入文本 input keyevent 20 #向下 input keyevent 4 #返回 input keyevent 3 #Home input keyevent 6 #挂机 input keyevent 84 #搜索 input keyevent 26 #电源，息屏 input keyevent 24 #音量+ input keyevent 25 #音量- #模拟点击 input tap 100 100 #滑动 input swipe x1 y1 x2 y2 ms input swipe 100 100 400 100 300 #左往右 input swipe 400 100 100 100 300 #右往左 input swipe 100 100 100 400 300 #上往下 input swipe 100 400 100 100 300 #下往上 input swipe 100 100 400 400 300 #上往下斜 input swipe 400 400 100 100 300 #下往上斜 #长按 input swipe 100 100 100 100 1000 //在 100 100 位置长按 1000毫秒 ","date":"2021-11-24T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/phone-root/","title":"root手机和自动化"},{"content":"本github actions方法已于2022-07-15完全被封，请去仓库看文档 freenom自动续期 Fork luolongfei大佬的freenom库，再添加以下workflow： “点击展开完整代码”\r# 1、Fork 本仓库 # 2、在你 Fork 的本仓库下的 Settings \u0026gt; Secrets 画面追加以下几个 secret 变量： # FREENOM_USERNAME、FREENOM_PASSWORD、MULTIPLE_ACCOUNTS、MAIL_USERNAME、MAIL_PASSWORD、TO、MAIL_ENABLE、TELEGRAM_CHAT_ID、 # TELEGRAM_BOT_TOKEN、TELEGRAM_BOT_ENABLE、NOTICE_FREQ # （注：此处列出了所有可用变量，你只用追加你需要用到的变量，变量的具体含义请参考本项目的 .env 文件中的说明，一般情况下，.env 文件中的某些 # 项存在默认值，如果默认值满足你的需求则可不追加到 Secrets，它们会保持默认） # # 下面定时任务中的时间是世界时间，每天 10:00（本示例已改为2:00） 执行，由于创建虚拟环境会消耗时间，故任务会延迟 30 秒左右执行 # # @Author of yml configuration file: RouRouX \u0026lt;https://github.com/RouRouX\u0026gt; \u0026amp; mybsdc \u0026lt;mybsdc@gmail.com\u0026gt; # ###### end 说明 ###### name: Run it on action on: push: branches: - main schedule: - cron: 00 02 * * * workflow_dispatch: jobs: run-it: runs-on: ubuntu-18.04 name: Run it on action steps: - name: Checkout master uses: actions/checkout@v2 - name: Setup PHP uses: shivammathur/setup-php@v2 with: php-version: \u0026#39;7.2\u0026#39; - name: Setting run: | echo \u0026#39;Renew freenom domain name automatically.\u0026#39; echo \u0026#39;@Author of yml configuration file: RouRouX \u0026lt;https://github.com/RouRouX\u0026gt; \u0026amp; mybsdc \u0026lt;mybsdc@gmail.com\u0026gt;\u0026#39; echo \u0026#39;@Url: https://github.com/luolongfei/freenom\u0026#39; cp .env.example .env if [[ (\u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39; == \u0026#39;\u0026#39; || \u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39; == \u0026#39;\u0026#39;) \u0026amp;\u0026amp; \u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39; == \u0026#39;\u0026#39; ]]; then echo \u0026#39;你在 Github 的当前项目的 Settings \u0026gt; Secrets 画面没有设置任何与账户信息相关的 secret 值，无法正常运行，请添加新的 secret 值，设置 FREENOM_USERNAME 与 FREENOM_PASSWORD，或者设置 MULTIPLE_ACCOUNTS，以及 .env 文件中其它必要项，各项的具体含义与格式参考本项目 .env 文件中的说明。\u0026#39;; fi if [ \u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^FREENOM_USERNAME=.*$/FREENOM_USERNAME=\u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^FREENOM_PASSWORD=.*$/FREENOM_PASSWORD=\u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MULTIPLE_ACCOUNTS=.*$/MULTIPLE_ACCOUNTS=\u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_USERNAME }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_USERNAME=.*$/MAIL_USERNAME=\u0026#39;${{ secrets.MAIL_USERNAME }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_PASSWORD }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_PASSWORD=.*$/MAIL_PASSWORD=\u0026#39;${{ secrets.MAIL_PASSWORD }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TO }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TO=.*$/TO=\u0026#39;${{ secrets.TO }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_ENABLE }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_ENABLE=.*$/MAIL_ENABLE=\u0026#39;${{ secrets.MAIL_ENABLE }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_CHAT_ID }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_CHAT_ID=.*$/TELEGRAM_CHAT_ID=\u0026#39;${{ secrets.TELEGRAM_CHAT_ID }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_BOT_TOKEN }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_BOT_TOKEN=.*$/TELEGRAM_BOT_TOKEN=\u0026#39;${{ secrets.TELEGRAM_BOT_TOKEN }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_BOT_ENABLE }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_BOT_ENABLE=.*$/TELEGRAM_BOT_ENABLE=\u0026#39;${{ secrets.TELEGRAM_BOT_ENABLE }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.NOTICE_FREQ }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^NOTICE_FREQ=.*$/NOTICE_FREQ=\u0026#39;${{ secrets.NOTICE_FREQ }}\u0026#39;/\u0026#34; .env; fi sed -i \u0026#34;s/^ON_GITHUB_ACTIONS=.*$/ON_GITHUB_ACTIONS=true/\u0026#34; .env - name: Run run: | php run # 以下为保活所需step - name: curl id: enable_workflow env: REST_TOKEN: ${{ secrets.REST_TOKEN }} API_ADDRESS: ${{ secrets.API_ADDRESS }} run: | echo \u0026#34;Enable Workflow Start...\u0026#34; curl -X PUT -H \u0026#34;Authorization: token $REST_TOKEN\u0026#34; \u0026#34;$API_ADDRESS\u0026#34; echo \u0026#34;Finished\u0026#34; 在你 Fork 的本仓库下的 Settings -\u0026gt; Secrets 页面追加以下几个secret秘密环境变量\n变量名 含义 默认值 是否必须 备注 FREENOM_USERNAME freenom 账户 - 是 只支持邮箱账户，不支持也不打算支持第三方社交账户登录 FREENOM_PASSWORD freenom 密码 - 是 某些特殊字符可能需要转义，在Github actions环境，请在除字母数字以外的字符前加上“\\”，否则可能无法正确读取密码，此举是防止某些字符在shell命令行被解析，举个例子，比如我密码是fei.,:!~@#$%^\u0026amp;*?233-_abcd^$$，那么写到秘密变量时就应写为fei\\.\\,\\:\\!\\~\\@\\#\\$\\%\\^\\\u0026amp;\\*\\?233\\-\\_abcd\\^\\$\\$。而在普通VPS环境，则只用在密码中的“#”或单双引号前加“\\”，请参考.env.example文件内的注释，应该没人会设置那么变态的密码吧 MULTIPLE_ACCOUNTS 多账户支持 - 否 多个账户和密码的格式必须是“\u0026lt;账户1\u0026gt;@\u0026lt;密码1\u0026gt;|\u0026lt;账户2\u0026gt;@\u0026lt;密码2\u0026gt;|\u0026lt;账户3\u0026gt;@\u0026lt;密码3\u0026gt;”，如果设置了多账户，上面的FREENOM_USERNAME和FREENOM_PASSWORD可不设置 MAIL_USERNAME 机器人邮箱账户 - 是 支持Gmail、QQ邮箱以及163邮箱，尽可能使用163邮箱或者QQ邮箱，而非之前推荐的Gmail。因为谷歌的安全机制，每次在新设备登录 Gmail 都会先被限制，需要手动解除限制才行，而Github Actions每次创建的虚拟环境都会分配一个新的设备IP，相当于每次都是从新设备登录Gmail，而我们不可能每次都去手动为Gmail解除登录限制，所以这种机制会导致无法发出通知邮件。具体的配置方法参考「 配置发信邮箱 」 MAIL_PASSWORD 机器人邮箱密码 - 是 Gmail填密码，QQ邮箱或163邮箱填授权码 TO 接收通知的邮箱 - 是 你自己最常用的邮箱，推荐使用QQ邮箱，用来接收机器人邮箱发出的域名相关邮件 MAIL_ENABLE 是否启用邮件推送功能 true 否 true：启用\nfalse：不启用\n默认启用，如果设为false，不启用邮件推送功能，则上面的MAIL_USERNAME、MAIL_PASSWORD、TO变量变为非必须，可不设置 TELEGRAM_CHAT_ID 你的chat_id - 否 通过发送/start给@userinfobot可以获取自己的id TELEGRAM_BOT_TOKEN 你的Telegram bot的token - 否 TELEGRAM_BOT_ENABLE 是否启用Telegram Bot推送功能 false 否 true：启用\nfalse：不启用\n默认不启用，如果设为true，则必须设置上面的TELEGRAM_CHAT_ID和TELEGRAM_BOT_TOKEN变量 NOTICE_FREQ 通知频率 1 否 0：仅当有续期操作的时候\n1：每次执行 REST_TOKEN 如后文所示 - 否 保活所需 API_ADDRESS 如后文所示 - 否 保活所需 （注：你只用关注上面表格中的必须项，非必须项可不设置，将保持默认值。更多相关变量的含义、格式以及默认值，请参考本项目的.env.example文件内的注释）\n启用 Actions ，完成。 保活 Fork zhzhzhy/Workflow-Keep-Alive库\n创建 sercets ：\n变量名 值 备注 REST_TOKEN 个人访问令牌（Personal access tokens） 个人资料照片-\u0026gt;设置-\u0026gt;Developer settings API_ADDRESS https://api.github.com/repos/{owner}/{target-repo}/actions/workflows/enable_workflow/enable 修改{owner}/{target-repo} 运行 github action。\n相互唤醒，再次在目标 repo 的工作流程中执行上述步骤，并添加所需 step（已在代码中注释）。\n附 github workflow 语法文档\n修改定时任务 —— Cron示例\n","date":"2021-11-19T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/freenom/","title":"freenom自动续期（废弃）"},{"content":"docker 安装docker：\n#更新apt包索引 sudo apt-get update #安装包以允许apt通过 HTTPS 使用存储库 sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release #添加Docker官方的GPG密钥 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg #设置稳定存储库 echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null #安装最新版本的Docker Engine和containerd sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io #hello-world 映像验证 sudo docker run hello-world # 使用脚本安装 curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh Dockerfile “点击展开go语言示例”\r# 这个参考示例来自李文周大佬的bluebell项目 FROM golang:alpine AS builder # 为我们的镜像设置必要的环境变量 ENV GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 # 移动到工作目录：/build WORKDIR /build # 复制项目中的 go.mod 和 go.sum文件并下载依赖信息 COPY go.mod . COPY go.sum . RUN go mod download # 将代码复制到容器中 COPY . . # 将我们的代码编译成二进制可执行文件 bluebell_app RUN go build -o bluebell_app . ################### # 接下来创建一个小镜像 ################### FROM debian:stretch-slim COPY ./wait-for.sh / COPY ./templates /templates COPY ./static /static COPY ./conf /conf # 从builder镜像中把/dist/app 拷贝到当前目录 COPY --from=builder /build/bluebell_app / RUN set -eux; \\ apt-get update; \\ apt-get install -y \\ --no-install-recommends \\ netcat; \\ chmod 755 wait-for.sh # 声明服务端口 EXPOSE 8084 # 需要运行的命令 #ENTRYPOINT [\u0026#34;/bluebell_app\u0026#34;, \u0026#34;conf/config.yaml\u0026#34;] 基础知识参考 以下简介节选自docker文档：\n**卷（volumes）**存储在由 Docker管理的主机文件系统（在 Linux 上的/var/lib/docker/volumes/ ）。卷完全由 Docker 管理，非 Docker 进程不应修改文件系统的这一部分。卷是在 Docker 中持久化数据的最佳方式。 # 将当前目录的相对路径挂载到/app目录中 volumes: - ./:/app docker compose 安装docker compose：\n#单独下载和安装 Compose，不装Docker CLI #下载 Docker Compose 的当前稳定版本 curl -SL https://github.com/docker/compose/releases/download/v2.7.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose #对二进制文件应用可执行权限 sudo chmod +x /usr/local/bin/docker-compose #测试安装 docker compose version # 脚本 curl -fsSL https://get.docker.com -o get-docker.sh \u0026amp;\u0026amp; \\ sudo sh get-docker.sh \u0026amp;\u0026amp; \\ docker -v \u0026amp;\u0026amp; \\ curl -SL https://github.com/docker/compose/releases/download/v2.7.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose \u0026amp;\u0026amp; \\ sudo chmod +x /usr/local/bin/docker-compose \u0026amp;\u0026amp; \\ docker compose version docker-compose.yaml “点击展开和折叠代码”\rversion: \u0026#39;3.7\u0026#39; services: mysql5.7: # 镜像名 image: \u0026#39;mysql:5.7\u0026#39; # 容器名(以后的控制都通过这个) container_name: mysql5.7 # 重启策略 restart: always environment: # 时区上海 TZ: Asia/Shanghai # root 密码 MYSQL_ROOT_PASSWORD: root # 初始化数据库(后续的初始化sql会在这个库执行) MYSQL_DATABASE: nacos_config # 初始化用户(不能是root 会报错, 后续需要给新用户赋予权限) MYSQL_USER: nacos # 用户密码 MYSQL_PASSWORD: nacos # 映射端口 ports: - 3306:3306 volumes: # 数据挂载 #- /root/mysql/data/:/var/lib/mysql/ # 配置挂载 #- /root/mysql/conf/:/etc/mysql/conf.d/ # 初始化目录挂载，注意此处我只跑了这个挂载，只是为了说明其他配置不应该数据初始化 - /root/mysql/init/:/docker-entrypoint-initdb.d/ command: # 将mysql8.0默认密码策略 修改为 原先 策略 (mysql8.0对其默认策略做了更改 会导致密码无法匹配) --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 networks: - proxy server: image: ghcr.io/USERNAME/server:master container_name: server ports: - 8082:8082 expose: - \u0026#34;8082\u0026#34; depends_on: - mysql5.7 restart: always volumes: - \u0026#39;./data:/data/\u0026#39; networks: - proxy web: image: ghcr.io/USERNAME/web:master container_name: web depends_on: - server restart: always ports: - 3000:3000 expose: - \u0026#34;3000\u0026#34; environment: - VIRTUAL_HOST=example.com - VIRTUAL_PORT=3000 - LETSENCRYPT_HOST=example.com - LETSENCRYPT_EMAIL=mail@example.com networks: - proxy networks: proxy: name: nginx-proxy external: true “点击展开nginx-proxy代码”\rversion: \u0026#39;3\u0026#39; services: nginx-proxy: image: jwilder/nginx-proxy container_name: nginx-proxy ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; volumes: - conf:/etc/nginx/conf.d - vhost:/etc/nginx/vhost.d - html:/usr/share/nginx/html - dhparam:/etc/nginx/dhparam - certs:/etc/nginx/certs:ro - /var/run/docker.sock:/tmp/docker.sock:ro restart: always networks: - nginxproxy labels: - \u0026#34;com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy\u0026#34; letsencrypt: image: jrcs/letsencrypt-nginx-proxy-companion container_name: nginx-proxy-le depends_on: - nginx-proxy volumes: - vhost:/etc/nginx/vhost.d - html:/usr/share/nginx/html - dhparam:/etc/nginx/dhparam:ro - certs:/etc/nginx/certs - acme:/etc/acme.sh - /var/run/docker.sock:/var/run/docker.sock:ro ################## # 由于LETSENCRYPT证书速率限制，可使用ZeroSSL # 注释掉web服务environment中的： - LETSENCRYPT_HOST=example.com - LETSENCRYPT_EMAIL=mail@example.com # 需添加如下environment environment: - ACME_CA_URI=https://acme.zerossl.com/v2/DV90 - ZEROSSL_API_KEY= ################## restart: always networks: - nginxproxy volumes: conf: vhost: html: dhparam: certs: acme: networks: nginxproxy: name: nginx-proxy external: true 基础知识参考 以下简介节选自docker compose文档：\nCompose 中的网络: Compose默认为您的应用程序设置单个网络。服务中的每个容器都加入默认网络。例如，假设您的应用程序是在一个名为myapp的目录，运行docker-compose up时会创建一个名为myapp_default的网络，服务中使用web和db的配置创建的容器会以web和db的名字加入myapp_default。\n但是，当你使用external（外部网络，例如你有2个或多个docker-compose.yml）时，Compose不会创建默认网络，你必须使用docker network create Your_Nerwork预先创建网络。\n注意：文档中示例写法错误，会报错\nnetworks: proxy: external: name: nginx-proxy 应写为:\nnetworks: proxy: name: nginx-proxy external: true 常用命令 Docker命令 docker run [可选参数] imagename #新建并启动容器 --name = \u0026#34;name\u0026#34; 容器取名 -it 交互模式进入容器 -d 后台启动容器 注意：一般后台启动要有前台的应用，否则很可能被守护程序杀掉 -p ip:主机端口:容器端口 #指定端口映射 -v或--volume /卷名称的路径:/容器中的挂载路径 查看： docker search xxx #搜索dockerhub-镜像 docker images [-a][-q] #列出本地主机的-镜像 -a 显示所有信息 -q 显示所有id docker ps [-a][-q] #显示当前正在运行的容器 -a 显示当前运行的容器，并显示历史运行过的容器 -q 只显示运行容器的编号 docker logs 容器id #日志 docker top 容器id #查看容器中进程信息 docker inspect 容器id #查看容器的详细信息 操作： docker build -t tag . #构建标签为tag的镜像 docker pull 镜像：版本号 #拉取-镜像 docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止容器 docker kill 容器id #强制停止容器 docker rm 容器id #删除停止状态的容器 docker rm -f 容器id #强制删除容器 docker rmi -f xxx #删除单个-镜像 docker rmi -f $(docker images -aq) #删除所有-镜像 docker stop $(docker ps -a -q) #停止所有容器运行 docker rm $(docker ps -a -q) #删除所有容器 docker network rm $(docker network ls -q) #删除所有network docker system prune --all --force --volumes #删除一切 exit 容器停止并退出 ctrl+p+q 容器不停止退出 docker exec -it mysql /bin/bash #进入正在执行的mysql容器 docker exec -it 容器名 /bin/sh #进入容器 docker exec -it 容器名 -c \u0026#34;apt-get update \u0026amp;\u0026amp; apt-get install -y vim\u0026#34; #进入容器安装vim编辑器 docker exec -it 容器名 -c \u0026#34; apk add --update vim\u0026#34; #进入alpine容器安装vim编辑器 docker inspect -f \u0026#39;{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}\u0026#39; [container_name_or_id] #查看容器ip 从容器拷贝内容到主机： docker cp 容器id: 路径 主机目的路径 #此处不必进入容器，容器可以是关闭的。 Docker-compose命令 docker-compose up -d # 在后台启动服务 docker-compose pull # 拉取 docker-compose -f docker-compose.yml up -d # 指定docker-compose.yml docker-compose -f docker-compose.yml pull # 指定docker-compose.yml，后同 查看： docker-compose ps # 查看正在运行中的容器 docker-compose ps -a # 查看所有编排容器，包括已停止的容器 docker-compose images # 列出Compose文件构建的镜像 docker-compose logs # 查看日志 docker-compose logs [serviceName] # 查看某服务的日志 docker-compose logs -f [serviceName] # 查看某服务的实时日志 操作： docker-compose stop # 停止服务 docker-compose start # 启动已经存在的服务 docker-compose pause [serviceName] # 暂停服务 docker-compose unpause [serviceName] # 恢复服务 docker-compose restart [serviceName] # 重启服务 docker-compose rm # 删除所有（停止状态的）服务容器 docker-compose down # 删除所有容器 docker-compose down --remove-orphans # 删除orphans容器 docker-compose config -q # 验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容 docker-compose exec --index=1 [serviceName] sh # 进入某服务的第1个容器执行命令 docker-compose --help # 帮助 actions自动化部署前后端分离项目 参考文章\n本文使用github actions + docker compose部署到github container registry（这适用于中小型项目） 附：容器注册平台对比\n准备好你的dockerfile\n使用github actions “点击展开示例actions”\ron: push: branches: - master workflow_dispatch: env: REGISTRY: ghcr.io IMAGE_NAME: ${{ github.repository }} jobs: build-and-push-image: runs-on: ubuntu-latest permissions: contents: read packages: write strategy: matrix: node: [ \u0026#39;14\u0026#39; ] steps: - name: Checkout repository uses: actions/checkout@v2 - name: Setup node uses: actions/setup-node@v2 with: node-version: ${{ matrix.node }} - name: npm install run: | cd web #进入前端dockerfile目录 npm install - name: Set up QEMU uses: docker/setup-qemu-action@v1 - uses: docker/setup-buildx-action@v1 id: builder1 - uses: docker/setup-buildx-action@v1 id: builder2 - name: Log in to the Container registry uses: docker/login-action@v1 with: registry: ${{ env.REGISTRY }} username: ${{ github.actor }} password: ${{ secrets.GITHUB_TOKEN }} # 用于消毒标签，tag是此动作的重要功能之一，本示例没使用，请见文档 - name: Extract metadata (tags, labels) for Docker id: meta1 uses: docker/metadata-action@v3 with: images: ghcr.io/username/server # images地址 - name: Extract metadata (tags, labels) for Docker id: meta2 uses: docker/metadata-action@v3 with: images: ghcr.io/username/web # images地址 - name: Build and push Docker image 1 uses: docker/build-push-action@v2 with: builder: ${{ steps.builder1.outputs.name }} context: ./server # 服务端dockerfile目录 file: ./server/Dockerfile # 服务端dockerfile push: true tags: ${{ steps.meta1.outputs.tags }} labels: ${{ steps.meta1.outputs.labels }} cache-from: type=gha cache-to: type=gha,mode=max - name: Build and push Docker image 2 uses: docker/build-push-action@v2 with: builder: ${{ steps.builder2.outputs.name }} context: ./web # 前端dockerfile目录 file: ./web/Dockerfile # 前端dockerfile push: true tags: ${{ steps.meta2.outputs.tags }} labels: ${{ steps.meta2.outputs.labels }} cache-from: type=gha cache-to: type=gha,mode=max deploy: runs-on: ubuntu-latest needs: build-and-push-image steps: - uses: appleboy/ssh-action@master with: host: ${{ secrets.host }} #仓库设置中添加Secrets：HOST username: root password: ${{ secrets.PASSWORD }} #仓库设置中添加Secrets：PASSWORD port: 22 script: | echo $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin # 用户名 docker-compose -f docker-compose-nginx.yaml -f docker-compose-app.yaml pull # docker-compose名 docker-compose -f docker-compose-nginx.yaml -f docker-compose-app.yaml up -d # docker-compose名 # 此actions许多参数由github自动提供，无需添加，需修改的均已注释 在服务器上完成向 Container registry 验证\n具体操作：打开/etc/profile\nexport CR_PAT=YOUR_TOKEN source /etc/profile echo $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin 新建docker-compose-app.yaml和代理容器docker-compose-nginx.yaml,示例文档。如有不懂，请多看几遍acme-companion和示例文档。最后，Issues中的实例可能会有帮助。 ","date":"2021-10-27T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/docker-compose/","title":"docker和docker-compose"},{"content":"git git命令 官网git备忘表\nsubmodule\ngit submodule add [git@github.com:xxx/submodule.git] [directory] # 添加子模块 git clone [git@github.com:xxx/submodule.git] [directory] --recurse-submodules # 克隆一个存储库,并自动更新仓库中所有子模块（更新可能不兼容，慎用） git submodule update # 更新 问题\n更新被拒绝，因为远程仓库包含您本地尚不存在的提交。 git push -u origin +master # 强制push gitmodules错误 删掉.git和.gitmodules重新初始化更容易。\npush脚本 #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master 公开仓库fork为私有仓库 fork一个公开仓库 使用github导入功能，写fork仓库的地址，并创建私有仓库 本地操作 git clone git@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git # 克隆到本地 git remote add upstream git@github.com:\u0026lt;original_owner\u0026gt;/\u0026lt;original_repo\u0026gt;.git # 添加上游(源)仓库用于更新 git remote set-url --push upstream DISABLE # 禁用推送到上游(源)仓库 如果上游(源)仓库有更新\ngit fetch upstream # 获取主分支的最新修改到本地 git merge upstream/master # 将upstream分支修改内容合并到本地master git remote -v可以看到： origin\tgit@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git (fetch) origin\tgit@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git (push) upstream\tgit@github.com:\u0026lt;original_owner\u0026gt;/\u0026lt;original_repo\u0026gt;.git (fetch) upstream\tDISABLE (push) 拉取更新 git fetch upstream git merge upstream/master Linux 文件 i 键可以对文件进行修改， Esc + :+ wq 退出并保存修改之后的文件\nsudo gedit ~/File //编辑 touch File //新建文件 mkdir -p Folder/a/src //新建文件夹 sudo rm -r Folder //删除文件夹 安装包 apt sudo apt update \u0026amp;\u0026amp; apt upgrade //更新 dpkg --list //显示所有软件 sudo apt-get install 包名 //安装 sudo apt-get remove 包名 //卸载不删除配置文件 sudo apt-get --purge remove 包名 //软件及其配置文件一并删除 snap sudo snap list //列出已经安装的snap包 sudo snap install \u0026lt;snap name\u0026gt; //安装一个snap包 sudo snap refresh \u0026lt;snap name\u0026gt; //更新一个snap包，如果后面不加包的名字更新所有的snap包 sudo snap remove \u0026lt;snap name\u0026gt; //删除一个snap包 端口 sudo apt-get install lsof //安装lsof lsof -i:80 //查看80端口 kill -9 pid //强制杀进程 命令 local #用于声明局部变量 source systemctl stop service # 停止一个服务 systemctl daemon-reload # 重载所有修改过的配置文件 systemctl enable #将服务设置为每次开机启动 set -eux #用于脚本开头设置 #-e 若指令传回值不等于0，则立即退出shell。0表示没有错误 #-u 当执行时使用到未定义过的变量，则显示错误信息。 #-x 执行指令后，会先显示该指令及所下的参数。 grep 、sed、awk grep 、sed、awk被称为linux中的\u0026quot;三剑客\u0026quot;。\ngrep 更适合单纯的查找或匹配文本 sed 更适合编辑匹配到的文本 awk 更适合格式化文本，对文本进行较复杂格式处理 sed sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为\u0026quot;pattern space\u0026quot;，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。\n语法 sed [option] \u0026#39;command\u0026#39; fileName 选项\n-n 使用安静silent模式。在一般sed的用法中，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来\n-e 直接在指令列模式上进行 sed 的动作编辑\n-f 直接将 sed 的动作写在一个文件内，-f filename则可以执行filename内的sed命令\n-r 让sed命令支持扩展的正则表达式(默认是基础正则表达式)\n-i 直接修改读取的文件内容，而不是由屏幕输出\n命令\na\\：追加行，a\\的后面跟上字符串s(多行字符串可以用\\n分隔)，则会在当前选择的行的后面都加上字符串s\nc\\：替换行，c\\后面跟上字符串s(多行字符串可以用\\n分隔)，则会将当前选中的行替换成字符串s\ni\\：插入行，i\\后面跟上字符串s(多行字符串可以用\\n分隔)，则会在当前选中的行的前面都插入字符串s\nd：删除行delete，该命令会将当前选中的行删除\np：打印print，该命令会打印当前选择的行到屏幕上\ny：替换字符，通常y命令的用法是这样的：y/Source-chars/Dest-chars/，分割字符/可以用任意单字符代替，用Dest-chars中对应位置的字符替换掉Soutce-chars中对应位置的字符\ns：替换字符串，通常s命令的用法是这样的：1,$s/Regexp/Replacement/Flags，分隔字符/可以用其他任意单字符代替，用Replacement替换掉匹配字符串\n替换选项\n\\digit：Replacement中可含有后向引用中的\\digit(digit是1至9)，引用前面定义的子表达\n\u0026amp;：代表模版空间中的整个匹配部分\n\\L：将在其后的替换部分转换成小写字母，直到发现一个\\U或\\E，GNU扩展功能\n\\l：将下一个字符转换成小写字母，GNU扩展功能\n\\U：将在其后的替换部分转换成大写字母，直到发现一个\\L或\\E，GNU扩展功能\n\\u：将下一个字符转换成大写字母，GNU扩展功能\n\\E：停止由\\L或\\U指示开始的大小写转换，GNU扩展功能\n标志选项\ng：将用Replacement替换模版空间中所有匹配Regexp的部分，则不仅仅是第一个匹配部分\ndigit：只用Replacement替换模版空间中第digit(digit是1至9)个匹配Regexp的部分\np：若发生了替换操作，指示显示模版空间中新的数据\nw file-name：若发生了替换操作，指示将模版空间中新的数据写入指定的文件file-name中\ni：表示进行Regexp匹配时，是不区分大小写字母的\n示例 a命令 sed '1,$a\\add one' test.txt 从第一行到最后一行所有行后追加\u0026quot;add one\u0026quot;字符串行\nsed '/first/a\\add one' test.txt 在匹配到first行追加\u0026quot;add one\u0026quot;字符串行\ni命令 与a命令类似，只不过在匹配的行前面插入字符串行，不举例了。\nc命令 sed '1,$c\\add one' test.txt 从第一行到最后一行所有行替换为\u0026quot;add one\u0026quot;字符串行\nsed '/first/c\\add one' test.txt 将匹配到first行替换为\u0026quot;add one\u0026quot;字符串行\nd命令 sed '4,$d' test.txt 从第四行到最后一行全部删除\np命令 sed -n '/^first.*end$/p' test.txt 以first开头end结尾的所有行全部打印\ns命令 sed 's/line/text/g' test.txt 将所有行的line替换为text，g代表全局选项，没有g只替换所有行的第一个匹配项\nsed '/^first.*end$/s/line/text/g' test.txt 匹配以first开头end结尾的所有行，然后将line全部替换为text\nsed 's/\\(.*\\)line$/\\1/g' test.txt 本例中的\\(\\)中包裹的内容表示正则表达式的第n部分，.*表示任意字符串，所以此例相当于删除所有行末的line\n脚本语言备忘录 shell 原文地址\nname=\u0026#34;MyName\u0026#34; //定义变量 echo $name 或 echo ${name} //使用变量 val=`expr 2 + 2` #expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 echo \u0026#34;Total value : $val\u0026#34; 2\u0026gt;\u0026amp;1 把\u0026#34;标准错误输出\u0026#34;重定向到\u0026#34;标准输出\u0026#34; 特殊变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2 $# 传递给脚本或函数的参数个数总和 $* 传递给脚本或函数的所有参数，当被双引号 \u0026quot; \u0026quot; 包含时，所有的位置参数被看做一个字符串 $@ 传递给脚本或函数的所有参数，当被双引号 \u0026quot; \u0026quot; 包含时，每个位置参数被看做独立的字符串 $? 上个命令的退出状态，或函数的返回值 $$ 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。 测试符 描述 -eq，equal 等于 -ne，not equal 不等于 -gt，greater than 大于 -lt，lesser than 小于 -ge，greater or equal 大于或等于 -le，lesser or equal 小于或等于 -z 检测字符串长度是否为 0，为 0 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 待续\npython os 函数名 使用方法 getcwd() 返回当前工作目录 chdir(path) 改变工作目录 listdir(path=\u0026rsquo;.') 列举指定目录中的文件名（\u0026rsquo;.\u0026lsquo;表示当前目录，\u0026rsquo;..\u0026lsquo;表示上一级目录） mkdir(path) 创建单层目录，如该目录已存在抛出异常 makedirs(path) 递归创建多层目录，如该目录已存在抛出异常，注意：\u0026lsquo;E:\\a\\b\u0026rsquo;和\u0026rsquo;E:\\a\\c\u0026rsquo;并不会冲突 remove(path) 删除文件 rmdir(path) 删除单层目录，如该目录非空则抛出异常 removedirs(path) 递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常 rename(old, new) 将文件old重命名为new system(command) 运行系统的shell命令 walk(top) 遍历top路径以下所有的子目录，返回一个三元组：(路径, [包含目录], [包含文件])【具体实现方案请看：第30讲课后作业^_^】 以下是支持路径操作中常用到的一些定义，支持所有平台 os.curdir 指代当前目录（\u0026rsquo;.\u0026rsquo;） os.pardir 指代上一级目录（\u0026rsquo;..\u0026rsquo;） os.sep 输出操作系统特定的路径分隔符（Win下为\u0026rsquo;\\\u0026rsquo;，Linux下为\u0026rsquo;/\u0026rsquo;） os.linesep 当前平台使用的行终止符（Win下为\u0026rsquo;\\r\\n\u0026rsquo;，Linux下为\u0026rsquo;\\n\u0026rsquo;） os.name 指代当前使用的操作系统（包括：\u0026lsquo;posix\u0026rsquo;, \u0026rsquo;nt\u0026rsquo;, \u0026lsquo;mac\u0026rsquo;, \u0026lsquo;os2\u0026rsquo;, \u0026lsquo;ce\u0026rsquo;, \u0026lsquo;java\u0026rsquo;） os.path 函数名 使用方法 basename(path) 去掉目录路径，单独返回文件名 dirname(path) 去掉文件名，单独返回目录路径 join(path1[, path2[, \u0026hellip;]]) 将path1, path2各部分组合成一个路径名 split(path) 分割文件名与路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在 splitext(path) 分离文件名与扩展名，返回(f_name, f_extension)元组 getsize(file) 返回指定文件的尺寸，单位是字节 getatime(file) 返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getctime(file) 返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getmtime(file) 返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） 以下为函数返回 True 或 False exists(path) 判断指定路径（目录或文件）是否存在 isabs(path) 判断指定路径是否为绝对路径 isdir(path) 判断指定路径是否存在且是一个目录 isfile(path) 判断指定路径是否存在且是一个文件 islink(path) 判断指定路径是否存在且是一个符号链接 ismount(path) 判断指定路径是否存在且是一个挂载点 samefile(path1, paht2) 判断path1和path2两个路径是否指向同一个文件 BeautifulSoup from bs4 import BeautifulSoup html_doc = \u0026#34;\u0026#34;\u0026#34; \u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;story\u0026#34;\u0026gt;Once upon a time there were three little sisters; and their names were \u0026lt;a href=\u0026#34;http://example.com/elsie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026#34;http://example.com/lacie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Lacie\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026#34;http://example.com/tillie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link3\u0026#34;\u0026gt;Tillie\u0026lt;/a\u0026gt;; and they lived at the bottom of a well.\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;story\u0026#34;\u0026gt;...\u0026lt;/p\u0026gt; \u0026#34;\u0026#34;\u0026#34; # 解析html_doc soup = BeautifulSoup(html_doc, \u0026#39;html.parser\u0026#39;) # 按照标准的缩进格式的结构输出 print(soup.prettify()) # 选择元素 soup.title # \u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt; # 提取节点信息 soup.title.name # u\u0026#39;title\u0026#39; # 获取属性 soup.p.attrs # {\u0026#39;class\u0026#39;: [\u0026#39;title\u0026#39;], \u0026#39;name\u0026#39;: \u0026#39;Dormouse\u0026#39;} soup.p.attrs[\u0026#39;name\u0026#39;] # Dormouse # 获取文本内容 soup.title.get_text() soup.title.string # u\u0026#39;The Dormouse\u0026#39;s story\u0026#39; # 获取第一个P标签下的所有的子节点，children是迭代器，所以用list转换 list(soup.p.children) list(soup.p.children)[0].text # 获取前面和后面的兄弟节点，迭代器类型 list(soup.a.next_siblings) list(soup.a.previous_siblings) # 找到标签 soup.find(\u0026#39;title\u0026#39;) # \u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt; # 找到所有\u0026lt;a\u0026gt;标签的链接 for link in soup.find_all(\u0026#39;a\u0026#39;): print(link.get(\u0026#39;href\u0026#39;)) # CSS选择器 html_doc = \u0026#34;\u0026#34;\u0026#34; \u0026lt;div class=\u0026#34;panel\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;panel-heading\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;Hello World\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;panel-body\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;list\u0026#34; id=\u0026#34;list-1\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Foo\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Bar\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Jay\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;list list-samll\u0026#34; id=\u0026#34;list-2\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Foo\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Bar\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Jay\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026#34;\u0026#34;\u0026#34; print(soup.select(\u0026#39;.panel-heading\u0026#39;)) # 获取class为panel-heading的节点 print(soup.select(\u0026#39;ul li\u0026#39;)) # 获取ul下的li节点 print(soup.select(\u0026#39;#list-2 li\u0026#39;)) # 获取id为list-2下的li节点 print(soup.select(\u0026#39;ul\u0026#39;)) # 获取所有的ul节点 正则表达式 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n\u0026lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“`(. (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`( (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95 (?\u0026lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?\u0026lt;=95 (?\u0026lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?\u0026lt;!95 x|y 匹配x或y。例如，“`z [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \\d 匹配一个数字字符。等价于[0-9]。 \\D 匹配一个非数字字符。等价于[^0-9]。 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04\u0026amp;1”。正则表达式中可以使用ASCII编码。. *num* 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。 *n* 标识一个八进制转义值或一个向后引用。如果*n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n*为一个八进制转义值。 *nm* 标识一个八进制转义值或一个向后引用。如果*nm之前至少有nm个获得子表达式，则nm为向后引用。如果*nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则*nm将匹配八进制转义值nm*。 *nml* 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 一、校验数字的表达式 1. 数字：^[0-9]*$ 2. n位的数字：^\\d{n}$ 3. 至少n位的数字：^\\d{n,}$ 4. m-n位的数字：^\\d{m,n}$ 5. 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 10. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 12. 非零的负整数：^\\-[1-9][]0-9″*$ 或 ^-[1-9]\\d*$ 13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1. 汉字：^[\\u4e00-\\u9fa5]{0,}$ 2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3. 长度为3-20的所有字符：^.{3,20}$ 4. 由26个英文字母组成的字符串：^[A-Za-z]+$ 5. 由26个大写英文字母组成的字符串：^[A-Z]+$ 6. 由26个小写英文字母组成的字符串：^[a-z]+$ 7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20} 9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 11. 可以输入含有^%\u0026amp;’,;=?$\\”等字符：[^%\u0026amp;’,;=?$\\x22]+ 12. 禁止输入含有~的字符[^~\\x22]+ 其它： .*匹配除 \\n 以外的任何字符。 /[\\u4E00-\\u9FA5]/ 汉字 /[\\uFF00-\\uFFFF]/ 全角符号 /[\\u0000-\\u00FF]/ 半角符号 三、特殊需求表达式 1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%\u0026amp;=]*)?$ 4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 5. 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6. 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7. 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 12. 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 1.有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0″不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了+可以用*替代,如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\n1. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 2. 中文字符的正则表达式：[\\u4e00-\\u9fa5] 3. 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 4. 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 5. HTML标记的正则表达式：\u0026lt;(\\S*?)[^\u0026gt;]*\u0026gt;.*?\u0026lt;/\\1\u0026gt;|\u0026lt;.*? /\u0026gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 6. 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 7. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 8. 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 9. IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) 10. IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 11. IP-v4地址：\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b (提取IP地址时有用) 12. 校验IP-v6地址:(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 13. 子网掩码：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 14. 校验日期:^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。) 15. 抽取注释：\u0026lt;!–(.*?)–\u0026gt; 16. 查找CSS属性:^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 17. 提取页面超链接:(\u0026lt;a\\\\s*(?!.*\\\\brel=)[^\u0026gt;]*)(href=”https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?’.implode(‘|(?:www\\\\.)?’, $follow_list).’))[^” rel=”external nofollow” ]+)”((?!.*\\\\brel=)[^\u0026gt;]*)(?:[^\u0026gt;]*)\u0026gt; 18. 提取网页图片:\\\\\u0026lt; *[img][^\\\\\\\\\u0026gt;]*[src] *= *[\\\\”\\\\’]{0,1}([^\\\\”\\\\’\\\\ \u0026gt;]*) 19. 提取网页颜色代码:^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 20. 文件扩展名效验:^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?”\u0026lt;\u0026gt;|]+\\\\.txt(l)?$ 21. 判断IE版本：^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ ","date":"2021-07-22T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/command/","title":"常用命令"},{"content":"部分电脑配置记录 架构 windows-386 ：这些是针对 32 位 Windows 系统编译的 windows-amd64 ：这些是针对具有 AMD 或 Intel x86-64 架构的 64 位 Windows 系统编译的 windows-arm64 ：这些是针对具有 ARM 架构的 64 位 Windows 系统编译的\nwin10 config git git config --global http.proxy http://127.0.0.1:[port.http] git config --global https.proxy https://127.0.0.1:[port.http] 文件路径：C:\\Users\\[Username]\\.gitconfig\nTerminal（临时使用） set http_proxy=http://127.0.0.1:[port.http] #临时命令行代理 set https_proxy=http://127.0.0.1:[port.http] #临时命令行代理 VM Ubuntu config 代理 Windows中使用ipconfig查看WLAN 2的ip地址，ubuntu中进入“设置”-“网络”-“proxy”，在Socks Host里写入查到的ip地址\ngit config 默认保存在用户的主目录下的 .gitconfig 文件内 git config --global user.name \u0026#34;John Doe\u0026#34; #配置github账号用户名 git config --global user.email johndoe@example.com #配置邮箱 git ssh 代理 创建~/.ssh/config 文件：\nHost github.com User git ProxyCommand nc -v -x ip:port.socks %h %p #写自己ip 终端代理（临时使用）\n方法一：直接在命令前加proxychains\n方法二：在.bashrc最后加入：\nexport http_proxy=\u0026#34;http://ip:port.http\u0026#34; #写自己ip export https_proxy=\u0026#34;http://ip:port.http\u0026#34; #写自己ip source ~/.bashrc #使配置生效 VM Ubuntu升级 # 更新 sudo apt update sudo apt upgrade sudo reboot # 启动 GUI 更新向导 sudo update-manager -c update错误 N: 无法安全地用该源进行更新，所以默认禁用该源 cd /etc/apt/sources.list.d sudo rm -f * # 删除全部软件源 W: Failed to fetch http://archive.ubuntu.com/ 备份您的来源列表 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup\n打开/etc/apt/sources.list粘贴这里对应地区和版本的sources.list条目\n# DNS 设置 sudo vim /etc/resolv.conf # 使用Google DNS作为首选 DNS 服务器 nameserver 8.8.8.8 nameserver 8.8.4.4 VM Ubuntu克隆 1. 概念\n虚拟机克隆 完整克隆 是和原始虚拟机完全独立的一个备份，可以脱离原始虚拟机独立使用 链接克隆 需要和原始虚拟机共享同一虚拟磁盘文件，不能脱离原始虚拟机独立运行 虚拟机模板克隆 克隆虚拟机固然是快速部署虚拟机的利器，但是所有的虚拟机都可以克隆，被克隆的虚拟机也可以再次被克隆，长此以往系统就会崩毁，从而给管理员带来诸多的麻烦。模板就是解决此问题的最好的方法，即将一台经常发起克隆的虚拟机做成虚拟机模板，每次需要克隆类似的虚拟机时都通过模板发起 虚拟快照 快照是针对虚拟机的VMDK文件在某一时间点的\u0026quot;备份\u0026quot;，快照任务启动时，将冻结虚拟机源VMDK文件处于只读状态，同时创建出1个快照文件，今后所有修改的数据都会写入这个快照文件。一旦触发快照恢复操作。系统将放弃文件的内容，回滚到源VMDK文件的状态，实现快照恢复 2. 模板克隆过程\n关机 -\u0026gt; 创建快照 -\u0026gt; 虚拟机、设置、高级、启用模板模式 -\u0026gt; 右键虚拟机克隆 -\u0026gt; 从快照克隆 -\u0026gt; 完整克隆\n3. 解决IP相同问题\n在虚拟机的网络设置 -\u0026gt; 高级 -\u0026gt; 点击生成新的mac地址\ncd /etc/netplan sudo gedit 01-network-manager-all.yaml # 添加内容 network: ethernets: ens33: dhcp4: true # 动态ip开启 dhcp-identifier: mac # 将DHCP获取IP地址的标识改为mac version: 2 # 更新配置 sudo netplan apply Ubuntu安装go sudo apt install snap #安装snap，使用snap更易安装、更新 sudo snap install go --classic #安装go sudo vim /etc/profile #编辑profile export GOROOT=/snap/go #在最后一行添加 export PATH=$PATH:$GOROOT/bin source /etc/profile #保存 go version #验证 export GO111MODULE=on export GOPROXY=https://goproxy.cn #设置 go get 为国内源（无代理） IDEA 使用 教程1\n教程2\n不能输入中文（Ubuntu） 在idea.sh注释之后的首行添加\nexport XMODIFIERS=\u0026#34;@im=ibus\u0026#34; export GTK_IM_MODULE=\u0026#34;ibus\u0026#34; export QT_IM_MODULE=\u0026#34;ibus\u0026#34; goland.vmoptions添加-Drecreate.x11.input.method=true\nWin10 系统问题 文件夹分类管理 在要分类的文件夹下新建desktop.txt文件 [.ShellClassInfo] InfoTip=分类名称 另存为desktop.ini，保存类型：所有文件，编码：ANSI\n生效：文件夹属性 -\u0026gt; 自定义 -\u0026gt; 更改图标 -\u0026gt; 还原默认值\n文件夹查看 -\u0026gt; 分组依据 -\u0026gt; 选择备注\n修改删除：文件夹查看 -\u0026gt; 选项 -\u0026gt; 查看 -\u0026gt; 取消选中\u0026quot;隐藏受保护的操作系统文件（推荐）\u0026ldquo;可以看到ini文件\n文件删不掉 TASKKILL /IM explorer* /F # 关掉任务栏 explorer.exe # 开启任务栏 管理员权限 方法一： cmd -\u0026gt; 输入 gpedit.msc 方法二： 添加右键超级管理员权限，新建1.reg文件并运行\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell\\runas] @=\u0026#34;获取超级管理员所有权限\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Windows\\\\System32\\\\imageres.dll,101\u0026#34; \u0026#34;NoWorkingDirectory\u0026#34;=\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\*\\shell\\runas\\command] @=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F\u0026#34; \u0026#34;IsolatedCommand\u0026#34;=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F\u0026#34; [HKEY_CLASSES_ROOT\\exefile\\shell\\runas2] @=\u0026#34;获取超级管理员所有权限\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Windows\\\\System32\\\\imageres.dll,101\u0026#34; \u0026#34;NoWorkingDirectory\u0026#34;=\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\exefile\\shell\\runas2\\command] @=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F\u0026#34; \u0026#34;IsolatedCommand\u0026#34;=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\runas] @=\u0026#34;获取超级管理员所有权限\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Windows\\\\System32\\\\imageres.dll,101\u0026#34; \u0026#34;NoWorkingDirectory\u0026#34;=\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command] @=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; /r /d y \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F /t\u0026#34; \u0026#34;IsolatedCommand\u0026#34;=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; /r /d y \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F /t\u0026#34; 关闭安全通知 关闭Win10防火墙通知 控制面板 -\u0026gt; 安全与维护 -\u0026gt; 更改用户账户控制设置 -\u0026gt; 从不通知\n搜索\u0026quot;编辑组策略\u0026rdquo; -\u0026gt; 管理模板 -\u0026gt; windows组件 -\u0026gt; windows安全中心 -\u0026gt; 通知 -\u0026gt; 打开隐藏所有通知 -\u0026gt; 已启用\n从注册表彻底关闭 Windows安全中心 win+R输入regedit，定位到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SecurityHealthService，找到Start，修改数值数据3为4。\n关闭\u0026quot;打开文件-安全警告\u0026quot;弹框 控制面板-\u0026gt; internet选项 -\u0026gt; 安全 -\u0026gt; 自定义级别 -\u0026gt; 启用(不安全)\nWin10 资源管理器无限重启闪屏 安全模式开机\n长按开机键3次，选择【疑难解答】-【高级选项】-【启动设置】- 【重启】，在启动设置内， 按 4 或 F4 就可以进入安全模式了。\n更换本地账户、新建本地账户。\n开机后右键windows图标点击 powershell（管理员）\n在命令提示符(管理员)中复制粘贴输入以下指令：\nnet user User ****** /add (User是新建账户，******是新建的随机密码)　net localgroup administrators User /add (赋予该账号管理员权限)\n重启后按电源键息屏，再开启后可以切换到User账户，进去后一切正常，表示故障原因不在硬件和系统方面，肯定是第三方软件。\n新建文本粘贴以下代码\nWindows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\\LocalDumps\\explorer.exe] \u0026#34;DumpFolder\u0026#34;=hex(2):43,00,3a,00,5c,00,43,00,72,00,61,00,73,00,68,00,44,00,75,\\ 00,6d,00,70,00,73,00,00,00 重命名为1.reg，运行后会在C盘建立CrashDumps文件夹（路径C:\\CrashDumps），当系统闪屏后里面有后缀.dmp文件，把这个文件拖到Visual Studio里打开，可以排查相关的第三方软件的路径，挨个卸载。我放在vs里显示我IDM下载程序缺少二进制文件，卸载后完美进入系统。\n自用软件 win10优雅必备 Wallpaper Engine　# 壁纸，steam购买\nEverything + uTools　# 文件快捷搜索及工具\nquicker　# 鼠标便捷操作神器\nDeskGo　# 腾讯出品的桌面软件格子\nIDM　# 下载\nPowerShell：irm https://massgrave.dev/ias | iex Geek Uninstaller　# 卸载无残留\nclover　# 资源管理器多标签页\n火绒　# 屏蔽弹窗\nwin10 microsoft store工具\nWindows Terminal　#命令行 TranslucentTB　#任务栏透明 EarTrumpet　#音频管理 开发者实用工具\ntypora　# markdown记事本 joplin　# markdown多端同步 sourcetree　# Git 界面 DBeaver　# 连接数据库 Postman　# 接口测试 素材工具\nGIMP　# 图像处理 例：转换pdf，文件-\u0026gt;打开，导入分辨率填300,文件-\u0026gt;导出 Pr　# 视频剪辑 Ae　# 动画特效 Ps　# 图片处理 Ai　# 插图 安卓app 浏览器：Chrome、Edge\n影视：\n论坛：haopanyou.net（已失效） App：tg破解软件中文频道，搜#影视 网盘搜索：pan.qianfan.app VLC　# 局域网视频播放器 椒盐音乐　# 本地音乐播放器\n音乐标签　# 歌词 小说：\n阅读　# 酷安评论区可以找书源 笔趣阁 阅读：ReadEra、福昕PDF阅读器\n去除启动广告：跳过广告\n动态壁纸：星空视频壁纸\n手机控制\ntasker、hamibot　# 手机自动化 Moonlight　# 局域网投屏 AirDroid和AirMirror　# 手机远程控制手机 向日葵远程控制 文件管理\nzarchiver　# 文件管理和解压 猫头鹰文件　# 访问局域网文件 APK Extractor　# 提取apk ","date":"2021-07-18T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/config/","title":"环境配置和软件"},{"content":"准备 1.Ubuntu\nsudo apt update # 更新 2.github账号\n3.git配置 默认保存在用户的主目录下的 .gitconfig 文件内\ngit config --global user.name \u0026#34;John Doe\u0026#34; # 配置github账号用户名 git config --global user.email johndoe@example.com # 配置邮箱 4.连接github\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # 生成SSH Keys 此为新版 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; # 此为旧版 cat ~/.ssh/id_ed25519.pub # 复制 点击github右上角头像-\u0026gt; Settings -\u0026gt; SSH and GPG Keys -\u0026gt; New SSH key添加\nssh -T git@github.com # 验证连接，输入yes 官方文档\n5.git ssh 代理设置\n非必要步骤，如果有一天ssh push网速极慢但https push正常，可尝试此操作\n创建~/.ssh/config 文件：\nHost github.com User git ProxyCommand nc -v -x 127.0.0.1:10808 %h %p # 请修改127.0.0.1:10808 安装 snap install hugo --channel=extended # 安装hugo hugo version # 验证 hugo new site myblog # 创建博客 git init # 初始化 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 删掉themes文件夹，安装stack主题作为子模块 rm config.toml \u0026amp;\u0026amp; cp themes/hugo-theme-stack/exampleSite/config.yaml . # 使用主题的配置文件 把myblog/themes/hugo-theme-stack/exampleSite/content内容移到myblog/content使用主题示例文章\n本地预览： myblog下执行\nhugo server 浏览器打开：\nhttp://localhost:1313/ 部署 注：我将介绍使用github托管源码自动化部署，如果您仅在本地存放源码，提交public文件夹即可，无需使用下列方法。\n1.虽然博客内容全都能看到，但我们可能不太希望公开源码，不开放源码使用github pages需要创建2个仓库: 创建 username.github.io.source 仓库存放源码可设为私人仓库，创建 username.github.io 仓库作为公开仓库\ngit remote add origin git@github.com:******.github.io.source.git # 连接远程仓库。注意使用ssh连接，如果使用https连接每次都要输账号密码。 点击github右上角头像-\u0026gt; Settings -\u0026gt; Developer Settings-\u0026gt; Personal access tokens -\u0026gt; Generate new token （Note随意，Select scopes全选,复制token，我们这里使用Personal tokens比Deploy keys更方便）\n找到源码仓库Settings-\u0026gt; Secrets and variables -\u0026gt; Actions -\u0026gt; New repository secret （Name写PERSONAL_TOKEN，Value粘贴token）\n2.创建github actions的workflows自动部署文件：\nmkdir -p .github/workflows \u0026amp;\u0026amp; touch ~/myblog/.github/workflows/main.yml 粘贴脚本：\nname: github pages on: push: branches: - master jobs: deploy: runs-on: ubuntu-latest #可 使用指定版本，例：runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest # 可使用指定版本，例：hugo-version: \u0026#39;0.83.1\u0026#39; extended: true - name: Build run: hugo --gc --forceSyncStatic --minify --cleanDestinationDir - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} # PERSONAL_TOKEN是源码仓库secrets的name external_repository: username/username.github.io # Pages 远程仓库 publish_branch: master # 部署的分支 publish_dir: ./public commit_message: ${{ github.event.head_commit.message }} #cname: www.example.com # 使用自定义域名 只需更改external_repository: username/username.github.io 为你的github账户名，脚本详情\n3.在myblog文件夹下创建push.sh\ntouch push.sh 粘贴脚本：\n#!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master 在myblog下运行 sh push.sh命令。\n到此已完成部署，之后任何更新如上运行push脚本即可\n修改主题 此处仅列举常见需修改内容，更多内容请看stack主题文档\n本博客修改样式来自rmdhnreza\n更多定制文章可以参考这里\n主题配置 1.修改~/myblog/config.yaml\n1 baseurl: https://username.github.io # 改为自己的 2 languageCode: zh-CN # 中文编码 4 paginate: 10 # 文章分页数 5 title: Example Site # 博客名字 30 DefaultContentLanguage: zh-cn # 中文 34 hasCJKLanguage: true # 正确计数中、日、韩文语言的字数 48 since: 2021 52 published: 2006-01-02 # 日期格式 53 lastUpdated: 2006-01-02 # 更新日期格式 56 emoji: 🍥 # 头像角标 57 subtitle: # 博客名下的简介 61 src: img/avatar.png # 头像，myblog/themes/hugo-theme-stack/assets/img 135 name: \u0026#39;首页\u0026#39; # 改中文左侧菜单home 155 startLevel: 1 # 从文章1级标题使用文章目录 195 unsafe: true # 允许Markdown嵌入html 2.左侧菜单栏 ~/myblog/content/page用于左侧菜单，请自定义\n2 title: \u0026#39;关于\u0026#39; #中文左侧菜单about，后同 3.覆盖主题样式\n直接在~/myblog下复制rmdhnreza的assets和layouts文件夹。\n另外修改：\n~/myblog/assets/scss/variables.scss\nlink-background-color: 0, 255, 255 链接背景颜色 注：浏览器可能缓存样式，可使用无痕模式\n创建文章 hugo new post/文件夹名/index.md #创建文章 写文章：\n1.front matter:\n--- title: hugo使用stack主题搭建博客及部署 #标题 description: #副标题，此样式不可用 date: 2021-07-04 #日期 lastUpdated: 2021-07-27 #上次修改内容的日期 slug: hugo-blog #URL的尾部，用于文章地址 categories: #文章分类 - blog --- front matter仅列举本文使用，hugo front matter官方文档\n2.常见文章markdown语法：\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n`单行代码` `` 有`需用双反引号 ``\n```html\n多行代码\n```\n[链接](https://)\n\\ 写在特殊符号前为转义；写在行尾为换行\\\n*斜体*\n**加粗**\n~~删除线~~\n* 无序列表\n双空格* 子无序列表\n![图片描述](本地图片.jpg)\n表格\n| Italics | Bold | Code | | -------- | -------- | ------ | | *italics* | **bold** | `code` | shortcodes ./myblog/layouts/shortcodes\n{{\u0026lt; spoiler text=\u0026quot;点击展开和折叠代码\u0026quot; \u0026gt;}}\n```html\ncode\n```\n{{\u0026lt; /spoiler \u0026gt;}}\n{{\u0026lt; typography font=default size=\u0026quot;30px\u0026quot; style=\u0026quot;normal\u0026quot; weight=\u0026quot;bold\u0026quot; color=\u0026quot;blue\u0026quot;\u0026gt;}} 自定义字体 {{\u0026lt; /typography \u0026gt;}}\n# font　Google 字体\n# size　大小\n# style　normal正常， italic 斜体\n# weight　bold 加粗 ， lighter 更细\n{{\u0026lt; box info \u0026gt;}} Hello there, and have a nice day {{\u0026lt; /box \u0026gt;}} Hello there, and have a nice day\n{{\u0026lt; box warning \u0026gt;}} Hello there, and have a nice day {{\u0026lt; /box \u0026gt;}} Hello there, and have a nice day\n{{\u0026lt; box important \u0026gt;}} Hello there, and have a nice day {{\u0026lt; /box \u0026gt;}} Hello there, and have a nice day\n{{\u0026lt; box tip \u0026gt;}} Hello there, and have a nice day {{\u0026lt; /box \u0026gt;}} Hello there, and have a nice day\n评论系统 waline官方文档写得非常清楚，您只需 LeanCloud设置 和 部署到Vercel ，拿到URL\n然后修改~/myblog/config.yaml\n52 provider: waline #评论系统，本文示例使用waline 73 serverURL: https:// #评论系统URL用你自己的 执行sh push.sh即可\n自定义域名 在~/myblog/config.yaml修改baseurl: https://username.github.io\n在~/myblog/.github/workflows/main.yml最后一行取消注释并修改cname: https://example.com\n执行sh push.sh即可\n启用https：参考链接\n","date":"2021-07-03T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/hugo-blog/","title":"hugo使用stack主题搭建博客及部署"}]