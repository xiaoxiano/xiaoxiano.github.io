[{"content":"想要体验二合一笔记本，大约有这些选择：\nsurface pro系不错，可是高价买低配 ROG 幻X，高配显卡反而拉低续航，二合一的屏幕尺寸也不适合打游戏 Chromebook，折腾。 x-station？ Windows的二合一更偏向于移动式笔记本电脑，用于外出用电脑，易用性强，但很多Android应用不能用。\nChromebook duet5 二合一的形态是平板的升级，强于Android平板甚至是Ipad，但还Chrome OS不成熟，不适配的bug很多。\nChromebook duet5 开启开发者模式 首先SSTap分享网络登录进去。\n从主机上取下可拆卸键盘，按住[提高音量]+[降低音量]+[电源按钮]约 10 秒钟，然后松开，您应该看到恢复模式屏幕。（Chromebook duet5和其他机型的方法有所不同）\n音量键可以切换语言，然后选中高级-\u0026gt;开发者模式-\u0026gt;从内部磁盘启动，系统将发出哔哔声重新启动并开始设置。\n双拼输入法 项目地址\n谷歌插件商店，先安装IME UI控件 ，然后再安装IME Decoder(chrome \u0026gt; 102) 。\n系统设置-\u0026gt;语言与输入法-\u0026gt;添加输入法,找到\u0026quot;中文双拼输入法\u0026quot;添加并选择启用输入。\n","date":"2023-04-16T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/chromebook/","title":"二合一笔记本"},{"content":"挖坑\n","date":"2023-04-10T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/medical/","title":"医学"},{"content":"电池 一次性电池 命名 负极 电解质 正极 标称电压(V) 特点 Alkaline battery\n碱性电池\n锌 碱金属氢氧化物 二氧化锰 1.5 容量大\n自放电率低\n价格便宜 Aluminium–air batteries\n铝空气电池 铝 氢氧化钾\n氢氧化钠 氧 1.2 军事用途 Atomic battery\n原子能电池 \u0026nbsp; 放射性同位素 \u0026nbsp; \u0026nbsp; 航天器\n登月车\n水下仪器 Bunsen's cell\n本生电池 锌 \u0026nbsp; 碳 1.9 1841发明\n以本生命名\n有毒 Earth battery\n接地电池 铜/铁/锌 土壤 铜/铁/锌 \u0026nbsp; 防强电冲击 Frog battery\n青蛙电池 \u0026nbsp; 青蛙腿 \u0026nbsp; \u0026nbsp; 生物电试验 Galvanic cell\nVoltaic cell\n原电池 锌 硫酸锌 铜 \u0026nbsp; 伽伐尼VS伏打\n最终两人同登\n名人堂 Grove cell\n格罗夫电池 铂 浓硝酸 锌 \u0026nbsp; 还记得武汉\n格罗夫汽车\n吗？ Leclanché cell 二氧化锰\n碳 氯化铵 锌 \u0026nbsp; 碳锌电池雏形\n目前Leclanché是\n电池企业品牌 Lemon/potato battery\n柠檬/马铃薯电池 锌 柠檬/马铃薯 铜 \u0026nbsp; 教学电池 Lithium battery\n锂电池 碳 \u0026nbsp; 锂化合物 3.7 21世纪\n电池之王 Lithium–air battery\n锂空气电池 氧 酸性水溶液\n等 锂 2.91 \u0026nbsp; Magnesium battery\n镁电池 二硫化锆\n氧化钴\n二硒化钨 \u0026nbsp; 镁 3.1 \u0026nbsp; Mercury battery\n汞电池 锌 碱金属氢氧化物 氧化汞\n二氧化锰 1.4 纽扣电池\n记得放\n“有害垃圾”桶 Molten-salt battery\n熔盐电池 \u0026nbsp; 盐类熔融体 \u0026nbsp; \u0026nbsp; 高温电池\n储能成本低 Nickel oxyhydroxide battery\n羟基氧化镍电池 锌 碱金属氢氧化物 二氧化锰\n羟基氧化镍 1.5 \u0026nbsp; Organic radical battery\n有机自由基电池\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; 塑料电池？ Paper battery\n纸电池 \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; PPT产物？ Silver-oxide battery\n银锌电池 锌 碱金属氢氧化物 氧化银 1.55 \u0026nbsp; Solid-state battery\n固态电池 \u0026nbsp; 固态电解质 \u0026nbsp; \u0026nbsp; \u0026nbsp; Sugar battery\n糖电池 \u0026nbsp; 麦芽糖糊精 \u0026nbsp; \u0026nbsp; PPT产物？\n索尼率先发表\n论文的喔…… Zinc–carbon battery\n锌碳电池 锌 氯化铵\n氯化锌 二氧化锰 1.5 \u0026nbsp; Zinc–air battery\n锌氧电池 锌 氯化铵\n氯化锌 氧 1.4 也叫\n“锌空气电池” 可充电电池 Aluminium-ion battery\n铝离子电池\n石墨 \u0026nbsp; 铝 2.0(?) 理想很丰满\n现实很骨感 Dual carbon battery\n双碳电池 碳 钾离子电解液 碳 \u0026nbsp; 耐高温\n充电超快\n当超级电容吧 Flow battery\n液流电池 \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; 需要建设\n全产业链\n才能运作 Lead–acid battery\n铅酸电池 铅 硫酸溶液 二氧化铅 12 电压稳定\n产业成熟\n能量密度低 Glass battery\n玻璃电池 石墨 固态电解质 碱金属 \u0026nbsp; 可能是下\n一个突破口 Lithium-ion battery\n锂离子电池 石墨\n等 无数种 无数种 3.2\n3.7 21世纪\n电池之王 Magnesium-ion battery\n镁离子电池 镁 \u0026nbsp; \u0026nbsp; 1.5\n2.0 高能量密度\n循环寿命长 Metal–air electrochemical cells\n金属-空气电池 镁\n铝\n锌\n等 碱性溶液 氧 \u0026nbsp; 细分种类\n非常多 Molten-salt battery\n熔盐电池 \u0026nbsp; 盐类熔融体 \u0026nbsp; \u0026nbsp; 高温电池\n电网级储能\n储能成本低 Microbial fuel cell\n微生物燃料电池 微生物电极 \u0026nbsp; 微生物电极 \u0026nbsp; 利用污水\n或光合作用\n发电 Nickel–cadmium battery\n镍镉电池 镉 \u0026nbsp; 二氧化镍 1.2 老式手机电池 Nickel hydrogen battery\n镍氢气电池 镍 氢氧化钾\n氢气 催化剂 1.25 使用气态氢\n高压电池\n循环寿命长\n用在卫星上 Nickel metal hydride battery\n镍氢电池 金属氧化物 氢氧化钾 氢氧化镍 1.2 镍镉进化版 Nickel–iron battery\n镍铁电池 铁 氢氧化钾 氧化镍 1.2 爱迪生发明\n价格高\n可靠性极高\n铁道车辆使用 Nickel–zinc battery\n镍锌电池 锌 氢氧化钾 镍 1.65 历史悠久\n一致性差\n不能过充 Organic radical battery\n有机自由基电池 \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; 塑料电池？\n不含重金属\n可制薄膜电池 Solid-state battery\n固态电池 \u0026nbsp; 固态电解质 \u0026nbsp; \u0026nbsp; 能量密度高 Potassium-ion battery\n钾离子电池 金属氧化物 固态聚合物 碳类 \u0026nbsp; 钾便宜 Rechargeable alkaline battery\n可充电碱性电池 锌 碱金属氢氧化物 二氧化锰 1.5 循环寿命短\n20个深度循环 Silicon–air battery\n硅空气电池 氧 \u0026nbsp; 硅 1.2 材料便宜环保\n能量密度高\n暂未实用化 Silver zinc battery\n银锌电池 锌 碱金属氢氧化物 氧化银 1.55 笔记本电脑\n助听器\n人造卫星\n潜艇与鱼雷 Silver-cadmium battery\n银镉电池 镉 氢氧化钾 氧化银 1.1 有毒\n电压太低 Sodium-ion battery\n钠离子电池 无烟煤基 \u0026nbsp; 锰基\n铜基 \u0026nbsp; 钠丰度高\n替代铅酸\n低速电动车 Sodium–sulfur battery\n钠硫电池 熔融金属钠 \u0026nbsp; 液态硫\n多硫化钠熔盐 \u0026nbsp; 高温电池\n制造简单\n电网储能 原文地址\n动力电池 新能源车的动力电池类型主要分为磷酸铁锂和三元锂电池，两者基本上瓜分了新能源市场的动力电池份额。\n固态电池\n全固态电池规模化量产尚需5-10 年，半固态成过渡期优选。出于对高能量密度和高安全性电池的追求，各国企业进入军备竞赛阶段，加注研发固态电池。但全固态电池还有离子电导率低导致性能变差、成本高昂等缺点有待解决，而半固态电池由于高安全性、长寿命与良好的经济性，成为液态电池向全固态电池过渡的产品。\n生活电池 碳性电池\n碳性电池是一种一次电池，属于原电池，它以二氧化锰为正极，电量约700mAh。碳性电池适合用在低电流的电器上，如石英钟、遥控器等。\n碱性电池\n碱性电池是一种一次电池，电量约1800~2000mAh。碱性电池适用在高电流的电器上，如数码相机、玩具、剃须刀、无线鼠标等。\n锂铁电池\n锂铁电池是一种一次电池，属于锂电池，电量约3000mAh。锂铁电池寿命长，尤其适用鼠标等，目前厂家仅有耐时电池和小米超级电池。\n","date":"2023-03-17T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/research/","title":"行业研究"},{"content":"购买vps一般需要注意性能、带宽和线路。\n性能是根据自身需要的，一般需要看内存，跑代理512M足够了，跑业务最好在2G以上。\n带宽只要搜一下商家的测评，注意共享带宽的实际速度、高峰速度就行了。\n线路却是一个相对复杂的问题。不仅海外各地区线路繁多，不同运营商、不同省市的情况也不同。所以，玩鸡第一步，首先测线路。\n测试线路 测试全国到VPS的延迟 ipip.net的ping工具输入ip，选择中国，然后ping。\n路由跟踪 去程路由跟踪 方式一：下载BestTrace软件，点路由跟踪，输入ip，开始。\n方式二：ipip.net的traceroute工具选地区，输入ip，查看。\n回程路由跟踪 回程跟踪需要连接到VPS，执行以下命令\nyum install -y wget unzip \u0026amp;\u0026amp; wget https://cdn.ipip.net/17mon/besttrace4linux.zip \u0026amp;\u0026amp; unzip best ./besttrace 你的本地ip -g cn 常见线路 介绍 IPLC国际私用出租线路\n电信的163骨干网自治系统编号 AS4134\n电信的CN2骨干网自治系统编号 AS4809\n联通的169骨干网自治系统编号 AS4837\n联通的A网骨干网自治系统编号 AS9929\n移动的CMNET境内骨干网自治系统编号 AS9808\n移动的CMI境外骨干网自治系统编号 AS58453\nCERNET（教育网，主用于高校）骨干网自治系统编号 AS4538\nCSTNET（科技网）骨干网自治系统编号 AS7497\n实际体验（以延迟排序） 最优： 香港IPLC、香港CN2 GIA：价格不在博主承担范围。\n次优： 日本SoftBank（推荐）：价格较高，v.ps约39、49欧元/年,搬瓦工$169/年。 新加坡CN2：价格太高。\n日本IIJ：超过200ms。vmiss有平价大带宽产品。\n香港CMI：超过200ms。移动网，有高峰期慎买。\n一般： 新加坡NTT：超过300ms。慎买。\n美国CN2 GIA（较为推荐）：超过500ms。平价大带宽，价格合理，网络审查宽松，且访问的大多服务器设在美国。\n差线路： racknerd、greencloud很廉价，适合测试用。\n防坑：\n知名vps商家基本不跑路，但很多机场会跑路，用机场一定要月付。\n有些商家线路会绕路欧美，至少要看测评，最好自测。\n韩国vps：会要求实名，即使你购买了可以使用，也会在一个月内要求实名，需自备韩国身份。\n日本vps：极少数涉及日本版权的网站和图片打不开，可能是日本的网络审查，几乎不影响使用。\n香港vps：高峰期可能爆炸，便宜商家的机房容易受到攻击。认准线路和口碑商家，否则不要买。\n","date":"2023-03-13T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/vps/","title":"VPS 选购"},{"content":"排列组合 1.特殊元素和特殊位置优先策略 例 1. 由 0,1,2,3,4,5 可以组成多少个没有重复数字五位奇数？\n解析\r先排末位共有 $C_3^1$, 然后排首位共有 $C_4^1$, 最后排其它位置共有 $A_4^3$, 由分步计数原理得 $C_4^1 C_3^1 A_4^3=288$ 。\n2.相邻问题捆绑法: 题目中规定相邻的几个元素捆绑成一个组，当作一个大元素参与排列.\n例 1. A,B,C,D,E 五人并排站成一排，如果 A,B必须相邻且 B在 A的右边，则不同的排法有（ ）\nA、60 种 B、48 种 C、36 种 D、24 种\n解析\r把 A,B 视为一人，且 B 固定在 A 的右边，则本题相当于 4 人的全排列，$A_4^4$=24 种， 答案： D .\n例 2. 7 人站成一排 ,其中甲乙相邻且丙丁相邻,共有多少种不同的排法.\n解析\r可先将甲乙两元素捆绑成整体并看成一个复合元素，同时丙丁也看成一个复合元素，再与其它元素进行排列，同时对相邻元素内部进行自排。由分步计数原理可得共有 $A_5^5$$A_2^2$$A_2^2$= 480种不同的排法\n3.相离问题插空策略: 元素相离（即不相邻）问题，可先把无位置要求的几个元素全排列，再把规定的相离的几个 元素插入上述几个元素的空位和两端.\n例 1. 七人并排站成一行，如果甲乙两个必须不相邻，那么不同的排法种数是（ ）\nA、1440 种 B、3600 种 C、4820 种 D、4800 种\n解析\r除甲乙外，其余 5 个排列数为$A_5^5$种，再用甲乙去插 6 个空位有$A_6^2$种，不同的排法种数是$A_5^5$$A_6^2$=3600 种， 选 B.\n例 2. 某人射击八枪,命中四枪,四枪中恰好有三枪连在一起的情形的不同种数为?\n解析\r把连续命中的三枪看做一个整体a,剩下命中的一枪看做一个整体b,用插空法,把a,b两个元素按一定顺序插到剩下四枪形成的5个空隙里,是$A_5^2$=20\n4.定序问题: 例 1. 7 人排队，其中甲乙丙 3 人顺序一定（可以不相邻），共有多少不同的排法?\n解析\r(倍缩法) 对于某几个元素顺序一定的排列问题，可先把这几个元素与其他元素一起进行排列，然后用总排列数除以这几个元素之间的全排列数，则共有不 同排法种数是: $A_7^7 / A_3^3$\n(空位法) 设想有7把椅子让除甲乙丙以外的四人就坐共有$A_7^4$ 种方法，其余的三个位置甲乙丙共有（1）种坐法，则共有$A_7^4$ 种方法。\n5.有序分配问题逐分法: 有序分配问题指把元素分成若干组，可用逐步下量分组法.\n例 1. 有甲乙丙三项任务，甲需 2 人承担，乙丙各需一人承担，从 10 人中选出 4 人承担这三项任务，不同的选法种数是（ ）\nA、1260 种 B、2025 种 C、2520 种 D、5040 种\n解析\r先从 10 人中选出 2 人承担甲项任务，再从剩下的 8 人中选 1 人承担乙项任务，第三步从另外的 7 人中选1 人承担丙项任务，不同的选法共有 $C_{10}^{2}$$C_8^1$$C_7^1$=2520 种，选 C.\n例 2. 12 名同学分别到三个不同的路口进行流量的调查，若每个路口 4 人，则不同的分配方案有（ A）\nA、$C_{12}^{4}$$C_8^4$$C_4^4$ 种 B、3$C_{12}^{4}$$C_8^4$$C_4^4$ 种 C、$C_{12}^{4}$$C_8^4$$A_3^3$ 种 D、$\\frac{C_{12}^{4}C_8^4C_4^4}{A_3^3}$ 种\n6.元素不同的分配问题先选后排: 例 1. 4 名优秀学生全部保送到 3 所学校去，每所学校至少去一名，则不同的保送方案有多少种？\n解析\r把四名学生分成 3 组有 $C_4^2$ 种方法，再把三组学生分配到三所学校有 $A_3^3$ 种，故共有 $C_4^2$$A_3^3$=36 种方法.\n例 2. 5 本不同的书，全部分给 4 个学生，每个学生至少一本，不同的分法种数为（ ）\nA、480 种　B、240 种 C、120 种 D、96 种\n解析\rB. $C_5^3$$A_4^4$=240\n7.元素相同的分配问题隔板法: 例 1： 10 个三好学生名额分到 7 个班级，每个班级至少一个名额，有多少种不同分配方案？\n解析\r10 个名额分到 7 个班级，就是把 10 个名额看成 10 个相同的小球分成 7 堆，每堆至少一个，可以在 10 个小球的 9 个空位中插入 6 块木板，每一种插法对应着一种分配方案，故共有不同的分配方案为$C_9^6$=84 种.\n例 2： 若x+y+z+w=100,求这个方程组的自然数解的组数.\n解析\r我们认为0是自然数，所有存在0+0+0+100=100的情况，所以这里的元素 个数应为104个，即3个 0和100个1，这104个元素间有103个空位，中间插入 4个隔板，就会把这104个元素分成4堆，每堆对应 x,y,x,w,而挡板的放置方法有$C_{103}^{3}$\n8.限制条件的分配问题分类法: 例 1. 某高校从某系的 10 名优秀毕业生中选 4 人分别到西部四城市参加中国西部经济开发建设，其中甲同学不到银川，乙不到西宁，共有多少种不同派遣方案？\n解析\r因为甲乙有限制条件，所以按照是否含有甲乙来分类，有以下四种情况： ①若甲乙都不参加，则有派遣方案 $A_8^4$ 种；②若甲参加而乙不参加，先安排甲有 3 种方法，然后安排其余学生有 $A_8^3$方法，所以共有 3$A_8^3$；③若乙参加而甲不参加同理也有 3$A_8^3$种；④若甲乙都参加，则先安排甲乙，有 7 种方法， 然 后 再 安 排 其 余 8 人 到 另 外 两 个 城 市 有 $A_8^2$种 ， 共 有 7$A_8^2$方 法 . 所 以 共 有 不 同 的 派 遣 方 法 总 数 为 $A_8^4$ + 3$A_8^3$ + 3$A_8^3$ + 7$A_8^2$=4088 种.\n9.多元问题分类法： 例 1 （1）由数字 0，1，2，3，4，5 组成没有重复数字的六位数，其中个位数字小于十位数字的共有（ ）\nA、210 种 B、300 种 C、464 种 D、600 种\n（2）从 1，2，3…，100 这 100 个数中，任取两个数，使它们的乘积能被 7 整除，这两个数的取法（不计顺序）共有多少种？\n（3）从 1，2，3，…，100 这 100 个数中任取两个数，使其和能被 4 整除的取法（不计顺序）有多少种？\n解析\r（1）按题意，个位数字只可能是 0，1，2，3，4 共 5 种情况，分别有 $A_5^5$个，$A_4^1$$A_3^1$$A_3^3$ , $A_3^1$$A_3^1$$A_3^3$ , $A_2^1$$A_3^1$$A_3^3$ , $A_3^1$$A_3^3$个，合并总计 300 个,选 B.\n（2）被取的两个数中至少有一个能被 7 整除时，他们的乘积就能被 7 整除，将这 100 个数组成的集合视为全集I,能被 7 整除的数的集合记做 $\\overline{A}$ = { 7，14，21，$\\cdots$，98 } 共有 14 个元素,不能被 7 整除的数组成的集合记做 $\\overline{A}$ = { 1，2，3，4,$\\cdots$，100 } 共有 86 个元素；由此可知，从 A中任取 2 个元素的取法有 $C_{14}^{2}$，从 A中任取一个，又从$\\overline{A}$中任取一个共有 $C_{14}^{1}$$C_{86}^{1}$，两种情形共符合要求的取法有 $C_{14}^{2}$ + $C_{14}^{1}$$C_{86}^{1}$=1295 种.\n（3）将 I = { 1,2,3,$\\cdots$，100 } 分成四个不相交的子集，能被 4 整除的数集 A = { 4,8,12,$\\cdots$，100 }；能被 4 除余 1 的数集B = { 1,5,9,$\\cdots$，97 } ，能被 4 除余 2 的数集 C = { 2,6,$\\cdots$，98 } ，能被 4 除余 3 的数集 D = { 3,7,11,$\\cdots$，99 } ，易见这四个集合中每一个有 25 个元素；从 A中任取两个数符合要；从B,D 中各取一个数也符合要求；从 C中任取两个数也符合要求；此外其它取法都不符合要求；所以符合要求的取法共有 $C_{25}^{2}$ + $C_{25}^{1}$$C_{25}^{1}$ + $C_{25}^{2}$ 种.\n10.交 叉 问 题 集 合 法 ： 例 1. 从 6 名运动员中选出 4 人参加 4×100 米接力赛，如果甲不跑第一棒，乙不跑第四棒，共有多少种不同的参赛方案？\n解析\r设全集= {6 人中任取 4 人参赛的排列} ，A={甲跑第一棒的排列} ，B={乙跑第四棒的排列} ，根据求集合元素个数的公式得参赛方法共有： n(I)-n(A)-n(B)+n(A $\\cap$ B ) = $A_6^4$-$A_5^3$-$A_5^3$+$A_4^2$ = 252\n11.配对问题： 例 1. 5双相异的鞋共10只,现随机地取出6只,恰好能配成2双鞋的取法是多少?\n解析\r$C_{5}^{2} C_{6}^{1} C_{4}^{1}$=240\n12.多排问题单排法: 例 1. 8人排成前后两排，每排4人，其中甲乙在前排，丙在后排，共有多少排法？\n解析\r看成一排，某 2 个元素在前半段四个位置中选排 2 个，有 $A_4^2$种，某 1 个元素排在后半段的四个位置中选一个有 $A_4^1$种，其余 5 个元素任排 5 个位置上有 $A_5^5$种，故共有 $A_4^2$$A_4^1$$A_5^5$=5760 种排法.\n13.“至少”“至多”问题用间接排除法或分类法: 例 1. 从 4 台甲型和 5 台乙型电视机中任取 3 台，其中至少要甲型和乙 型电视机各一台，则不同的取法共有（ ）\nA、140 种 B、80 种 C、70 种 D、35 种\n解析\r至少要甲型和乙 型电视机各一台可分两种情况：甲型 1 台乙型 2 台；甲型 2 台乙型 1 台；故不同的取法有 $C_5^2$$C_4^1$ + $C_5^1$$C_4^2$ =70 台,选 C.\n14.部分合条件问题排除法: 例 1. （1）以正方体的顶点为顶点的四面体共有（ ）\nA、70 种 B、64 种 C、58 种 D、52 种\n（2）四面体的顶点和各棱中点共 10 点，在其中取 4 个不共面的点，不同的取法共有（ ）\nA、150 种 B、147 种 C、144 种 D、141 种\n解析\r（1）正方体 8 个顶点从中每次取四点，理论上可构成 $C_8^4$四面体，但 6 个表面和 6 个对角面的四个顶点共面都不能构成四面体，所以四面体实际共有$C_8^4$-12= 58 个.\n（2）10 个点中任取 4 个点共有 $C_{10}^{4}$种，其中四点共面的有三种情况：①在四面体的四个面上，每面内四点共面的情况为 $C_6^4$，四个面共有 4$C_6^4$个；②过空间四边形各边中点的平行四边形共 3 个；③过棱上三点与对棱中点的三角形共 6 个.所以四点不共面的情况的种数是 $C_{10}^{4}$ - 4$C_6^4$ -3-6=141 种.\n15.可重复的排列求幂法: 例 1. 把 6 名实习生分配到 7 个车间实习共有多少种不同方法？\n解析\r完成此事共分 6 步，第一步；将第一名实习生分配到车间有 7 种不同方案，第二步：将第二名实习生分配到车间也有 7 种不同方案，依次类推，由分步计数原理知共有 $A_{7}^{6}$种不同方案.\n16.上楼梯问题: 例 1. 10级台阶，某人可一步跨一级，也可跨两级，也可跨三级。 （1）他6步就可上完台阶的方法数是多少？ （2）他上完台阶的方法总数是多少？\n解析\r（1）按照 3，3，1，1，1，1 的走法有 $C_{6}^{2}$ 种，按照 3，2，2，1，1，1 的走法有 $C_{6}^{1} C_{5}^{2}$ 种，按照 2，2，2，2，1，1 的走法有 $C_{6}^{4}$ 种，所以恰好6步上完台阶的方法种数是 $C_{6}^{2}$+$C_{6}^{1} C_{5}^{2}$+$C_{6}^{4}$=15+60+15=90 .\n（2）上楼梯问题是典型的斐波那契数列，设爬n级台阶的解法总数为f(n)，因为规定每一步只能跨一级或两级或三级，则f(n)=f(n-1)+f(n-2)+f(n-3)。易知f(1)=1，f(2)=2，f(3)=4,递推可得f(4)=7,f(5)=13,f(6)=24,f(7)=44,f(8)=81,f(9)=149,f10)=274\n17.元素个数较少的排列组合问题可以考虑枚举法: 例 1. 设有编号为 1，2，3，4，5 的五个球和编号为 1，2，3，4，5 的盒子现将这 5 个球投入 5 个盒子要求每个盒子放一个球，并且恰好有两个球的号码与盒子号码相同，问有多少种不同的方法？\n解析\r从 5 个球中取出 2 个与盒子对号有 $C_5^2$种，还剩下 3 个球与 3 个盒子序号不能对应，利用枚举法分析，如果剩下 3，4，5 号球与 3，4，5 号盒子时，3 号球不能装入 3 号盒子，当 3 号球装入 4 号盒子时，4，5 号球只有1 种装法，3 号球装入 5 号盒子时，4，5 号球也只有 1 种装法，所以剩下三球只有 2 种装法，因此总共装法数为2$C_5^2$= 20 种.\n28.复杂的排列组合问题也可用分解与合成法: 例 1.（1）30030 能被多少个不同偶数整除？\n（2）正方体 8 个顶点可连成多少队异面直线？\n解析\r（1）先把 30030 分解成质因数的形式：30030=2×3×5×7×11×13；依题意偶因数 2 必取，3，5，7，11，13这 5 个因数中任取若干个组成成积，所有的偶因数为$C_5^0$+$C_5^1$+$C_5^2$+$C_5^3$+$C_5^4$+$C_5^5$= 32 个.\n（2）因为四面体中仅有 3 对异面直线，可将问题分解成正方体的 8 个顶点可构成多少个不同的四面体，从正方体 8 个顶点中任取四个顶点构成的四面体有$C_8^4$-12= 58 个，所以 8 个顶点可连成的异面直线有 3×58=174 对.\n19.利用对应思想转化法: 例 1. （1）圆周上有 10 点，以这些点为端点的弦相交于圆内的交点有多少个？\n（2）某城市的街区有 12 个全等的矩形组成，其中实线表示马路，从 A到 B的最短路径有多少种？\n解析\r（1）因为圆的一个内接四边形的两条对角线相交于圆内一点，一个圆的内接四边形就对应着两条弦相交于圆内的一个交点，于是问题就转化为圆周上的 10 个点可以确定多少个不同的四边形，显然有 $C_{10}^{4}$个，所以圆周上有10 点，以这些点为端点的弦相交于圆内的交点有 $C_{10}^{4}$个.\n（2）可将图中矩形的一边叫一小段，从 A到 B最短路线必须走 7 小段，其中：向东 4 段，向北 3 段；而且前一段的尾接后一段的首，所以只要确定向东走过 4 段的走法，便能确定路径，因此不同走法有 $C_{7}^{4}$种.\n20.全错位排列问题公式法: 例 1. 分别编有 1，2，3，4，5 号码的人与椅，其中i 号人不坐i 号椅（i = 1,2,3,4,5）的不同坐法有多少种？\n解析\r全错位排列是组合数学中的经典问题之一，使用公式不容易出错： $$ D(n)=(n-1) \\cdot[D(n-1)+D(n-2)] . $$ 又易知, $D(1)=0, D(2)=1$. 由递推公式可得: $D(3)=2, D(4)=9，D(5)=44$\n21.环排问题 例 1. 8 人围桌而坐,共有多少种坐法?\n解析\r$\\mathrm{n}$ 个不同元素作圆形排列,共有 $(\\mathrm{n}-1)$!种排法.即7! 如果从 $\\mathrm{n}$ 个不同元素中取出 $\\mathrm{m}$ 个元素作圆形排列共有 $\\frac{1}{n} A_n^m$ 。\n22.正难则反策略 例 1. 从 0,1,2,3,4,5,6,7,8,9 这十个数字中取出三个数，使其和为不小于 10 的 偶数,不同的取法有多少种？\n解析\r这问题中如果直接求不小于 10 的偶数很困难, 可用总体淘汰法。这十个数字 中有 5 个偶数 5 个奇数, 所取的三个数含有 3 个偶数的取法有 $C_5^3$, 只含有 1 个偶数 的取法有 $C_5^1 C_5^2$, 和为偶数的取法共有 $C_5^1 C_5^2+C_5^3$ 。再淘汰和小于 10 的偶数共 9 种, 符合条件的取法共有 $C_5^1 C_5^2+C_5^3-9$\n23.平均分组问题 例 1. 6 本不同的书平均分成 3 堆,每堆 2 本共有多少分法？\n解析\r分三步取书得 $C_6^2 C_4^2 C_2^2$ 种方法, 但这里出现重复计数的现象, 不妨记 6 本书为 $A B C D E F$, 若第一步取 $A B$, 第二步取 $C D$, 第三步取 $E F$ 该分法记为 (AB, $C D, E F)$, 则 $C_6^2 C_4^2 C_2^2$ 中还有 (AB, $\\left.\\mathrm{EF}, \\mathrm{CD}\\right)$, (CD, AB, $\\mathrm{EF}$ ), (CD, EF, AB) (EF, CD, AB), (EF, AB, CD) 共有 $A_3^3$ 种取法, 而这些分法仅是 ( $\\left.\\mathrm{AB}, \\mathrm{CD}, \\mathrm{EF}\\right)$ 一种分法, 故共有 $C_6^2 C_4^2 C_2^2 / A_3^3$ 种分法。\n24.分类与分步策略 例 1. 有红、黄、兰色的球各 5 只,分别标有 A、B、C、D、E 五个字母,现从中取 5 只,要求各字母均有且三色齐备,则共有多少种不同的取法\n解析\r按颜色分有1 1 3和1 2 2 两种，各3种方案。2.分字母，1 1 3对应有$C_5^1$$C_4^1$$C_3^3$共20种，1 2 2对应$C_5^1$$C_4^2$$C_2^2$共30种，320+330=150\n例 2. 在一次演唱会上共 10 名演员,其中 8 人能能唱歌,5 人会跳舞,现要演出一个 2 人唱歌 2 人伴舞的节目,有多少选派方法？\n解析\r10 演员中有 5 人只会唱歌, 2 人只会跳舞 3 人为全能演员。选上唱歌人员为 标准进行研究只会唱的 5 人中没有人选上唱歌人员共有 $C_3^2 C_3^2$ 种, 只会唱的 5 人中只 有 1 人选上唱歌人员 $C_5^1 C_3^1 C_4^2$ 种, 只会唱的 5 人中只有 2 人选上唱歌人员有 $C_5^2 C_5^2$ 种, 由分类计数原理共有 $C_3^2 C_3^2+C_5^1 C_3^1 C_4^2+C_5^2 C_5^2$ 种。\n","date":"2022-12-10T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/math/","title":"数学"},{"content":"Let’s Encrypt 是一个免费的，自动化的，开放的证书颁发机构（CA），为公众的利益而运行。 它是一项由 Internet Security Research Group（ISRG）提供的服务。\nacme.sh 则是实现了 acme 协议, 可以从 letsencrypt 生成免费的证书。\nLet’s Encrypt 速率限制 每个注册网域(Registered Domain) 的凭证颁发数量，限制为每周50 张 更新凭证受到重复凭证限制，一个星期内仅能颁发5 张重复的凭证。 网域验证失败限制，对于每个帐号每域名每小时5 次的限制。 每个IP 位置每3 个小时最多能建立10 个帐号。 如果你达到速率限制，你只能等待一个星期直到速率限制结束。\nacme申请证书 安装 acme.sh curl https://get.acme.sh | sh sudo apt install socat # 安装socat 选择默认 CA Zerossl 从 acme.sh v 3.0.0 开始，acme.sh 使用 Zerossl 作为默认 ca，您必须先注册帐户（一次），然后才能颁发新证书。\n~/.acme.sh/acme.sh –register-account -m xxxx@xxxx.com Let\u0026rsquo;s Encrypt 如果需要更换Let\u0026rsquo;s Encrypt可以使用如下命令：\n~/.acme.sh/acme.sh --set-default-ca --server letsencrypt 通过 http 方式申请证书 Webroot模式 这种方式需要你的服务器上面已经部署了网站环境。Acme 自动在你的网站根目录下放置一个文件,来验证你的域名所有权,完成验证. 然后就可以生成证书了.\n# 生成 RSA 证书： ~/.acme.sh/acme.sh --issue -d example.com -w /var/www/_letsencrypt/ # 生成 ECC 证书： ~/.acme.sh/acme.sh --issue -d example.com -w /var/www/_letsencrypt/ --keylength ec-256 /var/www/_letsencrypt/ 为 example.com 站点下的 /.well-known/acme-challenge/ 证书请求目录。\n80 端口空闲的证书申请方式 ~/.acme.sh/acme.sh --issue -d example.com --standalone 安装证书到指定文件夹 # 把密钥和证书安装到 /root 目录，并改名为 private.key 和 cert.crt。 ~/.acme.sh/acme.sh --installcert -d mydomain.com --key-file /root/cert/private.key --fullchain-file /root/cert/cert.crtchmod -R 755 /root/cert 更新（后续操作） 更新证书 手动更新 ~/.acme.sh/acme.sh --renew -d example.com --force 自动更新 安装 acme.sh 时会自动创建一个 cronjob，每天定期检查所有证书，如果证书需要更新会自动更新证书。 通过 crontab -l 查看 crontab 任务:\n46 0 * * * \u0026#34;/root/.acme.sh\u0026#34;/acme.sh --cron --home \u0026#34;/root/.acme.sh\u0026#34; \u0026gt; /dev/null 更新 Acme 脚本 升级 Acme.sh 到最新版本\n~/.acme.sh/acme.sh --upgrade 如果你不想手动升级, 可以开启自动升级:\n~/.acme.sh/acme.sh --upgrade --auto-upgrade DNS 申请证书(通常只支持付费域名) 几个 CA 的简单对比\n功能 LE Buypass ZeroSSL SSL.com Google Public CA 有效期 90 天 180 天 90 天 90 天 90 天 多域名 支持 支持，最多 5 个 支持 收费支持 支持 泛域名 支持 不支持 支持 收费支持 支持 Rate Limit 有 有 收费无 未知 有 GUI 管理 否 否 有 有 无 ECC 证书链 否 否 有 未知 无 客户支持 社区 收费 收费 收费 收费 cloudflare 使用全局 API 密钥，您需要登录您的 Cloudflare 帐户以获取您的API 密钥\nexport CF_Key=\u0026#34;sdfsdfsdfljlbjkljlkjsdfoiwje\u0026#34; export CF_Email=\u0026#34;xxxx@sss.com\u0026#34; 颁发证书：\n./acme.sh --issue --dns dns_cf -d example.com -d www.example.com 阿里云 DNS 申请方式 export Ali_Key=\u0026#34;abcd\u0026#34; export Ali_Secret=\u0026#34;xxxxxxxxxx\u0026#34; # RSA 证书 acme.sh --issue --dns dns_ali -d example.com -d *.example.com # ECC 证书 acme.sh --issue --dns dns_ali -d example.com -d *.example.com --keylength ec-256 Ali_Key 和 Ali_Secret 需要从阿里云RAM访问控制中获取。\nDNSPod 申请方式 export DP_Id=\u0026#34;1234\u0026#34; export DP_Key=\u0026#34;xxxxxxxxxxx\u0026#34; acme.sh --issue --dns dns_dp -d example.com -d www.example.com 文档 如何颁发证书\n使用 DNS API\n选项和参数\n","date":"2022-10-24T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/acme/","title":"acme.sh 申请证书"},{"content":"前言 云是我们常用的服务，aws是头部厂商，但我们还有更多选择，以降低价格。即使aws有高昂且复杂的定价，仍有很多人使用，所以本文也将介绍。\n目前我在使用的云存储是Backblaze B2（兼容S3 API），价格仅为 Amazon S3、Microsoft Azure 和 Google Cloud 的1/4。\n我们同样需要一个CDN缓存加速（cloudflare 与传统 CDN 不同，CloudFlare 处理对网站的所有请求，能够阻止针对网站的攻击，可以再加到传统CDN前作为防护），CDN在用户第一次请求后，会在接近用户的区域缓存源服务器的静态资源（没人请求不缓存，不主动和服务器保持同步），后续访问就更加快速，并降低服务器压力，可以使用cloudfront免费套餐，如果每月传出超过 1T 数据，可以考虑使用 bunny CDN。\nS3 Bucket桶 桶就类似于根文件夹，其命名必须全局性唯一。也就是说，如果别人已经创建了命为X的Bucket，你就不能再用X作为桶的名字了。\nEvents事件 在S3中，可以定义很多事件及其处理函数。比如当文件被创建，修改，删除，复制时，触发Lambda。这样就可以构建Event Driven Architecture，比如：新文件到S3 -\u0026gt; 触发Lambda处理函数 -\u0026gt; 处理结束后通知AppSync/GraphQL API -\u0026gt; 通知用户文件已经处理完毕。\nS3费用决定因素 官方：存储和管理数据时需要考虑六大 Amazon S3 成本组成：存储定价、请求和数据检索定价、数据传输和传输加速定价、数据管理和分析定价、复制定价以及使用 S3 Object Lambda 处理数据的价格。\n通常我们关注存储类型、储存数据量、请求量、数据传输的费用。\n存储类型 S3 标准 S3 标准是一种通用对象存储平台，提供较低的延迟和较高的吞吐量，因此非常适合各种使用案例，包括云应用程序、动态网站、内容分发、移动和游戏应用程序以及大数据分析。\nS3 智能分层 ——通用选它 S3 智能分层可自动识别并将不常访问的数据（30天内未访问的数据）移动到成本较低的基础架构中。当访问不频繁层中的对象时，它会自动移回更高性能层，并且30天时钟重新启动。在访问模式发生变化时，在两个访问层（频繁访问层和不频繁访问层）之间移动数据来实现自动节省成本，非常适用于访问模式未知或不断变化的数据。\nS3标准-IA（不频繁访问）——备份选它 S3 Standard-IA 适用于不常访问（超过30天访问一次）、但在需要时要求快速访问的数据。提供与“S3 标准”相同的高持久性、高吞吐量和低延迟，成本较低且性能出色使得“S3标准–IA”很适合长期存储和备份，以及用作灾难恢复文件的数据存储。\nS3 单区域 - IA（不频繁访问） S3标准-IA 的单区域存储，此类别不会自动在至少三个AZ上存储数据。\nS3 Glacier 即时检索 Amazon S3 Glacier Instant Retrieval 是一种归档存储类，可以为很少访问（超过90天访问一次）且需要毫秒级检索速度的长期数据提供最低成本的存储。\nS3 Glacier 灵活检索（前称为 S3 Glacier） S3 Glacier Flexible Retrieval 为每年访问 1—2 次且异步检索的归档数据提供低成本存储，数据检索时间可配置，从数分钟到数小时不等。\nAmazon S3 Glacier 深度档案 支持长期保留和数字化保存一年可能访问一到两次的数据，数据检索时间为 12 小时以内。\ncloudfront Origin domain ：源域，选S3 存储桶需配置Alternate Domain Names作为加速站点，写自己解析过的域名即为加速的站点\nAmazon S3 存储桶– DOC-EXAMPLE-BUCKET.s3.us-west-2.amazonaws.com\n配置为网站的 Amazon S3 存储桶– https://DOC-EXAMPLE-BUCKET.s3-website.us-west-2.amazonaws.com\nMediaStore 容器– examplemediastore.data.mediastore.us-west-1.amazonaws.com\nMediaPackage 端点– examplemediapackage.mediapackage.us-west-1.amazonaws.com\n亚马逊 EC2 实例– ec2-203-0-113-25.compute-1.amazonaws.com\nElastic Load Balancing 负载均衡器– example-load-balancer-1234567890.us-west-2.elb.amazonaws.com\n您自己的网络服务器– https://www.example.com\n自选ip失败经历 查看官方公布的ip段（我们只需要边缘节点ip-\u0026ldquo;CLOUDFRONT_REGIONAL_EDGE_IP_LIST\u0026rdquo;，因为GLOBAL站点会自动判断离边缘节点最近的区域和进行健康检查，再连到边缘节点） 由于给的ip是CIDR格式，我们需要转换。先JSON转列表。然后CIDR转ip（因为在线转不支持批量转换，所以建议下载这个工具），重命名为cidr2ip.exe，新建cidrs.txt，把列表复制进去，cmd执行cidr2ip -f cidrs.txt可得很大一列ip。最后ip批量查询，下载后可以看到ip地区，复制你所需地区的ip（查询速度会很慢，我的vps是日本的，排在最前面，运气很好没有查询很久）。\n创建Cloud front测速链接\naws首页搜索cloud front 创建分配\n源域填写能测速的地址：cachefly.cachefly.net 协议：匹配查看器\n自动压缩对象：No 缓存键和源请求（选择第二项）：Legacy cache settings 创建\n复制得到的域名 打开显示为测速地址即可（需要等到部署完成）\n使用CloudflareSpeedTest](https://github.com/XIU2/CloudflareSpeedTest)优选ip， cmd输入CloudflareST.exe -url xxxxxxxxxxx.cloudfront.net/100mb.test发现ip全部不能用。 aws查看vcpu ","date":"2022-10-07T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/cloud-service/","title":"云服务"},{"content":"主要参考文章\nAPI API的英文即 Application Programming Interface 首字母的缩写，直译过来的意思就是：程序之间的接口。我更倾向于把API理解为，程序之间的合约。有关 API 是什么及它的意义这里就不展开讲了。\nchrome浏览器开发者工具\n勾选上谷歌开发者工具的preserve log，保留上一个页面接口调用信息，从而方便我们查看\nPostman 界面导航说明 请求：\nparams：get请求传参。\nAuthrization：鉴权\nHeaders：请求头\naccept:客户端接收的数据类型。\ncontent-type:客户端发送给服务器的数据类型\nuser-agent:客户端的类型\nxmlhttprequest:异步请求\nBody：Post请求传参\nnone：没有参数\nform-data：文件上传（包含键值对和文件上传）\nx-www-from-urlencodeed：表单请求（键值对）\nraw：使用原始数据格式请求（JSON，XML，HTML，Text，Javascript）\nbinary：二进制文件上传。\nPre-request-script：请求之前的脚本。\nTests；请求之后的脚本。\nSetting：设置\nCookies：用于自动管理Cookie的功能\n响应：\nBody：返回的信息\nPretty（各种格式查看返回数据）\nRaw（文本格式）\nPreview（网页）\nCookie：响应Cookie\ntoken鉴权码：\ncsrf_token：一般情况下有效期是7-15天。\naccess_token：一般情况下有效期是10分钟-2小时\nHeaders：响应头\nTestResults：测试结果\n200 响应码\nGET 请求 GET 请求基本操作 （1）点击主界面「+」号，新建一个请求页\n（2）选择 GET 请求命令\n（3）输入 API 地址\n在 GoRest API 设计中 GET 请求无需鉴权，所有我们直接点击「Send」即可远程调取服务器信息。\n如果我们只想看调取其中一位用户的信息应该怎么办呢？我们可以在 API URL 中带上参数。\n带参数的 GET 请求 如果我们想查询 ID 为 2043 的用户信息，我们只需要在请求页面中的 Params(参数) 标签页的 KEY - VALUE 内填写对应的参数即可，之后 Postman 会自动在 API URL 中生成你填写的参数，使 URL 带上参数 GET 请求。\nhttps://gorest.co.in/public/v1/users?id=2043 设置完成后，点击「Send」\n我们可以看到，返回值中仅包含我们请求的 user id 为 2043 的用户信息。\nGET 请求中的多条件查询 有时，我们需要使用 API 进行多条件查询操作，比如想找 name 值为 kalacloud.com ，同时 gender 值为 male 的用户。（特别提示：此格式是通用写法，但最终要看 API 的开发者如何约定调用方式）\nBaseURL + ResourceName + ? + key1 = value1 + \u0026amp; + key 2 = value 2 …… 主 URL 之后使用 ? 连接参数，参数与参数之间使用 \u0026amp; 连接符连接。\nhttps://gorest.co.in/public-api/users/?name=kalacloud.com\u0026amp;gender=male 当然，我们可以直接在 Postman 的 Params 中直接填写 KEY - VALUE\n让 Postman 帮我们生成，然后点击「Send」\n可以看到 API GET 调取了我们设定的两个 VALUE 值的 data 信息。\n特别提示，你可以点击右上角的「Bulk Edit」进行参数的批量编辑\nPOST 请求 POST 方式一：模仿浏览器\n在发送一个get请求之后，postman会自动保存cookis，我们只需复制 Payload 的数据格式到 body ，复制 x-csrf-token 到 Headers ，发送这个 POST 请求\n自动方式可以参考\nPOST 方式二：鉴权 在 Authorization 中添加鉴权方式和密钥，postman会自动添加到Headers，按照api写入所需body，发送这个 POST 请求\n用 Postman 发送第一个 PUT 更新请求 PUT 请求一般用于更新服务器已有资源，如果服务器中没有对应的资源，那么 PUT 会创建相应的资源（特别提醒：虽然 PUT 有创建新资源的功能，但是否能创建成功，最终取决于你调用的 API 是否支持此功能）\n打开你的 Postman 我们来创建一个 PUT 请求。\n点击「+」号，新建一个请求页\n请求类型选择「PUT」\n根据第6节我们使用 POST 请求创建的资源 ID 为 1475 ，又根据 GoRest API 的文档得知，修改资源的 API 地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PUT 修改 ID 为 1475 资源的请求地址应该写：\nhttps://gorest.co.in/public/v1/users/1475 选择在 Body 标签中填写 JSON 格式的资源修改信息。我们将 1475 中的邮箱由\nJiangChuan@kalacloud.com 修改为 Hi@kalacloud.com，所以我们在 Body 中填写以下代码。\n{ \u0026#34;name\u0026#34;: \u0026#34;kalacloud\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;Male\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;Hi@kalacloud.com\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;Active\u0026#34; } 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 PUT 请求 如上图所示，可以看到红4位置 响应代码返回 200 ，这说明 PUT 请求已经执行成功。 返回的 Body 信息中，email 字段已经更新为 Hi@kalacloud.com 用 Postman 发送第一个 PATCH 更新请求 PATCH 请求一般用于服务器资源的部分更新，它相对于 PUT 提交的数据更少，不用提整个数据，只需要提交需要修改的字段即可。有关 PUT 和 PATCH 的更多区别，可查看本文第9节。\n打开你的 Postman 我们来创建一个 PATCH 请求。\n点击「+」号，新建一个请求页\n请求类型选择「PATCH」\n根据第6节我们使用 POST 请求创建的资源 ID 为 1475 ，又根据 GoRest API 的文档得知，修改资源的 API 地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PATCH 修改 ID 为 1475 资源的请求地址应该写，到这里都和 PUT 请求修改资源的方法一样。\nhttps://gorest.co.in/public/v1/users/1475 选择在 Body 标签中填写 JSON 格式的资源修改信息。上一节我们已经将 ID 为 1475 资源的邮箱改为 Hi@kalacloud.com ，接着我们用 PATCH 请求把这个邮箱改为\nHelloWord@kalacloud.com { \u0026#34;email\u0026#34;:\u0026#34;HelloWord@kalacloud.com\u0026#34; } 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 PATCH 请求 如上图所示，可以看到红4位置 响应代码返回 200 ，这说明 PATCH 请求已经执行成功。\n返回的 Body 信息中，email 字段已经更新为\nHelloWord@kalacloud.com PUT 和 PATCH 的区别 在 HTTP 协议中，PUT 和 PATCH 都是用于更新服务器资源的命令，但他们有着不同的格式和用途。\nPUT 请求：一般用于更新服务器已有资源，如果服务器中没有对应的资源，那么 PUT 会创建相应的资源（特别提醒：虽然 PUT 有创建新资源的功能，但是否能创建最终取决于你调用的 API 是否支持此功能）\nPATCH 请求：用于局部更新服务器现有资源，它不用像 PUT 更新资源中的一点点也要提交所有字段信息，PATCH 更新哪个字段就提交哪个字段的更新信息即可。\n举例说明PUT 和 PATCH 的区别：\n同样是更新资源中的 Email 信息，PUT 需要带上资源中的所有信息，然后在更新（上图）\n而 PATCH 则仅需要提交更新部分，即仅提交邮箱信息即可（下图）\n那么，如果 PUT 像 PATCH 一样仅提交资源的局部信息会发生什么呢？会 400 报错。\nPUT 不论修改多少，必须把修改资源的全部字段写全，否则会 400 报错。\n用 Postman 发送第一个 DELETE 删除请求 我们在上文讲了获取(GET)，创建(POST)，更新(PUT / PATCH) 请求，接着我们来说说删除(DELETE) 请求。顾名思义，DELETE 请求执行可删除整个资源。我们来直接实践一次你就明白了。\n打开你的 Postman ，跟随本教程一起创建一个 DELETE 请求。\n点击「+」号，新建一个请求页\n请求类型选择「DELETE」\n我们来把上文刚刚创建的 ID 为 1475 的资源彻底删掉。根据 GoRest API 的文档得知，删除资源的 API 请求地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PATCH 删除 ID 为 1475 资源的请求地址应该写：\nhttps://gorest.co.in/public/v1/users/1475 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 DELETE 请求，删除对应的资源。 如上图所示，提交 DELETE 请求后，响应代码为 204 ，返回的 body 为空，删除成功。\n特别提示：在 GoRest 的文档说明中，特别说了 DELETE 删除返回值的状态。\nAPI 返回状态具体是怎么样的，还要看 API 的开发者是如何约定的，并非只有返回 200 才是成功的。\nPostman 中的全局变量、环境变量、集合变量的设置 Postman 设置变量的意义 Postman 里有多种变量，我们可以把某些重要的值抽象出来变成变量，方便我们做场景 / 条件切换。比如，我们可以把 baseURL 抽出来，在环境变量里设置「生产环境变量」和「测试环境变量」，之后，我们只需要切换标签即可快速将数据从一个环境切换到另一个环境中，非常方便。\nPostman 常用的三种变量形式 全局变量：全局变量一旦声明，即可应用到 Postman 中所有测试的 API 中。任何请求都可以直接使用全局变量，它的作用域是全局的。 环境变量：Postman 的环境变量可以理解为一组选项，当这组环境变量选项被选中时，才会生效，特别适合「生产环境」和「测试环境」之间的切换等应用场景。 集合变量：集合变量是针对集合（Collections）生效的，一个集合下可能有 N 条 API 请求，集合变量可以一次修改集合下的所有变量数值。 以上三种变量的作用域从大到小为 全局 集合 环境，当三个变量形式同时作用于一个 API 测试条时，Postman 会优先使用最小作用域变量。\n如何在 Postman 设置全局变量与环境变量 新建一个请求页，点击右上角的「小眼睛」进入变量设置页。 页面上方为「环境变量」，我们点击编辑设置环境变量名为「卡拉云_API 测试环境」 VARIABLE 设置为 baseURL，INITIAL VALUE 设置为 https://gorest.co.in ，保存之后我们就可以使用 {{baseURL}} 变量来替代 API URL 了。 页面下方为「全局变量」，VARIABLE 设置为 kalacloud_id，INITIAL VALUE 设置为 2312 (2312 为 GoRest 中的一个已存在的用户信息 ID)，保存后我们就可以使用 {{kalacloud_id}} 变量来替代 ID 值了。 我们来一起测一下刚刚设置好的「全局变量」和「环境变量」是否生效。\n新建一个 GET 请求页，地址栏填入： {{baseURL}}/public/v1/users?id={{kalacloud_id}} 点击「Send」 返回响应代码为 200 说明请求成功，返回的 Body 信息是 ID 为 2312 的用户信息，说明全局和环境变量已生效。\n如何在 Postman 设置集合变量 集合变量是指应用在整个集合所有请求中的变量，集合变量优先与其他变量应用与请求，也就是说如果有集合变量，那么其他变量与集合变量相冲突的化，优先执行集合变量。\n集合变量很适合临时修改整个集合中的变量，来针对集合进行测试。\n打开你的 Postman，我们一起操作一遍。\n选中一个集合，点击集合标题右侧「\u0026hellip;」选择编辑。 进入集合设置页，选择 Variables 设置集合变量 此时，整个集合下所有请求页，都应用了此集合变量。 如何使用 Postman Pre-request scripts 预请求脚本 Pre-request scripts 预请求脚本是在 API 请求之前执行的脚本，我们可以临时更改请求的某些变量。一般预请求脚本有这么两种常见的应用场景。(1)设置动态请求头信息。 (2)设置动态请求参数信息。比如，当我们要请求一个与时间有关的资源时，我们可以在预请求脚本中添加 timestamp 字段，这是一个动态值，我们可以通过前置请求脚本来实现。\n举例说明：比如我们要在 header 中包含一个时间戳，我们可以这样操作\n在 Pre-request scripts 中添加获取时间戳的代码 pm.environment.set(\u0026#34;TimeStampHeader\u0026#34;,new Date()); 在 header 中添加预脚本中的变量 TimeStampHeader 当请求时，Postman 会先执行预脚本获取时间戳，然后再将时间戳赋予到 header 中 timestamp 值中。 接着我们来执行这条 GET 请求，打开控制控制台，在控制台中，可以看到 Request Headers 中包含我们刚刚设置的时间戳 「timestamp」特别提示：有关控制台的讲解，在本教程第14节。 附：常用的 Pre-request scripts ：\n获取变量\n//通用语法 postman.getGlobalVariable(\u0026#34;key\u0026#34;); //获取全局变量 postman.getEnvironmentVariable(\u0026#34;key\u0026#34;); //获取环境变量 //postman native app 特有语法 pm.globals.get(\u0026#34;key\u0026#34;); //获取全局变量 pm.environment.get(\u0026#34;key\u0026#34;); //获取环境变量 设置变量\n//通用语法 postman.setGlobalVariable(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置全局变量 postman.setEnvironmentVariable(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置环境变量 //postman native app 特有语法 pm.globals.get(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置全局变量 pm.environment.get(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置环境变量 清除变量\n//通用语法 postman.clearGlobalVariable(\u0026#34;key\u0026#34;); //清除全局变量 postman.clearEnvironmentVariable(\u0026#34;key\u0026#34;); //清除环境变量 //postman native app 特有语法 pm.globals.unset(\u0026#34;key\u0026#34;); //清除全局变量 pm.environment.unset(\u0026#34;key\u0026#34;); //清除环境变量 将数组、嵌套对象存储到全局\u0026amp;环境变量中\n//将数组储存到环境变量中 var array = [1, 2, 3, 4]; postman.setEnvironmentVariable(\u0026#34;array\u0026#34;, JSON.stringify(array)); //将嵌套对象储存到环境变量中 var obj = { a: [1, 2, 3, 4], b: { c: \u0026#39;val\u0026#39; } }; postman.setEnvironmentVariable(\u0026#34;obj\u0026#34;, JSON.stringify(obj)); //从环境变量中获取数组对象 var array = JSON.parse(postman.getEnvironmentVariable(\u0026#34;array\u0026#34;)); //从环境变量中获取嵌套对象/json对象 var obj = JSON.parse(postman.getEnvironmentVariable(\u0026#34;obj\u0026#34;)); 如何创建 Postman Tests 测试脚本 - Postman 断言功能 在 Postman 中 Pre-request 和 Tests 是两兄弟，一个是在调用前执行（Pre-request），一个是在调用后执行（Tests），我们可以在 Tests 中使用 JavaScript 校验代码协助我们验证结果，可以说 Tests 是 Postman 的断言功能\nPostman Tests 断言的实际应用 Postman 状态类断言 1.我们首先创建一个 GET 请求，然后点击 Postman 中 Tests 标签，进入断言设置。\n2.我们可以在右侧已经预设好的断言代码，我们先点击「Status code: Code is 200」，可以看到预设的代码直接写入编辑框。这段代码的意思是，如果执行调用，服务器返回响应代码为 200 时，判断为 PASS 即调用成功。\n3.点击「Send」执行 GET 请求，返回的断言可以在 Test Results 中看到结果。\n4.绿色的 PASS，说明服务器返回的响应代码为 200 ，调用成功。\nPostman 结果比较类断言 我们再添加一条带有变量的 JavaScript 断言设置，比较预期结果和实际返回结果之间是否一致。\n我们刚刚 GET 请求了 ID 2312 的用户信息，其中 name 的值为 kalacloud\n那么我们接下来写一个 JS 判断预期与返回结果是否一致。即预期为 name 的值为「kalacloud」，写断言自动判断返回结果的name值是否也是「kalacloud」\n1.在 Tests 选项卡右侧选择「Response body:JSON value check」，我们来检测 ID 为 2312 的返回值中，name 的值是否为 kalacloud\n2.我们将「Your Test Name」替换为「检查 ID 为 2312 的 name 返回值为 kalacloud」让这条测试的名字直接反应出我们想测试的内容。\n3.使用\njsonData.data[0].name 代替jsonData.value ，即检测第一个返回值中的 name 的 value\n4.检测返回值：在 to.eql() 中输入待检测值 \u0026quot;kalacloud\u0026quot;，即需要检测的 text。\n5.代码如下，你可以复制并根据你的情况简单修改，然后在 Postman 中，跟随教程一起测试。\n特别注意：这里的 ID = 2312 是我这里的情况，你需要根据你的情况进行相应修改。\npm.test(\u0026#34;Status code is 200\u0026#34;, function () { pm.response.to.have.status(200); }); pm.test(\u0026#34;检查 ID 为 2312 的 name 返回值为 kalacloud\u0026#34;, function () { var jsonData = pm.response.json(); pm.expect(jsonData.data[0].name).to.eql(\u0026#34;kalacloud\u0026#34;); }); 如何在 Postman 中使用控制台 控制台可以非常直观的显示当前调用的一系列信息，我们可以在「菜单 → view → Show Postman Console」或者点击 Postman 左下角的「Console」图标，打开控制台。\n我们可以在 Tests 测试脚本中加入 console.log 来显示我们需要在控制台显示的调用信息。\n如上图，我们在 Test 脚本中加入以下代码\nconsole.log(\u0026#34;本次测试 id 值为\u0026#34;,pm.variables.get(\u0026#34;kalacloud_id\u0026#34;)); 可以显示隐藏在变量下面的具体变量值，方便我们测试时，进行相应的判断。\n如何使用 Runner 批量执行测试，批量更换变量测试 当我们有一组 API 且这一组之间相互关联的关系，使用手动测试效率非常低。这时，我们就要用到 Postman 的批量执行（Runner）功能，Runner 不仅可以批量执行 API 调用，还可以批量更换变量。掌握此方法，大幅度提升 API 测试效率。\n打开你的 Postman ，跟随本教程一起操作一遍吧。\n本次批量 API 测试，我们先导入一个 CSV 文件，文件中包含四组等待新建的用户信息，将 CSV 文件导入 Runner 中待用。 新建 POST 调用页，在 Body 里写上创建用户所需信息，所有值使用变量替代，这些变量将从 CSV 中读取。 新建 GET 调用页，使用 email 作为查询 KEY 进行查询，如果上一步 POST 执行成功，那么 GET 就能成功查询到新建用户对应的 email，查询到表示 POST 创建成功。 在「卡拉云_kalacloud.com_批量测试」这个集合中设置 Tests 中设置全局断言，每当一个调用执行完毕时，进行 Tests 一次判断。 pm.test(\u0026#34;Status code is 200\u0026#34;, function () { pm.response.to.have.status(200); }); 打开「卡拉云_kalacloud.com_批量测试」合集的「Run Collection」的设置页 Iterations：这是测试组，我们 CSV 文件中有 4 组测试条目 Delay：延迟，一般填 2000 毫秒，太密集的请求，容易被服务器拒绝 Data：这里选择我们刚刚的 CSV 文件：kalacloud_users.csv 导入测试数据 点击 RUN 蓝色按钮开始执行批量测试 从上图可以看到，Postman 按顺序提交了 POST 请求和 GET 请求，并连续测试了从 CSV 文件导入的 4 组数据。一键批量测试，相当高效。\n","date":"2022-08-04T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/test/","title":"测试接口"},{"content":"购买配件 配件 用途 mq2 pro 续航版 提升头戴舒适度，可以按照自己需要选择没有续航的 磁吸镜片 近视适用 USB3.0串流线 玩steam的游戏需要和电脑串流 网络 国内quest2用户应该已经具备上外网的条件，不再赘述。\nquest2需要无线网络链接，解决网络问题一般有以下方式：\n软路由openwrt 刷路由器，这个方式比较直接，我认为日常不适用的场景较多，所以我没用。 电脑开个VMware虚拟机安装OpenWrt,有点麻烦。参考文章 电脑热点，下文介绍。 sstap方法(推荐)\n打开科学上网，注意用全局模式并且允许局域网连接。\n下载sstap，我使用的1.0.9.9版本。\n配置并打开sstap 打开热点，并打开 网络和Internet设置 -\u0026gt; 更改适配器选项 -\u0026gt; 右键 SSTAP 1 -\u0026gt; 属性 -\u0026gt; 共享 ，然后就可以连热点了。 TUN模式方法\n如果你的电脑同时网线和无线网卡，clash和v2rayN的TUN模式开热点应该也可以。\n注册，接受邀请领取30美金奖励 使用outlook、gmail等邮箱和原生ip至少提前1天注册facebook账号。\n接受邀请比较麻烦（实际上大多玩家只玩破解版，无需受邀，无需此步骤！），有需要直接去找别人代操作受邀！！以下方式成本过高，作为邀请别人的参考！\n注意：接受邀请也是高风险的操作，由于变换ip和账号资料不完善，依然有可能封号\n我试了多地vps，原生ip也全都出现Ineligible Country​，原因是服务器厂商用的数据中心ip（type是hosting），会被识别屏蔽。所以要用住宅代理（type是isp），由于成本高，服务器厂商几乎不用，只有代理厂商的住宅代理和部分静态住宅代理才可以接受邀请。我搜索了多家代理厂商，价格便宜的只有 911s5 和 iproyal\n代理厂商 特点 价格 911s5 自有软件，pc端指定软件代理，使用简单，ip质量差，部分可以邀请使用 最低28美元/150ip，每ip可用24小时 iproyal 直接给地址端口和用户，所以在国内必须自己搭建国外节点并且中转才能使用，但是ip质量较好、使用舒适。必须实名，不实名很多网站不能访问（包括facebook），而且实名较为耗时 3美元/GB ，paypal入金最低20美元 “以xui为例的中转配置文件”\r// 直接修改\u0026#34;servers\u0026#34;即可使用 { \u0026#34;api\u0026#34;: { \u0026#34;services\u0026#34;: [ \u0026#34;HandlerService\u0026#34;, \u0026#34;LoggerService\u0026#34;, \u0026#34;StatsService\u0026#34; ], \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 62789, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;Socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;proxy.iproyal.com\u0026#34;, \u0026#34;port\u0026#34;: 12325, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34; }, { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: {} }, { \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;blocked\u0026#34; } ], \u0026#34;policy\u0026#34;: { \u0026#34;system\u0026#34;: { \u0026#34;statsInboundDownlink\u0026#34;: true, \u0026#34;statsInboundUplink\u0026#34;: true } }, \u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;inbound-12325\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;ip2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, \u0026#34;protocol\u0026#34;: [ \u0026#34;bittorrent\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;stats\u0026#34;: {} } // 配置文件详解 { \u0026#34;api\u0026#34;: { // api: 提供了一些 API 接口供远程调用 \u0026#34;services\u0026#34;: [ // services: [string] 开启的 API 列表 \u0026#34;HandlerService\u0026#34;, // HandlerService:添加、删除一个入站、出站代理在一个入站代理中添加、删除一个用户 \u0026#34;LoggerService\u0026#34;, // 内置Logger \u0026#34;StatsService\u0026#34; // 内置的数据统计服务 ], \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; // tag: string api中的tag是**出站**代理标识 }, \u0026#34;inbounds\u0026#34;: [ // 入站 -\u0026gt; 路由 不用修改 { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 62789, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, // 任意门,可以监听一个本地端口 \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ], \u0026#34;outbounds\u0026#34;: [ // 出站 ##################此处开始添加################## { // 添加出站节点 \u0026#34;protocol\u0026#34;: \u0026#34;Socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 12325, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34; }, #################此处结束添加################### { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, // 向任意网络发送（正常的）TCP 或 UDP 数据 \u0026#34;settings\u0026#34;: {} }, { \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, // 禁止访问 \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;blocked\u0026#34; } ], \u0026#34;policy\u0026#34;: { \u0026#34;system\u0026#34;: { \u0026#34;statsInboundDownlink\u0026#34;: true, \u0026#34;statsInboundUplink\u0026#34;: true } }, \u0026#34;routing\u0026#34;: { // 路由 -\u0026gt; 出站 \u0026#34;rules\u0026#34;: [ ##################此处开始添加################## { // 添加路由，xui的\u0026#34;inboundTag\u0026#34;规则是\u0026#34;inbound-port\u0026#34; \u0026#34;inboundTag\u0026#34;: [ \u0026#34;inbound-12325\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;ip2\u0026#34;, // -\u0026gt; \u0026#34;outbounds\u0026#34;: {\u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34;} \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, #################此处结束添加################### { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, // -\u0026gt; \u0026#34;api\u0026#34;: {\u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34;} \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, // -\u0026gt; 禁止访问 \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, // -\u0026gt; 禁止访问 \u0026#34;protocol\u0026#34;: [ \u0026#34;bittorrent\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;stats\u0026#34;: {} } 激活 下载Oculus App，quest2联网后配对，配对成功就说明Quest2激活成功了。\n安装第三方应用 便携方式 87vr助手安装热门游戏和应用，安卓apk可以通过QQ发送直接安装。 更多破解应用可以看看极客VR（1元注册）、VR魔趣网。\n常规方式 首先需要开启开发者模式。在Oculus开发者网站创建一个开发者组织，再去Oculus APP菜单 -\u0026gt; 设备 -\u0026gt; 开发者模式 -\u0026gt; 打开 。 下载SideQuest并安装。 下载Oculus ADB驱动。右键单击android_winusb.inf选择“安装”。然后用USB线将头显和电脑连接起来，在头显中点击“允许”。 然后就可以安装apk了。 如果apk附带文件夹，就拖入obb文件夹。 进入头显的未知来源就可以使用了。 SKYBOX 《SkyBox VR》是最优秀的vr视频播放器，而且可以使用本地网络播放电脑上的影片。\nvr影片体积超过10G的很常见，quest2装不了多少，所以放在pc，局域网共享。\n电脑设置开启共享。 无密码的共享 有密码的共享，找到用户名和改密码 共享存放影片的文件夹。(以后删除共享点击图一的“删除访问”) 去quest2 SKYBOX 本地网络查看。 常见问题 恢复出厂设置 手机配对后在app菜单 -\u0026gt; 设备 -\u0026gt; 高级设置 -\u0026gt; 恢复出场设置\n登陆Oculus官网 -\u0026gt; 点头像 -\u0026gt; Oculus settings -\u0026gt; Devices DELETE -\u0026gt; DEVICE DATA\n截图 按住右手柄Oculus Home键（椭圆键） + 扳机按键（食指键）\n","date":"2022-05-14T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/quest2/","title":"quest2入门使用汇总"},{"content":"安装 安装 JDK 下载地址\n安装配置Android Studio 下载地址\nflutter(windows) flutter安装\nset PUB_HOSTED_URL=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/dart-pub\u0026#34; #配置国内镜像 set FLUTTER_STORAGE_BASE_URL=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/flutter\u0026#34; 配置环境变量path Dart: 无需配置，flutter现在自带dart。\nFlutter: C:\\flutter\\bin\nJava: C:\\Program Files\\Java\\jdk1.8.0_281\\bin\nAndroid SDK Tools:C:\\Users{username}\\AppData\\Local\\Android\\sdk\\tools\nAndroid SDK Platform-Tools:C:\\Users{username}\\AppData\\Local\\Android\\sdk\\platform-tools\n创建 Flutter 项目 故障排除 配置 配置build.gradle(project:android) allprojects { repositories { google() jcenter() maven { url \u0026#34;https://storage.googleapis.com/download.flutter.io\u0026#34; } } } 更新 flutter flutter upgrade flutter doctor 运行项目报错 常见错误\n更新Android Studio 重新建项目 \\android\\app\\build.gradle compileSdkVersion 33 minSdkVersion 21 其他错误\nAttribute application@label value=(Dormitory) from AndroidManifest.xml 解决：进入\\android\\app\\src\\main\\AndroidManifest.xml\n\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; // 添加此行 package=\u0026#34;com.example.model_dev\u0026#34;\u0026gt; \u0026lt;application tools:replace=\u0026#34;android:label\u0026#34; // 添加此行 android:label=\u0026#34;model_dev\u0026#34; android:name=\u0026#34;${applicationName}\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34;\u0026gt; \u0026lt;activity Gradle threw an error while downloading artifacts from the network 解决：Gradle损坏，进入 C:\\Users\\username 删除 .gradle 文件夹\ndart 变量 # 创建一个变量并将其初始化 var name = \u0026#39;Bob\u0026#39;; # 指定类型 String name = \u0026#39;Bob\u0026#39;; # 如果对象(name)不局限于单一的类型(String),可以将其指定为 Object（或 dynamic）类型 Object name = \u0026#39;Bob\u0026#39;; ? 可空类型 int? a=123; // int? 表示a是一个可空类型 ! 类型断言 a! // a不为空 常量 final 和 const final在被使用到的时候才会进行初始化, 如果只是被定义, 而没有被使用到, 那么这个变量一直没有被初始化 (\u0026lsquo;懒加载\u0026rsquo;); 而const修饰的变量, 一经定义就会在编译期间对其进行初始化\nfinal name = \u0026#39;Bob\u0026#39;; // Without a type annotation final String nickname = \u0026#39;Bobby\u0026#39;; 类型 内置类型 int 整数值 double 浮点数字 String 字符串 bool 布尔类型 List 集合类型 Map 字典型 不常用类型 enum　枚举类型,用于表示固定数量的常量值。在switch语句中运行良好。\nObject　对象类型，允许任何类型。\ndynamic　动态类型，不仅接受所有对象，而且还允许所有操作\nvoid main() { dynamic foo=\u0026#34;bar\u0026#34;; print(foo); foo=123; print(foo); } Set　无序集合，主要的功能就是去除数组重复内容 void main(){ List myList=[\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;,\u0026#39;西瓜\u0026#39;,\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;,\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;]; var s=new Set(); s.addAll(myList); print(s); print(s.toList()); } 几乎不用的类型 runes 暴露了字符串的 Unicode 代码点（Unicode 为每个字母、数字和符号定义了一个唯一的数值）。例如，用于表情符号，(😆) 是\\u{1f606}。\nSymbol 表示标识符，例如#。\nvoid main() { assert(Symbol(\u0026#39;bar\u0026#39;)==#bar); } // true 类型转换 String -\u0026gt; int myint = int.parse(myString); String -\u0026gt; double mydouble = double.parse(myString); int -\u0026gt; String myString = myint.toString(); double -\u0026gt; String myString = 3.14159.toStringAsFixed(2); // myString = \u0026#39;3.14\u0026#39; 将 list 映射为 widget List MyList.map((item) =\u0026gt; SomeWidget(item)).toList(); 函数 bool isNoble(int atomicNumber) { // bool:返回类型 return _nobleGases[atomicNumber] != null; } 箭头函数 =\u0026gt;\n=\u0026gt; expr 是 { return expr; }的简写\n参数 命名参数（可传可不传） String printUserInfo(String username, {int age = 0, String sex = \u0026#39;男\u0026#39;}) {//行参，用大括号 if (age != 0) { return \u0026#34;姓名:$username---性别:$sex--年龄:$age\u0026#34;; } return \u0026#34;姓名:$username---性别:$sex--年龄保密\u0026#34;; } print(printUserInfo(\u0026#39;张三\u0026#39;)); //实参 print(printUserInfo(\u0026#39;张三\u0026#39;, age: 20, sex: \u0026#39;未知\u0026#39;)); //实参,命名参数的实参必须传入参数名age: sex: 位置参数（可传可不传） String printUserInfo(String username,[String sex=\u0026#39;男\u0026#39;,int age=0]){ //行参，用中括号 if(age!=0){ return \u0026#34;姓名:$username---性别:$sex--年龄:$age\u0026#34;; } return \u0026#34;姓名:$username---性别:$sex--年龄保密\u0026#34;; } print(printUserInfo(\u0026#39;张三\u0026#39;)); //实参 print(printUserInfo(\u0026#39;小李\u0026#39;,\u0026#39;女\u0026#39;,30)); //实参 运算符 算术运算符\n+(加)　–(减)　-(负)　*(乘)　/(除)　~/(取整)　%（取余）\n关系运算符\n==　！=　\u0026gt;　\u0026lt;　\u0026gt;=　\u0026lt;=\n逻辑运算符\n!(取反)　\u0026amp;\u0026amp;(与)　||(或)\n赋值运算符\n基础赋值运算符　=　??=(为 null 的变量赋值)\n复合赋值运算符　+=　-=　*=　/=　%=　~/=\n其他运算符 ()　使用一个方法\n[]　访问 List\n?[]　访问 List,左侧/?表示可以为null\n.　访问成员\n?.　访问成员,左侧/?表示可以为null\n.. 级联，可以在同一个对象上访问实例成员和调用多个实例方法\nif-else的表达式：\ncondition ? expr1 : expr2 如果条件为真，则计算expr1（并返回其值）；否则，计算并返回expr2的值。\nexpr1 ?? expr2 如果expr1不为 null，则返回其值；否则，计算并返回expr2的值。\n类 方法 实例变量和方法 实例变量:\nclass Point { double? x; // Declare instance variable x, initially null. double? y; // Declare y, initially null. double z = 0; // Declare z, initially 0. } 实例方法可以访问实例变量和 this\nimport \u0026#39;dart:math\u0026#39;; class Point { final double x; final double y; Point(this.x, this.y); double distanceTo(Point other) { var dx = x - other.x; var dy = y - other.y; return sqrt(dx * dx + dy * dy); } } 静态变量和方法 使用关键字 static 可以声明类变量或类方法。静态成员可以通过类名称直接访问（不需要实例化），提高性能。静态方法不能访问非静态成员，非静态方法可以访问静态成员，不能使用this关键字。\nget 和 set 特殊方法:实例对象的每一个属性都有一个隐式的 Getter 方法，非 final 属性还会有一个 Setter 方法。 通过get和set修饰的方法不带小括号，可以使访问方法像访问属性一样，简便我们的使用。访问 set：传入属性，get：访问属性。 class Rectangle { double left, top, width, height; Rectangle(this.left, this.top, this.width, this.height); // Define two calculated properties: right and bottom. double get right =\u0026gt; left + width; set right(double value) =\u0026gt; left = value - width; double get bottom =\u0026gt; top + height; set bottom(double value) =\u0026gt; top = value - height; } 抽象类、抽象方法 抽象类常用于定义接口，抽象类常常会包含抽象方法\nabstract class Doer { // Define instance variables and methods... void doSomething(); // Define an abstract method. } class EffectiveDoer extends Doer { void doSomething() { // Provide an implementation, so the method is not abstract here... } } 构造函数 特点： 实例化类时会被自动触发\n一般用于初始化操作\n没有返回值\n普通构造函数 构造函数方法名和类名相同\nclass Point { num x, y; Point(num x, num y) { // There\u0026#39;s a better way to do this, stay tuned. this.x = x; this.y = y; } } 简化形式：\nclass Point { num x, y; // Syntactic sugar for setting x and y // before the constructor body runs. Point(this.x, this.y); } 命名构造函数 命名构造函数(类名.函数名)可以实现多个构造器。\nclass Point { num x, y; Point(this.x, this.y); // 命名构造函数 Point.origin() { x = 0; y = 0; } } 请记住，命名构造函数不可继承，如果子类想要有 和父类一样的命名构造函数，那就写个同名的（通常也会在子类的命名构造函数里，调用父类的同名命名构造函数）\n调用父类构造函数 如果你的类，继承于父类，那么子类的构造函数，势必要调用父类的构造函数，这时候就要分两种情况：\nDart语言帮你调用父类的无参数构造函数 代码中显式调用父类的构造函数 默认调用调用父类的无参数构造函数 如果你没有显式调用父类的构造函数，并且父类有一个无参数构造函数，那么Dart就会帮你在子类的构造函数方法体的最前面，调用父类的无参数构造函数。当然，后面我们会说道，构造函数分成好几部分来初始化成员变量，调用的顺序如下：\n初始化列表 父类的无参数构造函数 子类的无参数构造函数 当然，如果父类没有无参数构造函数，或者Dart这种隐式调用无法满足你的要求，那就需要显式调用父类的构造函数了\n显式调用父类构造函数 显式调用父类构造函数，应该在初始化列表中完成\nclass Person { String firstName; Person.fromJson(Map data) { print(\u0026#39;in Person\u0026#39;); } } class Employee extends Person { // Person does not have a default constructor; // you must call super.fromJson(data). Employee.fromJson(Map data) : super.fromJson(data) { print(\u0026#39;in Employee\u0026#39;); } } main() { var emp = new Employee.fromJson({}); // Prints: // in Person // in Employee } 初始化列表 在构造函数后加上: x = , y = 可以在构造函数中设置属性的默认值\n在构造函数体执行之前执行\n可以调用超类的构造函数\n// Initializer list sets instance variables before // the constructor body runs. Point.fromJson(Map\u0026lt;String, num\u0026gt; json) : x = json[\u0026#39;x\u0026#39;], y = json[\u0026#39;y\u0026#39;] { print(\u0026#39;In Point.fromJson(): ($x, $y)\u0026#39;); } 尤其是初始化那些final修饰的成员变量时，初始化列表很有用，因为在方法体中，不能给final修饰的成员变量赋值，因为在执行方法体的时候，final修饰的成员变量已经不能变了。这个地方很多人犯错。\nimport \u0026#39;dart:math\u0026#39;; class Point { final num x; final num y; final num distanceFromOrigin; Point(x, y) : x = x, y = y, distanceFromOrigin = sqrt(x * x + y * y); } main() { var p = new Point(2, 3); print(p.distanceFromOrigin); } 重定向构造函数 定义构造函数的时候，除了一个普通构造函数，还可以有若干命名构造函数，这些构造函数之间，有时候会有一些相同的逻辑，如果分别书写在各个构造函数中，会有些多余，所以构造函数可以传递。\nclass Point { num x, y; // The main constructor for this class. Point(this.x, this.y); // Delegates to the main constructor. Point.alongXAxis(num x) : this(x, 0); } 传递构造函数，没有方法体，会在初始化列表中，调用另一个构造函数。\n常量构造函数 class ImmutablePoint { static final ImmutablePoint origin = const ImmutablePoint(0, 0); final num x, y; const ImmutablePoint(this.x, this.y); } 如果你的类，创建的对象永远不会改变，你可以在编译期就创建这个常量实例，并且定义一个常量构造函数，并且确保所有的成员变量都是final的。\n工厂构造函数/单例模式 在构造函数前加上factory\n只实例化一次，节省相同实例化带来的消耗\n第一次调用命名构造函数进入工厂函数中实例化，后续调用就用缓存中现成的实例\n工厂构造函数，没有权利访问this\nclass Logger { final String name; bool mute = false; // _cache is library-private, thanks to // the _ in front of its name. static final Map\u0026lt;String, Logger\u0026gt; _cache = \u0026lt;String, Logger\u0026gt;{}; factory Logger(String name) { if (_cache.containsKey(name)) { return _cache[name]; } else { final logger = Logger._internal(name); # 调用构造函数 _cache[name] = logger; return logger; } } Logger._internal(this.name); # 定义命名构造函数 void log(String msg) { if (!mute) print(msg); } } main() { var logger = Logger(\u0026#39;UI\u0026#39;); logger.log(\u0026#39;Button clicked\u0026#39;); } 上例的意思是，类中又一个静态缓存_cache保存着一些Logger类实例，创建实例时，给工厂构造函数传递的name，如果在缓存中已经存在，就用缓存中现成的实例，如果没有，就新建一个实例，并且也放到缓存中。\n如此，我们可以创建名字为UI / SYS / API 等的实例，然后在debug的时候，如果设置名字为UI的Logger实例的mute为true，就不会打印UI相关的log，而不影响其它两个名字的log。\n回调函数 回调函数本质上是把函数作为参数传递给小部件的函数，当按钮按下时调用此函数。\nimport \u0026#39;package:flutter/material.dart\u0026#39;; void main() { runApp(const MyApp()); } class MyApp extends StatefulWidget { const MyApp({Key? key}) : super(key: key); @override State\u0026lt;MyApp\u0026gt; createState() =\u0026gt; _MyAppState(); } class _MyAppState extends State\u0026lt;MyApp\u0026gt; { String topic = \u0026#34;Packages\u0026#34;; callback(varTopic) { // setState:通知内部状态已更改从而重建UI setState(() { topic = varTopic; }); } @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: AppBar( title: const Text(\u0026#34;Learning Flutter\u0026#34;), ), body: Column( children: [ Container( width: double.maxFinite, height: 70, margin: const EdgeInsets.only( top: 50, left: 40, right: 40, bottom: 20), decoration: BoxDecoration( color: Colors.lightBlue, borderRadius: BorderRadius.circular(20)), child: Center( child: Text( \u0026#34;We are learning Flutter $topic\u0026#34;, style: const TextStyle(fontSize: 20, color: Colors.white), ), ), ), MyButtons(topic: \u0026#34;Cubit\u0026#34;, callbackFunction: callback), MyButtons(topic: \u0026#34;BLoc\u0026#34;, callbackFunction: callback), MyButtons(topic: \u0026#34;GetX\u0026#34;, callbackFunction: callback) ], ), ), ); } } class MyButtons extends StatelessWidget { final String topic; final Function callbackFunction; const MyButtons( {Key? key, required this.topic, required this.callbackFunction}) : super(key: key); @override Widget build(BuildContext context) { return GestureDetector( onTap: () { callbackFunction(topic); }, child: Container( width: double.maxFinite, height: 70, margin: const EdgeInsets.only(top: 20, left: 40, right: 40, bottom: 20), decoration: BoxDecoration( color: Colors.lightBlue, borderRadius: BorderRadius.circular(20)), child: Center( child: Text( topic, style: const TextStyle(fontSize: 20, color: Colors.white), ), ), ), ); } } 扩展 扩展类 extends Extends是典型的OOP类继承。如果 a类 扩展了 b类，则 a类 可以使用或覆盖 b类 中实现的所有属性、变量、函数 。在 Dart 中，一个类只能扩展一个类。 implements 创建另一个类或接口的实现。当 a类 实现 b类 时，必须实现 b类 中定义的所有功能(所有属性、变量、函数)。一个类可以实现多个接口。\nwith mixin使用with关键字，类似于继承，可以扩展多个类。mixins的类只能继承自Object，不能再继承其他类，且不能有构造函数。\n# extends只能扩展一个类，而mixin没有限制，可以一起使用 class Maestro extends Person with Musical, Aggressive, Demented { Maestro(String maestroName) { name = maestroName; canConduct = true; } } super super关键字用于调用父类的对象、方法、构造函数和子类中的属性。\n// 访问父类变量 super.variable_name; // 访问父类方法 super.method_name(); // 转发给超类的构造函数 const MyApp({Key? key}) : super(key: key); 扩展方法 // 扩展 num，就可以使用 num.attribute 和 num.method extension FancyNum on num { num plus(num other) =\u0026gt; this + other; num times(num other) =\u0026gt; this * other; } print(5.plus(3)); // Equal to \u0026#34;5 + 3\u0026#34;. print(5.times(8)); // Equal to \u0026#34;5 * 8\u0026#34;. print(2.plus(1).times(3)); // Equal to \u0026#34;(2 + 1) * 3\u0026#34;. 泛型 泛型常用于需要要求类型安全的情况，可以减少代码重复。 如果 T 是一个class，则表示传入该类型的参数。\n@override 注解来表示你重写了一个成员 异步 // 示例：等待返回自己ip import \u0026#39;package:http/http.dart\u0026#39;as http; import \u0026#39;dart:convert\u0026#39;; Future getIPAddress() async { final url =\u0026#39;https://httpbin.org/ip\u0026#39;; var response = await http.get(Uri.parse(url)); String ip = json.decode(response.body)[\u0026#39;origin\u0026#39;]; return ip; } void main() async { final ip = await getIPAddress(); print(ip); } flutter Widget生命周期 StatelessWidget生命周期源码图 Flutter 中万物皆为Widget，widget类继承自DiagnosticableTree。\nDiagnosticableTree即“诊断树”，主要作用是提供调试信息。\nWidget.createElement() :创建一个Element实例，记为element。\nKey: [Key]是[Widget]、[Element]和[SemanticsNode]的标识符。Key可以保持组件之前的状态，比如在用户滑动时或者修改集合时，决定的条件在canUpdate()方法中。\ncanUpdate(...): newWidget与oldWidget的runtimeType和key同时相等时就会用new widget去更新Element对象的配置，否则就会创建新的Element。\ncreateState():为每一个StatefulElement创建一个State实例。\nelement.mount() :调用createRenderObject创建RenderObject，并使用attachRenderObject将RenderObject关联到Element上。\nStatefulWidget更为复杂，使用Getx接管更好用，不再详解。\nGetx 状态管理 介绍 分类 状态管理器 消耗RAM 结论 简单的状态管理 GetBuilder 最少 性能最好，最常用 反应式状态管理 Obx 较少 反应式的基础层，较Getx简洁 GetX 较多 可以灵活使用的反应式，较Obx实用 混合态管理 MixinBuilder 最多 在GetBuilder中插入一个Obx，既可以响应式更新、也可以手动更新 使用场景： Obx\n当我的控制器已经在其他地方注册 最少的代码/噪音 反应式小部件，自动刷新，不用update() 监听多个GetXController的状态改变 GetX\n当我的控制器尚未注册 我想非常明确/明显地使用哪个控制器 我需要initState在创建过程中进行一些调用 反应式小部件，自动刷新，不用update() 只更新某个小组件的状态，只重建特定组件，性能更好 GetBuilder\n我想手动决定何时重建小部件 我有几个状态变量，可以作为一个组一起刷新 需要update()手动刷新 更新几乎整个页面或几乎所有的变量，性能更好 Controller Getx状态管理的代码结构都可以分为GetXController（控制器层）和view（界面层），GetXController 可以进一步分为state（状态层/变量层），logic（逻辑层）。\n└── sinup ├── controller.dart ├── view.dart └── login ├── logic.dart ├── state.dart ├── view.dart 生命周期 在 StatefulWidget 中，使用initState或dispose()，而在 Controller 中我们可以使用相对应的操作：\nonStart（开始）[不可覆盖]：组件在内存分配的时间点就会被调用，完成后会调用onInit方法 onInit（初始化）：组件在内存分配后会被马上调用，适用于初始化 Controller（例如一些成员属性的初始化），详见Workers小节 onReady（加载完成）：在 onInit 一帧后被调用，适合做一些导航进入的事件（例如对话框提示、SnackBar）或异步网络请求 onClose（控制器被释放）：在 onDelete 方法前调用、用于销毁 controller 使用的资源（例如关闭事件监听，关闭流对象、动画）或者销毁可能造成内存泄露的对象（例如 TextEditingController，AniamtionController）。也适用于将数据进行离线持久化。 onDelete（删除）[不可覆盖]：在 controller销毁前调用，将控制器从内存中删除 反应状态管理 反应变量 使用反应状态管理需要声明反应变量，你有3种方法可以把一个变量变成是 \u0026ldquo;可观察的\u0026rdquo;。\n1 - 第一种是使用 Rx{Type}。\n// 建议使用初始值，但不是强制性的 final name = RxString(\u0026#39;\u0026#39;); final isLogged = RxBool(false); final count = RxInt(0); final balance = RxDouble(0.0); final items = RxList\u0026lt;String\u0026gt;([]); final myMap = RxMap\u0026lt;String, int\u0026gt;({}); 2 - 第二种是使用 Rx，规定泛型 Rx\u0026lt;Type\u0026gt;。\nfinal name = Rx\u0026lt;String\u0026gt;(\u0026#39;\u0026#39;); final isLogged = Rx\u0026lt;Bool\u0026gt;(false); final count = Rx\u0026lt;Int\u0026gt;(0); final balance = Rx\u0026lt;Double\u0026gt;(0.0); final number = Rx\u0026lt;Num\u0026gt;(0) final items = Rx\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;([]); final myMap = Rx\u0026lt;Map\u0026lt;String, int\u0026gt;\u0026gt;({}); // 自定义类 - 可以是任何类 final user = Rx\u0026lt;User\u0026gt;(); 3 - 第三种更实用、更简单和首选的方法，只需添加 .obs 作为value的属性。\nfinal name = \u0026#39;\u0026#39;.obs; final isLogged = false.obs; final count = 0.obs; final balance = 0.0.obs; final number = 0.obs; final items = \u0026lt;String\u0026gt;[].obs; final myMap = \u0026lt;String, int\u0026gt;{}.obs; // 自定义类 - 可以是任何class, literally final user = User().obs; 使用value // controller final count1 = 0.obs; final count2 = 0.obs; int get sum =\u0026gt; count1.value + count2.value; // 由于.obs把变量换成`Rx{Type}`类型，所以需要用.value取值 // 视图 GetX\u0026lt;Controller\u0026gt;( builder: (controller) { print(\u0026#34;count 1 rebuild\u0026#34;); return Text(\u0026#39;${controller.count1.value}\u0026#39;); }, ), GetX\u0026lt;Controller\u0026gt;( builder: (controller) { print(\u0026#34;count 2 rebuild\u0026#34;); return Text(\u0026#39;${controller.count2.value}\u0026#39;); }, ), GetX\u0026lt;Controller\u0026gt;( builder: (controller) { print(\u0026#34;count 3 rebuild\u0026#34;); return Text(\u0026#39;${controller.sum}\u0026#39;); }, ), Obx class StateObxView extends StatelessWidget { StateObxView({Key? key}) : super(key: key); final count = 0.obs; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\u0026#34;Obx(...)\u0026#34;), ), body: Center( child: Column( children: [ Obx(() =\u0026gt; Text(\u0026#34;count1 -\u0026gt; \u0026#34; + count.toString())), Obx(() =\u0026gt; Text(\u0026#34;count2 -\u0026gt; \u0026#34; + count.toString())), // Divider(), ElevatedButton( onPressed: () { count.value++; }, child: Text(\u0026#39;add\u0026#39;), ), ], ), ), ); } } GetX Controller\nclass CountController extends GetxController { final _count = 0.obs; set count(value) =\u0026gt; this._count.value = value; get count =\u0026gt; this._count.value; final _count2 = 0.obs; set count2(value) =\u0026gt; this._count2.value = value; get count2 =\u0026gt; this._count2.value; add() =\u0026gt; _count.value++; add2() =\u0026gt; _count2.value++; } View\nclass StateGetxView extends StatelessWidget { StateGetxView({Key? key}) : super(key: key); final controller = CountController(); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\u0026#34;Getx\u0026#34;), ), body: Center( child: Column( children: [ GetX\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetX - 1\u0026#34;); return Text(\u0026#39;value 1 -\u0026gt; ${_.count}\u0026#39;); }, ), GetX\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetX - 2\u0026#34;); return Text(\u0026#39;value 2 -\u0026gt; ${_.count}\u0026#39;); }, ), Divider(), // GetX\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetX - 3\u0026#34;); return Column( children: [ Text(\u0026#39;value 3 -\u0026gt; ${_.count}\u0026#39;), ElevatedButton( onPressed: () { _.add(); }, child: Text(\u0026#39;count1\u0026#39;), ) ], ); }, ), Divider(), // count2 GetX\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetX - 4\u0026#34;); return Text(\u0026#39;value 4 -\u0026gt; ${_.count2}\u0026#39;); }, ), Divider(), // 按钮 ElevatedButton( onPressed: () { controller.add(); }, child: Text(\u0026#39;count1\u0026#39;), ), ElevatedButton( onPressed: () { controller.add2(); }, child: Text(\u0026#39;count2\u0026#39;), ), ], ), ), ); } } 简单状态管理 GetBuilder Controller同Getx\nView\nclass StateGetBuilderView extends StatelessWidget { StateGetBuilderView({Key? key}) : super(key: key); final controller = CountController(); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\u0026#34;GetBuilder\u0026#34;), ), body: Center( child: Column( children: [ GetBuilder\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 1\u0026#34;); return Text(\u0026#39;value -\u0026gt; ${_.count}\u0026#39;); }, ), GetBuilder\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 2\u0026#34;); return Text(\u0026#39;value -\u0026gt; ${_.count}\u0026#39;); }, ), Divider(), // GetBuilder\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 3\u0026#34;); return Column( children: [ Text(\u0026#39;value -\u0026gt; ${_.count}\u0026#39;), ElevatedButton( onPressed: () { _.add(); }, child: Text(\u0026#39;GetBuilder -\u0026gt; add\u0026#39;), ) ], ); }, ), Divider(), // count2 GetBuilder\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 4\u0026#34;); return Text(\u0026#39;value count2 -\u0026gt; ${_.count2}\u0026#39;); }, ), Divider(), // id2 标记一个 `builder` ，触发方式`controller.update([\u0026#34;id2\u0026#34;]);` ，可传多个 `Array` 类型。 GetBuilder\u0026lt;CountController\u0026gt;( id: \u0026#34;id2\u0026#34;, init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 4\u0026#34;); return Text(\u0026#39;id2 -\u0026gt; value count2 -\u0026gt; ${_.count2}\u0026#39;); }, ), Divider(), // 按钮 ElevatedButton( onPressed: () { controller.add(); }, child: Text(\u0026#39;add\u0026#39;), ), ElevatedButton( onPressed: () { controller.add2(); }, child: Text(\u0026#39;add2\u0026#39;), ), ElevatedButton( onPressed: () { controller.update(); }, child: Text(\u0026#39;controller.update()\u0026#39;), ), ElevatedButton( onPressed: () { controller.update([\u0026#34;id2\u0026#34;]); }, child: Text(\u0026#39;controller.update(id2)\u0026#39;), ), ], ), ), ); } } Workers Workers可以精确控制事件发生时触发回调，常用于Controller的onInit中：\nclass CountController extends GetxController { final _count = 0.obs; set count(value) =\u0026gt; this._count.value = value; get count =\u0026gt; this._count.value; add() =\u0026gt; _count.value++; @override void onInit() { super.onInit(); // 每次_count变化时调用 ever(_count, (value) { print(\u0026#34;ever -\u0026gt; \u0026#34; + value.toString()); }); // 第一次被改变时才会被调用。 once(_count, (value) { print(\u0026#34;once -\u0026gt; \u0026#34; + value.toString()); }); // 防DDos - 每当用户停止输入1秒时调用 debounce( _count, (value) { print(\u0026#34;debounce -\u0026gt; \u0026#34; + value.toString()); }, time: Duration(seconds: 1), ); // 忽略1秒内的所有变化。 interval( _count, (value) { print(\u0026#34;interval -\u0026gt; \u0026#34; + value.toString()); }, time: Duration(seconds: 1), ); } } 路由管理 普通路由 // 导航到新的页面。 Get.to(NextScreen()); // 要导航到下一条路由，并在返回后立即接收或更新数据。 var data = await Get.to(Payment()); // 关闭SnackBars、Dialogs、BottomSheets或任何你通常会用Navigator.pop(context)关闭的东西。 Get.back(); // 在另一个页面上，发送前一个路由的数据。并使用它。 Get.back(result: \u0026#39;success\u0026#39;); if(data == \u0026#39;success\u0026#39;) madeAnything(); // 进入下一个页面，但没有返回上一个页面的选项（用于SplashScreens，登录页面等）。 Get.off(NextScreen()); // 进入下一个界面并取消之前的所有路由（在购物车、投票和测试中很有用）。 Get.offAll(NextScreen()); 别名路由 普通路由管理起来比较麻烦,通常我们使用别名路由。\n// 导航到下一个页面 Get.toNamed(\u0026#34;/NextScreen\u0026#34;); // 传递参数 Get.toNamed(\u0026#34;/NextScreen\u0026#34;, arguments: \u0026#34;Hello\u0026#34;); // 浏览并删除前一个页面。 Get.offNamed(\u0026#34;/NextScreen\u0026#34;); // 浏览并删除所有以前的页面。 Get.offAllNamed(\u0026#34;/NextScreen\u0026#34;); // 动态URL Get.offAllNamed(\u0026#34;/NextScreen?device=phone\u0026amp;id=354\u0026amp;name=Enzo\u0026#34;); 依赖注入 Get.put()： 不使用控制器实例也会被创建\nGet.put(CountController()); Get.lazyPut()： 懒加载方式创建实例，只有在使用时才创建\nGet.lazyPut\u0026lt;CountController\u0026gt;(() =\u0026gt; CountController()); Get.putAsync()： Get.put()的异步版版本\nGet.putAsync\u0026lt;CountController\u0026gt;(() async =\u0026gt; await CountController()); Get.create()： 每次使用都会创建一个新的实例\nGet.find()： 你可以实例化100万个控制器，Get总会找到你所需的控制器\nGet.find\u0026lt;CountController\u0026gt;(); 其他高级 API https://github.com/jonataslaw/getx#other-advanced-apis\ndio 原理 # dio_mixin.dart 文件中 DioMixin 实现了 Dio abstract class DioMixin implements Dio { @override Future\u0026lt;Response\u0026lt;T\u0026gt;\u0026gt; post\u0026lt;T\u0026gt;( String path, { # path： 请求的url链接 data, # data： 请求数据，例如上传用到的FromData Map\u0026lt;String, dynamic\u0026gt;? queryParameters, # data： 请求数据，例如上传用到的FromData Options? options, # queryParameters： 查询参数 CancelToken? cancelToken, # cancelToken： 用来取消发送请求的token ProgressCallback? onSendProgress, # onSendProgress： 网络请求发送的进度 ProgressCallback? onReceiveProgress, # onSendProgress： 网络请求发送的进度 }) { return request\u0026lt;T\u0026gt;( # 返回request方法 path, data: data, options: checkOptions(\u0026#39;POST\u0026#39;, options), queryParameters: queryParameters, cancelToken: cancelToken, onSendProgress: onSendProgress, onReceiveProgress: onReceiveProgress, ); } } get() post() 等调用时，返回request方法，request 方法对请求参数处理，并返回 fetch 方法，fetch 进行响应数据设定、构建请求流、添加拦截器、请求分发。\nWebView WebView是应用内显示网页的功能，查看项目的官网、文档、条款等经常用到。推荐使用flutter_inappwebview，比官方webview_flutter有更丰富的功能和详尽的文档。主要功能：\nInAppWebView：是一个内嵌原生 WebView 小部件，集成到 Flutter 小部件树中。\nContextMenu：WebView 的快捷菜单。例如长按网页文本后的复制。 HeadlessInAppWebView：无头模式下的 WebView。在没有界面或UI的情况下运行WebView。它可以在没有用户界面的情况下执行网页加载和渲染操作，而不需要在用户界面中显示网页，用于后台处理网页数据、自动化测试、网络爬虫等。 InAppBrowser\nInAppBrowser：显示在 Flutter 应用程序顶部的原生 WebView，它没有集成到 Flutter 小部件树中。 ChromeSafariBrowser：Android 上的 Chrome 自定义选项卡和 iOS 上的SFSafariViewController。 InAppLocalhostServer：这个类允许你在 http://localhost:[port] 上创建一个简单的服务器。默认端口值为 8080。能够在本地服务器上缓存 js，html等资产文件，优化加载时间。\nCookieManager：此类实现了一个单例对象（共享实例），该对象管理 WebView 实例使用的 cookie。\nHttpAuthCredentialDatabase：此类实现管理共享 HTTP 身份验证凭据缓存的单例对象（共享实例）。\nWebStorageManager：这个类实现了一个单例对象（共享实例），它管理 WebView 实例使用的 Web 存储。\nService Worker：Service Worker 是 PWA 的基本组成部分。它们支持快速加载（无论网络如何）、离线访问、推送通知和其他功能。\nInAppWebView官方示例注释\rimport \u0026#39;dart:async\u0026#39;; import \u0026#39;package:flutter/foundation.dart\u0026#39;; import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:flutter_inappwebview/flutter_inappwebview.dart\u0026#39;; import \u0026#39;package:url_launcher/url_launcher.dart\u0026#39;; Future main() async { WidgetsFlutterBinding.ensureInitialized(); // 如果是Android，则对加载到 WebView 中的 Web内容（HTML/CSS/JavaScript）启用调试 if (!kIsWeb \u0026amp;\u0026amp; defaultTargetPlatform == TargetPlatform.android) { await InAppWebViewController.setWebContentsDebuggingEnabled(true); } runApp(const MaterialApp(home: MyApp())); } class MyApp extends StatefulWidget { const MyApp({super.key}); @override State\u0026lt;MyApp\u0026gt; createState() =\u0026gt; _MyAppState(); } class _MyAppState extends State\u0026lt;MyApp\u0026gt; { final GlobalKey webViewKey = GlobalKey(); InAppWebViewController? webViewController; InAppWebViewSettings settings = InAppWebViewSettings( // 能够监听 WebView.shouldOverrideUrlLoading（URL即将加载时）的事件。 useShouldOverrideUrlLoading: true, // 设置为 true 以防止 HTML5 音频或视频自动播放。 mediaPlaybackRequiresUserGesture: false, // 允许 HTML5 媒体播放在屏幕布局中内嵌显示，即让媒体播放器嵌入到网页的其他内容中一起显示 allowsInlineMediaPlayback: true, // 根据请求的来源定义了哪些功能可供使用（例如，访问麦克风、摄像头、电池、网络共享等） iframeAllow: \u0026#34;camera; microphone\u0026#34;, // 如果 iframe 可以通过调用 requestFullscreen() 方法激活全屏模式，则设置为 true。 iframeAllowFullscreen: true ); PullToRefreshController? pullToRefreshController; String url = \u0026#34;\u0026#34;; double progress = 0; final urlController = TextEditingController(); @override void initState() { super.initState(); // 在 WebView 中开启下拉刷新 pullToRefreshController = kIsWeb ? null : PullToRefreshController( settings: PullToRefreshSettings( color: Colors.blue, ), onRefresh: () async { if (defaultTargetPlatform == TargetPlatform.android) { webViewController?.reload(); } else if (defaultTargetPlatform == TargetPlatform.iOS) { webViewController?.loadUrl( urlRequest: URLRequest(url: await webViewController?.getUrl())); } }, ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text(\u0026#34;Official InAppWebView website\u0026#34;)), body: SafeArea( child: Column(children: \u0026lt;Widget\u0026gt;[ TextField( decoration: const InputDecoration(prefixIcon: Icon(Icons.search)), controller: urlController, keyboardType: TextInputType.url, onSubmitted: (value) { var url = WebUri(value); if (url.scheme.isEmpty) { url = WebUri(\u0026#34;https://www.google.com/search?q=$value\u0026#34;); } webViewController?.loadUrl(urlRequest: URLRequest(url: url)); }, ), Expanded( child: Stack( children: [ InAppWebView( key: webViewKey, // 初始化URL initialUrlRequest: URLRequest(url: WebUri(\u0026#34;https://inappwebview.dev/\u0026#34;)), // 初始化设置 initialSettings: settings, // 下拉刷新 pullToRefreshController: pullToRefreshController, // 创建 WebView 时触发的事件 onWebViewCreated: (controller) { webViewController = controller; }, // 当 WebView 开始加载 url 时触发的事件。 onLoadStart: (controller, url) { setState(() { this.url = url.toString(); urlController.text = this.url; }); }, // 请求无访问权限资源 时触发的事件。 onPermissionRequest: (controller, request) async { return PermissionResponse( resources: request.resources, action: PermissionResponseAction.GRANT); }, // 让APP有机会在 URL即将加载 时进行控制。 shouldOverrideUrlLoading: (controller, navigationAction) async { var uri = navigationAction.request.url!; if (![ \u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;, \u0026#34;file\u0026#34;, \u0026#34;chrome\u0026#34;, \u0026#34;data\u0026#34;, \u0026#34;javascript\u0026#34;, \u0026#34;about\u0026#34; ].contains(uri.scheme)) { if (await canLaunchUrl(uri)) { // Launch the App await launchUrl( uri, ); // and cancel the request return NavigationActionPolicy.CANCEL; } } return NavigationActionPolicy.ALLOW; }, // 完成加载 url 时触发的事件。 onLoadStop: (controller, url) async { pullToRefreshController?.endRefreshing(); setState(() { this.url = url.toString(); urlController.text = this.url; }); }, // 加载请求时遇到错误 时触发的事件。 onReceivedError: (controller, request, error) { pullToRefreshController?.endRefreshing(); }, // 更改正在加载的页面 时触发的事件。 onProgressChanged: (controller, progress) { if (progress == 100) { pullToRefreshController?.endRefreshing(); } setState(() { this.progress = progress / 100; urlController.text = url; }); }, // APP更新其访问的链接 时触发的事件。 onUpdateVisitedHistory: (controller, url, androidIsReload) { setState(() { this.url = url.toString(); urlController.text = this.url; }); }, // WebView收到控制台报错 时触发的事件。 onConsoleMessage: (controller, consoleMessage) { if (kDebugMode) { print(consoleMessage); } }, ), // 进度指示器 progress \u0026lt; 1.0 ? LinearProgressIndicator(value: progress) : Container(), ], ), ), ButtonBar( alignment: MainAxisAlignment.center, children: \u0026lt;Widget\u0026gt;[ // 后退按钮 ElevatedButton( child: const Icon(Icons.arrow_back), onPressed: () { webViewController?.goBack(); }, ), // 前进按钮 ElevatedButton( child: const Icon(Icons.arrow_forward), onPressed: () { webViewController?.goForward(); }, ), // 刷新按钮 ElevatedButton( child: const Icon(Icons.refresh), onPressed: () { webViewController?.reload(); }, ), ], ), ]) ) ); } } Widgetbook 使用Widgetbook可以管理组件、使用不同设备尺寸测试组件、实时修改组件参数、协作共享。\nWindows配置 确保安装Visual Studio，及其应用： 从https://www.nuget.org/downloads下载最新的nuget.exe,并放入任意文件夹（我的在C:\\Program Files\\Microsoft Visual Studio），配置系统环境变量。\n使用 在pubspec.yaml安装 widgetbook 组件 注意是放在 dev_dependencies 下面\ndev_dependencies: flutter_test: sdk: flutter flutter_lints: ^2.0.0 widgetbook: ^3.0.0-beta.14 新建lib/app.widgetbook.dart import \u0026#39;package:flutter/material.dart\u0026#39;; // ignore: depend_on_referenced_packages import \u0026#39;package:widgetbook/widgetbook.dart\u0026#39;; import \u0026#39;你的组件\u0026#39;; void main() { runApp(const HotReload()); } class HotReload extends StatelessWidget { const HotReload({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return Widgetbook.material( // Widgetbook 属性选择 addons: [ // 主题 // buildMaterialThemeAddon(), // 字体大小 // buildTextScaleAddon(), ], // 可以容纳包、文件夹、类别、组件和用例 directories: [ // buildWidgetbookCategory(), // //buildWidgetbookCategory2(), ], ); } TextScaleAddon buildTextScaleAddon() { return TextScaleAddon( setting: TextScaleSetting.firstAsSelected( textScales: [1.0, 1.25, 1.5, 1.75, 2])); } MaterialThemeAddon buildMaterialThemeAddon() { return MaterialThemeAddon( setting: MaterialThemeSetting.firstAsSelected(themes: [ WidgetbookTheme(name: \u0026#34;dark\u0026#34;, data: ThemeData.dark()), WidgetbookTheme(name: \u0026#34;light\u0026#34;, data: ThemeData.light()), ])); } WidgetbookCategory buildWidgetbookCategory() { return WidgetbookCategory( // 分类名 name: \u0026#39;公共组件\u0026#39;, children: [ WidgetbookComponent( // 组件名 name: \u0026#39;Spinkit加载\u0026#39;, useCases: [ WidgetbookUseCase.center( // 组件用例名 name: \u0026#34;SpinKitFadingCircle\u0026#34;, child: mySpinkit(), ), ], ), ], ); } } AI画图 Ai 设置：视图-\u0026gt;显示网格\n多边形变换：多边形工具-\u0026gt;自定义变换工具\n缩放：鼠标左键向右划放大、向左划缩小\n形状合成：选中区域-\u0026gt;形状生成器工具-\u0026gt;穿过需要的区域-\u0026gt;按住Alt穿过不要的区域\n渐变：双击圆圈弹出调色板\n动画 lottie需要用到Ae，rive是在线编辑。\n其他 double width = MediaQuery.of(context).size.width; 屏幕宽度\ndouble height = MediaQuery.of(context).size.height; 屏幕高度\n","date":"2022-04-30T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/flutter/","title":"flutter基础备忘录"},{"content":"root（不同手机不同操作，刷机有变砖风险！） 以前手机都是用虚拟机 VMOS Pro，应用权限是有了，但现手机不能自动开屏幕锁自动执行任务，于是只能root。 大概分为以下步骤：\n解bl锁 各品牌手机解锁有所不同，三星、小米、一加、Google pixel等部分厂商官方给解锁。\\\n解锁困难的华为旧机：我用的是github的potatoNV短接解锁，如果其中没有你的手机，直接淘宝不要浪费时间。作者在youtube有教程，照做就好了（视频简介的USB com 1.0连接教程也要看，他的点击DriverSetup操作很快，不要漏了），短接点可以参考这里。获得解锁码搜华为工具箱即可解锁。\n刷rom（系统）、刷入 TWRP recovery 建议不要刷机软件一键刷机，都是垃圾系统，一般就用原系统刷适合你手机的TWRP。新手机找不到官方TWRP去https://unofficialtwrp.com/，点图片左下角手机品牌可以进入分类，收录了全面的非官方TWRP。 \\\n小米为例：在https://xiaomirom.com/下载刷机工具，刷酷安ID乌堆小透明的ROM（另外欧版eu社区版ROM不错，但我的k50至尊版无论刷欧版还是刷gsi均不能使用chrome联网，小米手机已被我拉黑）。然后按照此教程操作，安装选择默认即可，开机后卸载重装magisk。\\\n华为为例：我在https://m.huaweirom.com/rom/找到华为有TWRP的rom，我当时看到网站干净无广告就刷了，是可以用的，此网站应该靠谱。Fastboot模式运行run脚本就行了。\nroot github下载magisk放进手机储存卡（有人建议低版安卓用20.4版本），进入TWRP recovery安装，开机后酷安安装magisk app即可。\nMacroDroid 基础 设置：\n防止系统清理：进入系统最近任务界面，点击应用旁边的小锁，锁定应用不被系统清理 忽略电池优化：依次打开系统设置，应用和通知，应用管理，设置，特殊访问权限，忽略电池优化（直接在设置搜索栏搜索电池也能找到），允许忽略应用 设置启动管理：依次打开系统设置，电池，启动管理，关闭应用自动管理后弹出的对话框中选中：允许自启动，允许关联启动，允许后台活动 权限全部打开 shell shell命令很方便定义操作（点击的坐标可以在手机开发者选项中打开指针位置）。shell命令摘录网站\n#按键事件 input text \u0026lt;string\u0026gt; #输入文本 input keyevent 20 #向下 input keyevent 4 #返回 input keyevent 3 #Home input keyevent 6 #挂机 input keyevent 84 #搜索 input keyevent 26 #电源，息屏 input keyevent 24 #音量+ input keyevent 25 #音量- #模拟点击 input tap 100 100 #滑动 input swipe x1 y1 x2 y2 ms input swipe 100 100 400 100 300 #左往右 input swipe 400 100 100 100 300 #右往左 input swipe 100 100 100 400 300 #上往下 input swipe 100 400 100 100 300 #下往上 input swipe 100 100 400 400 300 #上往下斜 input swipe 400 400 100 100 300 #下往上斜 #长按 input swipe 100 100 100 100 1000 //在 100 100 位置长按 1000毫秒 ","date":"2021-11-24T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/phone-root/","title":"root手机和自动化"},{"content":"本github actions方法已于2022-07-15完全被封，请去仓库看文档 freenom自动续期 Fork luolongfei大佬的freenom库，再添加以下workflow： “点击展开完整代码”\r# 1、Fork 本仓库 # 2、在你 Fork 的本仓库下的 Settings \u0026gt; Secrets 画面追加以下几个 secret 变量： # FREENOM_USERNAME、FREENOM_PASSWORD、MULTIPLE_ACCOUNTS、MAIL_USERNAME、MAIL_PASSWORD、TO、MAIL_ENABLE、TELEGRAM_CHAT_ID、 # TELEGRAM_BOT_TOKEN、TELEGRAM_BOT_ENABLE、NOTICE_FREQ # （注：此处列出了所有可用变量，你只用追加你需要用到的变量，变量的具体含义请参考本项目的 .env 文件中的说明，一般情况下，.env 文件中的某些 # 项存在默认值，如果默认值满足你的需求则可不追加到 Secrets，它们会保持默认） # # 下面定时任务中的时间是世界时间，每天 10:00（本示例已改为2:00） 执行，由于创建虚拟环境会消耗时间，故任务会延迟 30 秒左右执行 # # @Author of yml configuration file: RouRouX \u0026lt;https://github.com/RouRouX\u0026gt; \u0026amp; mybsdc \u0026lt;mybsdc@gmail.com\u0026gt; # ###### end 说明 ###### name: Run it on action on: push: branches: - main schedule: - cron: 00 02 * * * workflow_dispatch: jobs: run-it: runs-on: ubuntu-18.04 name: Run it on action steps: - name: Checkout master uses: actions/checkout@v2 - name: Setup PHP uses: shivammathur/setup-php@v2 with: php-version: \u0026#39;7.2\u0026#39; - name: Setting run: | echo \u0026#39;Renew freenom domain name automatically.\u0026#39; echo \u0026#39;@Author of yml configuration file: RouRouX \u0026lt;https://github.com/RouRouX\u0026gt; \u0026amp; mybsdc \u0026lt;mybsdc@gmail.com\u0026gt;\u0026#39; echo \u0026#39;@Url: https://github.com/luolongfei/freenom\u0026#39; cp .env.example .env if [[ (\u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39; == \u0026#39;\u0026#39; || \u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39; == \u0026#39;\u0026#39;) \u0026amp;\u0026amp; \u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39; == \u0026#39;\u0026#39; ]]; then echo \u0026#39;你在 Github 的当前项目的 Settings \u0026gt; Secrets 画面没有设置任何与账户信息相关的 secret 值，无法正常运行，请添加新的 secret 值，设置 FREENOM_USERNAME 与 FREENOM_PASSWORD，或者设置 MULTIPLE_ACCOUNTS，以及 .env 文件中其它必要项，各项的具体含义与格式参考本项目 .env 文件中的说明。\u0026#39;; fi if [ \u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^FREENOM_USERNAME=.*$/FREENOM_USERNAME=\u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^FREENOM_PASSWORD=.*$/FREENOM_PASSWORD=\u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MULTIPLE_ACCOUNTS=.*$/MULTIPLE_ACCOUNTS=\u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_USERNAME }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_USERNAME=.*$/MAIL_USERNAME=\u0026#39;${{ secrets.MAIL_USERNAME }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_PASSWORD }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_PASSWORD=.*$/MAIL_PASSWORD=\u0026#39;${{ secrets.MAIL_PASSWORD }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TO }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TO=.*$/TO=\u0026#39;${{ secrets.TO }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_ENABLE }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_ENABLE=.*$/MAIL_ENABLE=\u0026#39;${{ secrets.MAIL_ENABLE }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_CHAT_ID }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_CHAT_ID=.*$/TELEGRAM_CHAT_ID=\u0026#39;${{ secrets.TELEGRAM_CHAT_ID }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_BOT_TOKEN }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_BOT_TOKEN=.*$/TELEGRAM_BOT_TOKEN=\u0026#39;${{ secrets.TELEGRAM_BOT_TOKEN }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_BOT_ENABLE }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_BOT_ENABLE=.*$/TELEGRAM_BOT_ENABLE=\u0026#39;${{ secrets.TELEGRAM_BOT_ENABLE }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.NOTICE_FREQ }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^NOTICE_FREQ=.*$/NOTICE_FREQ=\u0026#39;${{ secrets.NOTICE_FREQ }}\u0026#39;/\u0026#34; .env; fi sed -i \u0026#34;s/^ON_GITHUB_ACTIONS=.*$/ON_GITHUB_ACTIONS=true/\u0026#34; .env - name: Run run: | php run # 以下为保活所需step - name: curl id: enable_workflow env: REST_TOKEN: ${{ secrets.REST_TOKEN }} API_ADDRESS: ${{ secrets.API_ADDRESS }} run: | echo \u0026#34;Enable Workflow Start...\u0026#34; curl -X PUT -H \u0026#34;Authorization: token $REST_TOKEN\u0026#34; \u0026#34;$API_ADDRESS\u0026#34; echo \u0026#34;Finished\u0026#34; 在你 Fork 的本仓库下的 Settings -\u0026gt; Secrets 页面追加以下几个secret秘密环境变量\n变量名 含义 默认值 是否必须 备注 FREENOM_USERNAME freenom 账户 - 是 只支持邮箱账户，不支持也不打算支持第三方社交账户登录 FREENOM_PASSWORD freenom 密码 - 是 某些特殊字符可能需要转义，在Github actions环境，请在除字母数字以外的字符前加上“\\”，否则可能无法正确读取密码，此举是防止某些字符在shell命令行被解析，举个例子，比如我密码是fei.,:!~@#$%^\u0026amp;*?233-_abcd^$$，那么写到秘密变量时就应写为fei\\.\\,\\:\\!\\~\\@\\#\\$\\%\\^\\\u0026amp;\\*\\?233\\-\\_abcd\\^\\$\\$。而在普通VPS环境，则只用在密码中的“#”或单双引号前加“\\”，请参考.env.example文件内的注释，应该没人会设置那么变态的密码吧 MULTIPLE_ACCOUNTS 多账户支持 - 否 多个账户和密码的格式必须是“\u0026lt;账户1\u0026gt;@\u0026lt;密码1\u0026gt;|\u0026lt;账户2\u0026gt;@\u0026lt;密码2\u0026gt;|\u0026lt;账户3\u0026gt;@\u0026lt;密码3\u0026gt;”，如果设置了多账户，上面的FREENOM_USERNAME和FREENOM_PASSWORD可不设置 MAIL_USERNAME 机器人邮箱账户 - 是 支持Gmail、QQ邮箱以及163邮箱，尽可能使用163邮箱或者QQ邮箱，而非之前推荐的Gmail。因为谷歌的安全机制，每次在新设备登录 Gmail 都会先被限制，需要手动解除限制才行，而Github Actions每次创建的虚拟环境都会分配一个新的设备IP，相当于每次都是从新设备登录Gmail，而我们不可能每次都去手动为Gmail解除登录限制，所以这种机制会导致无法发出通知邮件。具体的配置方法参考「 配置发信邮箱 」 MAIL_PASSWORD 机器人邮箱密码 - 是 Gmail填密码，QQ邮箱或163邮箱填授权码 TO 接收通知的邮箱 - 是 你自己最常用的邮箱，推荐使用QQ邮箱，用来接收机器人邮箱发出的域名相关邮件 MAIL_ENABLE 是否启用邮件推送功能 true 否 true：启用\nfalse：不启用\n默认启用，如果设为false，不启用邮件推送功能，则上面的MAIL_USERNAME、MAIL_PASSWORD、TO变量变为非必须，可不设置 TELEGRAM_CHAT_ID 你的chat_id - 否 通过发送/start给@userinfobot可以获取自己的id TELEGRAM_BOT_TOKEN 你的Telegram bot的token - 否 TELEGRAM_BOT_ENABLE 是否启用Telegram Bot推送功能 false 否 true：启用\nfalse：不启用\n默认不启用，如果设为true，则必须设置上面的TELEGRAM_CHAT_ID和TELEGRAM_BOT_TOKEN变量 NOTICE_FREQ 通知频率 1 否 0：仅当有续期操作的时候\n1：每次执行 REST_TOKEN 如后文所示 - 否 保活所需 API_ADDRESS 如后文所示 - 否 保活所需 （注：你只用关注上面表格中的必须项，非必须项可不设置，将保持默认值。更多相关变量的含义、格式以及默认值，请参考本项目的.env.example文件内的注释）\n启用 Actions ，完成。 保活 Fork zhzhzhy/Workflow-Keep-Alive库\n创建 sercets ：\n变量名 值 备注 REST_TOKEN 个人访问令牌（Personal access tokens） 个人资料照片-\u0026gt;设置-\u0026gt;Developer settings API_ADDRESS https://api.github.com/repos/{owner}/{target-repo}/actions/workflows/enable_workflow/enable 修改{owner}/{target-repo} 运行 github action。\n相互唤醒，再次在目标 repo 的工作流程中执行上述步骤，并添加所需 Github Action step（此步骤已标注请回看）。\n附 github workflow 语法文档\n修改定时任务 —— Cron示例\n","date":"2021-11-19T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/freenom/","title":"freenom自动续期（废弃）"},{"content":"actions部署前后端分离项目 参考文章\n本文使用github actions + docker compose部署到github container registry（这适用于中小型项目） 附：容器注册平台对比\n准备好你的dockerfile，如无docker和docker-compose基础请先看文档和前文。\n使用github actions “点击展开示例actions”\ron: push: branches: - master workflow_dispatch: env: REGISTRY: ghcr.io IMAGE_NAME: ${{ github.repository }} jobs: build-and-push-image: runs-on: ubuntu-latest permissions: contents: read packages: write strategy: matrix: node: [ \u0026#39;14\u0026#39; ] steps: - name: Checkout repository uses: actions/checkout@v2 - name: Setup node uses: actions/setup-node@v2 with: node-version: ${{ matrix.node }} - name: npm install run: | cd web #进入前端dockerfile目录 npm install - name: Set up QEMU uses: docker/setup-qemu-action@v1 - uses: docker/setup-buildx-action@v1 id: builder1 - uses: docker/setup-buildx-action@v1 id: builder2 - name: Log in to the Container registry uses: docker/login-action@v1 with: registry: ${{ env.REGISTRY }} username: ${{ github.actor }} password: ${{ secrets.GITHUB_TOKEN }} # 用于消毒标签，tag是此动作的重要功能之一，本示例没使用，请见文档 - name: Extract metadata (tags, labels) for Docker id: meta1 uses: docker/metadata-action@v3 with: images: ghcr.io/username/server # images地址 - name: Extract metadata (tags, labels) for Docker id: meta2 uses: docker/metadata-action@v3 with: images: ghcr.io/username/web # images地址 - name: Build and push Docker image 1 uses: docker/build-push-action@v2 with: builder: ${{ steps.builder1.outputs.name }} context: ./server # 服务端dockerfile目录 file: ./server/Dockerfile # 服务端dockerfile push: true tags: ${{ steps.meta1.outputs.tags }} labels: ${{ steps.meta1.outputs.labels }} cache-from: type=gha cache-to: type=gha,mode=max - name: Build and push Docker image 2 uses: docker/build-push-action@v2 with: builder: ${{ steps.builder2.outputs.name }} context: ./web # 前端dockerfile目录 file: ./web/Dockerfile # 前端dockerfile push: true tags: ${{ steps.meta2.outputs.tags }} labels: ${{ steps.meta2.outputs.labels }} cache-from: type=gha cache-to: type=gha,mode=max deploy: runs-on: ubuntu-latest needs: build-and-push-image steps: - uses: appleboy/ssh-action@master with: host: ${{ secrets.host }} #仓库设置中添加Secrets：HOST username: root password: ${{ secrets.PASSWORD }} #仓库设置中添加Secrets：PASSWORD port: 22 script: | echo $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin # 用户名 docker-compose -f docker-compose-nginx.yaml -f docker-compose-app.yaml pull # docker-compose名 docker-compose -f docker-compose-nginx.yaml -f docker-compose-app.yaml up -d # docker-compose名 # 此actions许多参数由github自动提供，无需添加，需修改的均已注释 在服务器上完成向 Container registry 验证\n具体操作：打开/etc/profile\nexport CR_PAT=YOUR_TOKEN source /etc/profile echo $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin 新建docker-compose-app.yaml和代理容器docker-compose-nginx.yaml,示例文档。如有不懂，请多看几遍acme-companion和示例文档。最后，Issues中的实例可能会有帮助。 ","date":"2021-11-15T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/auto-deploy/","title":"docker自动化部署"},{"content":"docker 安装docker：\n#更新apt包索引 sudo apt-get update #安装包以允许apt通过 HTTPS 使用存储库 sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release #添加Docker官方的GPG密钥 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg #设置稳定存储库 echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null #安装最新版本的Docker Engine和containerd sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io #hello-world 映像验证 sudo docker run hello-world # 使用脚本安装 curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh Dockerfile “点击展开go语言示例”\r# 这个参考示例来自李文周大佬的bluebell项目 FROM golang:alpine AS builder # 为我们的镜像设置必要的环境变量 ENV GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 # 移动到工作目录：/build WORKDIR /build # 复制项目中的 go.mod 和 go.sum文件并下载依赖信息 COPY go.mod . COPY go.sum . RUN go mod download # 将代码复制到容器中 COPY . . # 将我们的代码编译成二进制可执行文件 bluebell_app RUN go build -o bluebell_app . ################### # 接下来创建一个小镜像 ################### FROM debian:stretch-slim COPY ./wait-for.sh / COPY ./templates /templates COPY ./static /static COPY ./conf /conf # 从builder镜像中把/dist/app 拷贝到当前目录 COPY --from=builder /build/bluebell_app / RUN set -eux; \\ apt-get update; \\ apt-get install -y \\ --no-install-recommends \\ netcat; \\ chmod 755 wait-for.sh # 声明服务端口 EXPOSE 8084 # 需要运行的命令 #ENTRYPOINT [\u0026#34;/bluebell_app\u0026#34;, \u0026#34;conf/config.yaml\u0026#34;] 基础知识参考 以下简介节选自docker文档：\n**卷（volumes）**存储在由 Docker管理的主机文件系统（在 Linux 上的/var/lib/docker/volumes/ ）。卷完全由 Docker 管理，非 Docker 进程不应修改文件系统的这一部分。卷是在 Docker 中持久化数据的最佳方式。 # 将当前目录的相对路径挂载到/app目录中 volumes: - ./:/app docker compose 安装docker compose：\n#单独下载和安装 Compose，不装Docker CLI #下载 Docker Compose 的当前稳定版本 curl -SL https://github.com/docker/compose/releases/download/v2.7.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose #对二进制文件应用可执行权限 sudo chmod +x /usr/local/bin/docker-compose #测试安装 docker compose version # 脚本 curl -fsSL https://get.docker.com -o get-docker.sh \u0026amp;\u0026amp; \\ sudo sh get-docker.sh \u0026amp;\u0026amp; \\ docker -v \u0026amp;\u0026amp; \\ curl -SL https://github.com/docker/compose/releases/download/v2.7.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose \u0026amp;\u0026amp; \\ sudo chmod +x /usr/local/bin/docker-compose \u0026amp;\u0026amp; \\ docker compose version docker-compose.yaml “点击展开和折叠代码”\rversion: \u0026#39;3.7\u0026#39; services: mysql5.7: # 镜像名 image: \u0026#39;mysql:5.7\u0026#39; # 容器名(以后的控制都通过这个) container_name: mysql5.7 # 重启策略 restart: always environment: # 时区上海 TZ: Asia/Shanghai # root 密码 MYSQL_ROOT_PASSWORD: root # 初始化数据库(后续的初始化sql会在这个库执行) MYSQL_DATABASE: nacos_config # 初始化用户(不能是root 会报错, 后续需要给新用户赋予权限) MYSQL_USER: nacos # 用户密码 MYSQL_PASSWORD: nacos # 映射端口 ports: - 3306:3306 volumes: # 数据挂载 #- /root/mysql/data/:/var/lib/mysql/ # 配置挂载 #- /root/mysql/conf/:/etc/mysql/conf.d/ # 初始化目录挂载，注意此处我只跑了这个挂载，只是为了说明其他配置不应该数据初始化 - /root/mysql/init/:/docker-entrypoint-initdb.d/ command: # 将mysql8.0默认密码策略 修改为 原先 策略 (mysql8.0对其默认策略做了更改 会导致密码无法匹配) --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 networks: - proxy server: image: ghcr.io/USERNAME/server:master container_name: server ports: - 8082:8082 expose: - \u0026#34;8082\u0026#34; depends_on: - mysql5.7 restart: always volumes: - \u0026#39;./data:/data/\u0026#39; networks: - proxy web: image: ghcr.io/USERNAME/web:master container_name: web depends_on: - server restart: always ports: - 3000:3000 expose: - \u0026#34;3000\u0026#34; environment: - VIRTUAL_HOST=example.com - VIRTUAL_PORT=3000 - LETSENCRYPT_HOST=example.com - LETSENCRYPT_EMAIL=mail@example.com networks: - proxy networks: proxy: name: nginx-proxy external: true “点击展开nginx-proxy代码”\rversion: \u0026#39;3\u0026#39; services: nginx-proxy: image: jwilder/nginx-proxy container_name: nginx-proxy ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; volumes: - conf:/etc/nginx/conf.d - vhost:/etc/nginx/vhost.d - html:/usr/share/nginx/html - dhparam:/etc/nginx/dhparam - certs:/etc/nginx/certs:ro - /var/run/docker.sock:/tmp/docker.sock:ro restart: always networks: - nginxproxy labels: - \u0026#34;com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy\u0026#34; letsencrypt: image: jrcs/letsencrypt-nginx-proxy-companion container_name: nginx-proxy-le depends_on: - nginx-proxy volumes: - vhost:/etc/nginx/vhost.d - html:/usr/share/nginx/html - dhparam:/etc/nginx/dhparam:ro - certs:/etc/nginx/certs - acme:/etc/acme.sh - /var/run/docker.sock:/var/run/docker.sock:ro ################## # 由于LETSENCRYPT证书速率限制，可使用ZeroSSL # 注释掉web服务environment中的： - LETSENCRYPT_HOST=example.com - LETSENCRYPT_EMAIL=mail@example.com # 需添加如下environment environment: - ACME_CA_URI=https://acme.zerossl.com/v2/DV90 - ZEROSSL_API_KEY= ################## restart: always networks: - nginxproxy volumes: conf: vhost: html: dhparam: certs: acme: networks: nginxproxy: name: nginx-proxy external: true 基础知识参考 以下简介节选自docker compose文档：\nCompose 中的网络: Compose默认为您的应用程序设置单个网络。服务中的每个容器都加入默认网络。例如，假设您的应用程序是在一个名为myapp的目录，运行docker-compose up时会创建一个名为myapp_default的网络，服务中使用web和db的配置创建的容器会以web和db的名字加入myapp_default。\n但是，当你使用external（外部网络，例如你有2个或多个docker-compose.yml）时，Compose不会创建默认网络，你必须使用docker network create Your_Nerwork预先创建网络。\n注意：文档中示例写法错误，会报错\nnetworks: proxy: external: name: nginx-proxy 应写为:\nnetworks: proxy: name: nginx-proxy external: true 常用命令 Docker命令 docker run [可选参数] imagename #新建并启动容器 --name = \u0026#34;name\u0026#34; 容器取名 -it 交互模式进入容器 -d 后台启动容器 注意：一般后台启动要有前台的应用，否则很可能被守护程序杀掉 -p ip:主机端口:容器端口 #指定端口映射 -v或--volume /卷名称的路径:/容器中的挂载路径 查看： docker search xxx #搜索dockerhub-镜像 docker images [-a][-q] #列出本地主机的-镜像 -a 显示所有信息 -q 显示所有id docker ps [-a][-q] #显示当前正在运行的容器 -a 显示当前运行的容器，并显示历史运行过的容器 -q 只显示运行容器的编号 docker logs 容器id #日志 docker top 容器id #查看容器中进程信息 docker inspect 容器id #查看容器的详细信息 操作： docker build -t tag . #构建标签为tag的镜像 docker pull 镜像：版本号 #拉取-镜像 docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止容器 docker kill 容器id #强制停止容器 docker rm 容器id #删除停止状态的容器 docker rm -f 容器id #强制删除容器 docker rmi -f xxx #删除单个-镜像 docker rmi -f $(docker images -aq) #删除所有-镜像 docker stop $(docker ps -a -q) #停止所有容器运行 docker rm $(docker ps -a -q) #删除所有容器 docker network rm $(docker network ls -q) #删除所有network docker system prune --all --force --volumes #删除一切 exit 容器停止并退出 ctrl+p+q 容器不停止退出 docker exec -it mysql /bin/bash #进入正在执行的mysql容器 docker exec -it 容器名 /bin/sh #进入容器 docker exec -it 容器名 -c \u0026#34;apt-get update \u0026amp;\u0026amp; apt-get install -y vim\u0026#34; #进入容器安装vim编辑器 docker exec -it 容器名 -c \u0026#34; apk add --update vim\u0026#34; #进入alpine容器安装vim编辑器 docker inspect -f \u0026#39;{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}\u0026#39; [container_name_or_id] #查看容器ip 从容器拷贝内容到主机： docker cp 容器id: 路径 主机目的路径 #此处不必进入容器，容器可以是关闭的。 Docker-compose命令 docker-compose up -d # 在后台启动服务 docker-compose pull # 拉取 docker-compose -f docker-compose.yml up -d # 指定docker-compose.yml docker-compose -f docker-compose.yml pull # 指定docker-compose.yml，后同 查看： docker-compose ps # 查看正在运行中的容器 docker-compose ps -a # 查看所有编排容器，包括已停止的容器 docker-compose images # 列出Compose文件构建的镜像 docker-compose logs # 查看日志 docker-compose logs [serviceName] # 查看某服务的日志 docker-compose logs -f [serviceName] # 查看某服务的实时日志 操作： docker-compose stop # 停止服务 docker-compose start # 启动已经存在的服务 docker-compose pause [serviceName] # 暂停服务 docker-compose unpause [serviceName] # 恢复服务 docker-compose restart [serviceName] # 重启服务 docker-compose rm # 删除所有（停止状态的）服务容器 docker-compose down # 删除所有容器 docker-compose down --remove-orphans # 删除orphans容器 docker-compose config -q # 验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容 docker-compose exec --index=1 [serviceName] sh # 进入某服务的第1个容器执行命令 docker-compose --help # 帮助 ","date":"2021-10-27T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/docker-compose/","title":"docker和docker-compose"},{"content":"git git命令 官网git备忘表\nsubmodule\ngit submodule add [git@github.com:xxx/submodule.git] [directory] # 添加子模块 git clone [git@github.com:xxx/submodule.git] [directory] --recurse-submodules # 克隆一个存储库,并自动更新仓库中所有子模块（更新可能不兼容，慎用） git submodule update # 更新 问题\n更新被拒绝，因为远程仓库包含您本地尚不存在的提交。 git push -u origin +master # 强制push gitmodules错误 删掉.git和.gitmodules重新初始化更容易。\npush脚本 #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master 公开仓库fork为私有仓库 fork一个公开仓库 使用github导入功能，写fork仓库的地址，并创建私有仓库 本地操作 git clone git@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git #克隆到本地 git remote add upstream git@github.com:\u0026lt;original_owner\u0026gt;/\u0026lt;original_repo\u0026gt;.git #添加上游(源)仓库用于更新 git remote set-url --push upstream DISABLE #禁用推送到上游(源)仓库 git remote -v可以看到： origin\tgit@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git (fetch) origin\tgit@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git (push) upstream\tgit@github.com:\u0026lt;original_owner\u0026gt;/\u0026lt;original_repo\u0026gt;.git (fetch) upstream\tDISABLE (push) 拉取更新 git fetch upstream git merge upstream/master Linux 文件 i 键可以对文件进行修改， Esc + :+ wq 退出并保存修改之后的文件\nsudo gedit ~/File //编辑 touch File //新建文件 mkdir -p Folder/a/src //新建文件夹 sudo rm -r Folder //删除文件夹 安装包 apt sudo apt update \u0026amp;\u0026amp; apt upgrade //更新 dpkg --list //显示所有软件 sudo apt-get install 包名 //安装 sudo apt-get remove 包名 //卸载不删除配置文件 sudo apt-get --purge remove 包名 //软件及其配置文件一并删除 snap sudo snap list //列出已经安装的snap包 sudo snap install \u0026lt;snap name\u0026gt; //安装一个snap包 sudo snap refresh \u0026lt;snap name\u0026gt; //更新一个snap包，如果后面不加包的名字更新所有的snap包 sudo snap remove \u0026lt;snap name\u0026gt; //删除一个snap包 端口 sudo apt-get install lsof //安装lsof lsof -i:80 //查看80端口 kill -9 pid //强制杀进程 命令 local #用于声明局部变量 source systemctl stop service # 停止一个服务 systemctl daemon-reload # 重载所有修改过的配置文件 systemctl enable #将服务设置为每次开机启动 set -eux #用于脚本开头设置 #-e 若指令传回值不等于0，则立即退出shell。0表示没有错误 #-u 当执行时使用到未定义过的变量，则显示错误信息。 #-x 执行指令后，会先显示该指令及所下的参数。 grep 、sed、awk grep 、sed、awk被称为linux中的\u0026quot;三剑客\u0026quot;。\ngrep 更适合单纯的查找或匹配文本 sed 更适合编辑匹配到的文本 awk 更适合格式化文本，对文本进行较复杂格式处理 sed sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为\u0026quot;pattern space\u0026quot;，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。\n语法 sed [option] \u0026#39;command\u0026#39; fileName 选项\n-n 使用安静silent模式。在一般sed的用法中，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来\n-e 直接在指令列模式上进行 sed 的动作编辑\n-f 直接将 sed 的动作写在一个文件内，-f filename则可以执行filename内的sed命令\n-r 让sed命令支持扩展的正则表达式(默认是基础正则表达式)\n-i 直接修改读取的文件内容，而不是由屏幕输出\n命令\na\\：追加行，a\\的后面跟上字符串s(多行字符串可以用\\n分隔)，则会在当前选择的行的后面都加上字符串s\nc\\：替换行，c\\后面跟上字符串s(多行字符串可以用\\n分隔)，则会将当前选中的行替换成字符串s\ni\\：插入行，i\\后面跟上字符串s(多行字符串可以用\\n分隔)，则会在当前选中的行的前面都插入字符串s\nd：删除行delete，该命令会将当前选中的行删除\np：打印print，该命令会打印当前选择的行到屏幕上\ny：替换字符，通常y命令的用法是这样的：y/Source-chars/Dest-chars/，分割字符/可以用任意单字符代替，用Dest-chars中对应位置的字符替换掉Soutce-chars中对应位置的字符\ns：替换字符串，通常s命令的用法是这样的：1,$s/Regexp/Replacement/Flags，分隔字符/可以用其他任意单字符代替，用Replacement替换掉匹配字符串\n替换选项\n\\digit：Replacement中可含有后向引用中的\\digit(digit是1至9)，引用前面定义的子表达\n\u0026amp;：代表模版空间中的整个匹配部分\n\\L：将在其后的替换部分转换成小写字母，直到发现一个\\U或\\E，GNU扩展功能\n\\l：将下一个字符转换成小写字母，GNU扩展功能\n\\U：将在其后的替换部分转换成大写字母，直到发现一个\\L或\\E，GNU扩展功能\n\\u：将下一个字符转换成大写字母，GNU扩展功能\n\\E：停止由\\L或\\U指示开始的大小写转换，GNU扩展功能\n标志选项\ng：将用Replacement替换模版空间中所有匹配Regexp的部分，则不仅仅是第一个匹配部分\ndigit：只用Replacement替换模版空间中第digit(digit是1至9)个匹配Regexp的部分\np：若发生了替换操作，指示显示模版空间中新的数据\nw file-name：若发生了替换操作，指示将模版空间中新的数据写入指定的文件file-name中\ni：表示进行Regexp匹配时，是不区分大小写字母的\n示例 a命令 sed '1,$a\\add one' test.txt 从第一行到最后一行所有行后追加\u0026quot;add one\u0026quot;字符串行\nsed '/first/a\\add one' test.txt 在匹配到first行追加\u0026quot;add one\u0026quot;字符串行\ni命令 与a命令类似，只不过在匹配的行前面插入字符串行，不举例了。\nc命令 sed '1,$c\\add one' test.txt 从第一行到最后一行所有行替换为\u0026quot;add one\u0026quot;字符串行\nsed '/first/c\\add one' test.txt 将匹配到first行替换为\u0026quot;add one\u0026quot;字符串行\nd命令 sed '4,$d' test.txt 从第四行到最后一行全部删除\np命令 sed -n '/^first.*end$/p' test.txt 以first开头end结尾的所有行全部打印\ns命令 sed 's/line/text/g' test.txt 将所有行的line替换为text，g代表全局选项，没有g只替换所有行的第一个匹配项\nsed '/^first.*end$/s/line/text/g' test.txt 匹配以first开头end结尾的所有行，然后将line全部替换为text\nsed 's/\\(.*\\)line$/\\1/g' test.txt 本例中的\\(\\)中包裹的内容表示正则表达式的第n部分，.*表示任意字符串，所以此例相当于删除所有行末的line\n脚本语言备忘录 shell 原文地址\nname=\u0026#34;MyName\u0026#34; //定义变量 echo $name 或 echo ${name} //使用变量 val=`expr 2 + 2` #expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 echo \u0026#34;Total value : $val\u0026#34; 2\u0026gt;\u0026amp;1 把\u0026#34;标准错误输出\u0026#34;重定向到\u0026#34;标准输出\u0026#34; 特殊变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2 $# 传递给脚本或函数的参数个数总和 $* 传递给脚本或函数的所有参数，当被双引号 \u0026quot; \u0026quot; 包含时，所有的位置参数被看做一个字符串 $@ 传递给脚本或函数的所有参数，当被双引号 \u0026quot; \u0026quot; 包含时，每个位置参数被看做独立的字符串 $? 上个命令的退出状态，或函数的返回值 $$ 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。 测试符 描述 -eq，equal 等于 -ne，not equal 不等于 -gt，greater than 大于 -lt，lesser than 小于 -ge，greater or equal 大于或等于 -le，lesser or equal 小于或等于 -z 检测字符串长度是否为 0，为 0 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 待续\npython os 函数名 使用方法 getcwd() 返回当前工作目录 chdir(path) 改变工作目录 listdir(path=\u0026rsquo;.') 列举指定目录中的文件名（\u0026rsquo;.\u0026lsquo;表示当前目录，\u0026rsquo;..\u0026lsquo;表示上一级目录） mkdir(path) 创建单层目录，如该目录已存在抛出异常 makedirs(path) 递归创建多层目录，如该目录已存在抛出异常，注意：\u0026lsquo;E:\\a\\b\u0026rsquo;和\u0026rsquo;E:\\a\\c\u0026rsquo;并不会冲突 remove(path) 删除文件 rmdir(path) 删除单层目录，如该目录非空则抛出异常 removedirs(path) 递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常 rename(old, new) 将文件old重命名为new system(command) 运行系统的shell命令 walk(top) 遍历top路径以下所有的子目录，返回一个三元组：(路径, [包含目录], [包含文件])【具体实现方案请看：第30讲课后作业^_^】 以下是支持路径操作中常用到的一些定义，支持所有平台 os.curdir 指代当前目录（\u0026rsquo;.\u0026rsquo;） os.pardir 指代上一级目录（\u0026rsquo;..\u0026rsquo;） os.sep 输出操作系统特定的路径分隔符（Win下为\u0026rsquo;\\\u0026rsquo;，Linux下为\u0026rsquo;/\u0026rsquo;） os.linesep 当前平台使用的行终止符（Win下为\u0026rsquo;\\r\\n\u0026rsquo;，Linux下为\u0026rsquo;\\n\u0026rsquo;） os.name 指代当前使用的操作系统（包括：\u0026lsquo;posix\u0026rsquo;, \u0026rsquo;nt\u0026rsquo;, \u0026lsquo;mac\u0026rsquo;, \u0026lsquo;os2\u0026rsquo;, \u0026lsquo;ce\u0026rsquo;, \u0026lsquo;java\u0026rsquo;） os.path 函数名 使用方法 basename(path) 去掉目录路径，单独返回文件名 dirname(path) 去掉文件名，单独返回目录路径 join(path1[, path2[, \u0026hellip;]]) 将path1, path2各部分组合成一个路径名 split(path) 分割文件名与路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在 splitext(path) 分离文件名与扩展名，返回(f_name, f_extension)元组 getsize(file) 返回指定文件的尺寸，单位是字节 getatime(file) 返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getctime(file) 返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getmtime(file) 返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） 以下为函数返回 True 或 False exists(path) 判断指定路径（目录或文件）是否存在 isabs(path) 判断指定路径是否为绝对路径 isdir(path) 判断指定路径是否存在且是一个目录 isfile(path) 判断指定路径是否存在且是一个文件 islink(path) 判断指定路径是否存在且是一个符号链接 ismount(path) 判断指定路径是否存在且是一个挂载点 samefile(path1, paht2) 判断path1和path2两个路径是否指向同一个文件 BeautifulSoup from bs4 import BeautifulSoup html_doc = \u0026#34;\u0026#34;\u0026#34; \u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;story\u0026#34;\u0026gt;Once upon a time there were three little sisters; and their names were \u0026lt;a href=\u0026#34;http://example.com/elsie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026#34;http://example.com/lacie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Lacie\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026#34;http://example.com/tillie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link3\u0026#34;\u0026gt;Tillie\u0026lt;/a\u0026gt;; and they lived at the bottom of a well.\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;story\u0026#34;\u0026gt;...\u0026lt;/p\u0026gt; \u0026#34;\u0026#34;\u0026#34; # 解析html_doc soup = BeautifulSoup(html_doc, \u0026#39;html.parser\u0026#39;) # 按照标准的缩进格式的结构输出 print(soup.prettify()) # 选择元素 soup.title # \u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt; # 提取节点信息 soup.title.name # u\u0026#39;title\u0026#39; # 获取属性 soup.p.attrs # {\u0026#39;class\u0026#39;: [\u0026#39;title\u0026#39;], \u0026#39;name\u0026#39;: \u0026#39;Dormouse\u0026#39;} soup.p.attrs[\u0026#39;name\u0026#39;] # Dormouse # 获取文本内容 soup.title.get_text() soup.title.string # u\u0026#39;The Dormouse\u0026#39;s story\u0026#39; # 获取第一个P标签下的所有的子节点，children是迭代器，所以用list转换 list(soup.p.children) list(soup.p.children)[0].text # 获取前面和后面的兄弟节点，迭代器类型 list(soup.a.next_siblings) list(soup.a.previous_siblings) # 找到标签 soup.find(\u0026#39;title\u0026#39;) # \u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt; # 找到所有\u0026lt;a\u0026gt;标签的链接 for link in soup.find_all(\u0026#39;a\u0026#39;): print(link.get(\u0026#39;href\u0026#39;)) # CSS选择器 html_doc = \u0026#34;\u0026#34;\u0026#34; \u0026lt;div class=\u0026#34;panel\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;panel-heading\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;Hello World\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;panel-body\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;list\u0026#34; id=\u0026#34;list-1\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Foo\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Bar\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Jay\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;list list-samll\u0026#34; id=\u0026#34;list-2\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Foo\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Bar\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Jay\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026#34;\u0026#34;\u0026#34; print(soup.select(\u0026#39;.panel-heading\u0026#39;)) # 获取class为panel-heading的节点 print(soup.select(\u0026#39;ul li\u0026#39;)) # 获取ul下的li节点 print(soup.select(\u0026#39;#list-2 li\u0026#39;)) # 获取id为list-2下的li节点 print(soup.select(\u0026#39;ul\u0026#39;)) # 获取所有的ul节点 正则表达式 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n\u0026lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“`(. (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`( (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95 (?\u0026lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?\u0026lt;=95 (?\u0026lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?\u0026lt;!95 x|y 匹配x或y。例如，“`z [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \\d 匹配一个数字字符。等价于[0-9]。 \\D 匹配一个非数字字符。等价于[^0-9]。 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04\u0026amp;1”。正则表达式中可以使用ASCII编码。. *num* 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。 *n* 标识一个八进制转义值或一个向后引用。如果*n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n*为一个八进制转义值。 *nm* 标识一个八进制转义值或一个向后引用。如果*nm之前至少有nm个获得子表达式，则nm为向后引用。如果*nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则*nm将匹配八进制转义值nm*。 *nml* 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 一、校验数字的表达式 1. 数字：^[0-9]*$ 2. n位的数字：^\\d{n}$ 3. 至少n位的数字：^\\d{n,}$ 4. m-n位的数字：^\\d{m,n}$ 5. 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 10. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 12. 非零的负整数：^\\-[1-9][]0-9″*$ 或 ^-[1-9]\\d*$ 13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1. 汉字：^[\\u4e00-\\u9fa5]{0,}$ 2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3. 长度为3-20的所有字符：^.{3,20}$ 4. 由26个英文字母组成的字符串：^[A-Za-z]+$ 5. 由26个大写英文字母组成的字符串：^[A-Z]+$ 6. 由26个小写英文字母组成的字符串：^[a-z]+$ 7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20} 9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 11. 可以输入含有^%\u0026amp;’,;=?$\\”等字符：[^%\u0026amp;’,;=?$\\x22]+ 12. 禁止输入含有~的字符[^~\\x22]+ 其它： .*匹配除 \\n 以外的任何字符。 /[\\u4E00-\\u9FA5]/ 汉字 /[\\uFF00-\\uFFFF]/ 全角符号 /[\\u0000-\\u00FF]/ 半角符号 三、特殊需求表达式 1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%\u0026amp;=]*)?$ 4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 5. 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6. 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7. 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 12. 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 1.有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0″不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了+可以用*替代,如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\n1. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 2. 中文字符的正则表达式：[\\u4e00-\\u9fa5] 3. 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 4. 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 5. HTML标记的正则表达式：\u0026lt;(\\S*?)[^\u0026gt;]*\u0026gt;.*?\u0026lt;/\\1\u0026gt;|\u0026lt;.*? /\u0026gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 6. 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 7. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 8. 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 9. IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) 10. IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 11. IP-v4地址：\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b (提取IP地址时有用) 12. 校验IP-v6地址:(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 13. 子网掩码：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 14. 校验日期:^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。) 15. 抽取注释：\u0026lt;!–(.*?)–\u0026gt; 16. 查找CSS属性:^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 17. 提取页面超链接:(\u0026lt;a\\\\s*(?!.*\\\\brel=)[^\u0026gt;]*)(href=”https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?’.implode(‘|(?:www\\\\.)?’, $follow_list).’))[^” rel=”external nofollow” ]+)”((?!.*\\\\brel=)[^\u0026gt;]*)(?:[^\u0026gt;]*)\u0026gt; 18. 提取网页图片:\\\\\u0026lt; *[img][^\\\\\\\\\u0026gt;]*[src] *= *[\\\\”\\\\’]{0,1}([^\\\\”\\\\’\\\\ \u0026gt;]*) 19. 提取网页颜色代码:^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 20. 文件扩展名效验:^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?”\u0026lt;\u0026gt;|]+\\\\.txt(l)?$ 21. 判断IE版本：^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ ","date":"2021-07-22T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/command/","title":"常用命令"},{"content":"部分电脑配置记录 win10 config git git config --global http.proxy http://127.0.0.1:port.http git config --global https.proxy https://127.0.0.1:port.http 文件路径：C:\\Users\\90487\\.gitconfig，90487是我的用户名\nTerminal（临时使用） set http_proxy=http://127.0.0.1:port.http #临时命令行代理 set https_proxy=http://127.0.0.1:port.http #临时命令行代理 VM Ubuntu config 代理 Windows中使用ipconfig查看VMware Network Adapter VMnet8的ip地址，ubuntu中进入“设置”-“网络”-“proxy”，在Socks Host里写入之前查到的ip地址\ngit config 默认保存在用户的主目录下的 .gitconfig 文件内 git config --global user.name \u0026#34;John Doe\u0026#34; #配置github账号用户名 git config --global user.email johndoe@example.com #配置邮箱 git ssh 代理 创建~/.ssh/config 文件：\nHost github.com User git ProxyCommand nc -v -x ip:port.socks %h %p #写自己ip 终端代理（临时使用）\n方法一：直接在命令前加proxychains\n方法二：在.bashrc最后加入：\nexport http_proxy=\u0026#34;http://ip:port.http\u0026#34; #写自己ip export https_proxy=\u0026#34;http://ip:port.http\u0026#34; #写自己ip source ~/.bashrc #使配置生效 VM Ubuntu升级 # 更新 sudo apt update sudo apt upgrade sudo reboot # 启动 GUI 更新向导 sudo update-manager -c update错误 N: 无法安全地用该源进行更新，所以默认禁用该源 cd /etc/apt/sources.list.d sudo rm -f * # 删除全部软件源 W: Failed to fetch http://archive.ubuntu.com/ 备份您的来源列表 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup\n打开/etc/apt/sources.list粘贴这里对应地区和版本的sources.list条目\n# DNS 设置 sudo vim /etc/resolv.conf # 使用Google DNS作为首选 DNS 服务器 nameserver 8.8.8.8 nameserver 8.8.4.4 VM Ubuntu克隆 1. 概念\n虚拟机克隆 完整克隆 是和原始虚拟机完全独立的一个备份，可以脱离原始虚拟机独立使用 链接克隆 需要和原始虚拟机共享同一虚拟磁盘文件，不能脱离原始虚拟机独立运行 虚拟机模板克隆 克隆虚拟机固然是快速部署虚拟机的利器，但是所有的虚拟机都可以克隆，被克隆的虚拟机也可以再次被克隆，长此以往系统就会崩毁，从而给管理员带来诸多的麻烦。模板就是解决此问题的最好的方法，即将一台经常发起克隆的虚拟机做成虚拟机模板，每次需要克隆类似的虚拟机时都通过模板发起 虚拟快照 快照是针对虚拟机的VMDK文件在某一时间点的\u0026quot;备份\u0026quot;，快照任务启动时，将冻结虚拟机源VMDK文件处于只读状态，同时创建出1个快照文件，今后所有修改的数据都会写入这个快照文件。一旦触发快照恢复操作。系统将放弃文件的内容，回滚到源VMDK文件的状态，实现快照恢复 2. 模板克隆过程\n关机 -\u0026gt; 创建快照 -\u0026gt; 虚拟机、设置、高级、启用模板模式 -\u0026gt; 右键虚拟机克隆 -\u0026gt; 从快照克隆 -\u0026gt; 完整克隆\n3. 解决IP相同问题\n在虚拟机的网络设置 -\u0026gt; 高级 -\u0026gt; 点击生成新的mac地址\ncd /etc/netplan sudo gedit 01-network-manager-all.yaml # 添加内容 network: ethernets: ens33: dhcp4: true # 动态ip开启 dhcp-identifier: mac # 将DHCP获取IP地址的标识改为mac version: 2 # 更新配置 sudo netplan apply Ubuntu安装go sudo apt install snap #安装snap，使用snap更易安装、更新 sudo snap install go --classic #安装go sudo vim /etc/profile #编辑profile export GOROOT=/snap/go #在最后一行添加 export PATH=$PATH:$GOROOT/bin source /etc/profile #保存 go version #验证 export GO111MODULE=on export GOPROXY=https://goproxy.cn #设置 go get 为国内源（无代理） Goland 使用 goland无限试用，方法适用IDEA系列\ngoland中添加第三方插件仓库地址：https://plugins.zhile.io 安装插件：IDE Eval Reset 下载 直接把zip包拖进IDE的窗口来进行插件的安装 Help -\u0026gt; Eval Reset 勾选Auto reset before per restart 原文地址，本段仅进行简述，使操作简明\n不能输入中文（Ubuntu） 在goland.sh注释之后的首行添加\nexport XMODIFIERS=\u0026#34;@im=ibus\u0026#34; export GTK_IM_MODULE=\u0026#34;ibus\u0026#34; export QT_IM_MODULE=\u0026#34;ibus\u0026#34; goland.vmoptions添加-Drecreate.x11.input.method=true\nWin10 系统问题 文件夹分类管理 在要分类的文件夹下新建desktop.ini文件 [.ShellClassInfo] InfoTip=分类名称 另存为，保存类型：所有文件，编码：ANSI\n生效：文件夹属性 -\u0026gt; 自定义 -\u0026gt; 更改图标 -\u0026gt; 还原默认值\n文件夹查看 -\u0026gt; 分组依据 -\u0026gt; 选择备注\n修改删除：文件夹查看 -\u0026gt; 选项 -\u0026gt; 查看 -\u0026gt; 取消选中\u0026quot;隐藏受保护的操作系统文件（推荐）\u0026ldquo;可以看到ini文件\n文件删不掉 TASKKILL /IM explorer* /F # 关掉任务栏 explorer.exe # 开启任务栏 管理员权限 方法一： cmd -\u0026gt; 输入 gpedit.msc 方法二： 添加右键超级管理员权限，新建1.reg文件并运行\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell\\runas] @=\u0026#34;获取超级管理员所有权限\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Windows\\\\System32\\\\imageres.dll,101\u0026#34; \u0026#34;NoWorkingDirectory\u0026#34;=\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\*\\shell\\runas\\command] @=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F\u0026#34; \u0026#34;IsolatedCommand\u0026#34;=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F\u0026#34; [HKEY_CLASSES_ROOT\\exefile\\shell\\runas2] @=\u0026#34;获取超级管理员所有权限\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Windows\\\\System32\\\\imageres.dll,101\u0026#34; \u0026#34;NoWorkingDirectory\u0026#34;=\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\exefile\\shell\\runas2\\command] @=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F\u0026#34; \u0026#34;IsolatedCommand\u0026#34;=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\runas] @=\u0026#34;获取超级管理员所有权限\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Windows\\\\System32\\\\imageres.dll,101\u0026#34; \u0026#34;NoWorkingDirectory\u0026#34;=\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command] @=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; /r /d y \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F /t\u0026#34; \u0026#34;IsolatedCommand\u0026#34;=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; /r /d y \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F /t\u0026#34; 关闭Win10防火墙通知 控制面板-\u0026gt;安全与维护-\u0026gt;更改用户账户控制设置-\u0026gt;从不通知\n搜索\u0026quot;编辑组策略\u0026rdquo;-\u0026gt;管理模板-\u0026gt;windows组件-\u0026gt;windows安全中心-\u0026gt;通知-\u0026gt;打开隐藏所有通知-\u0026gt;已启用\n从注册表彻底关闭 Windows安全中心 win+R输入regedit，定位到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SecurityHealthService，找到Start，修改数值数据3为4。\nWin10 资源管理器无限重启闪屏 安全模式开机\n长按开机键3次，选择【疑难解答】-【高级选项】-【启动设置】- 【重启】，在启动设置内， 按 4 或 F4 就可以进入安全模式了。\n更换本地账户、新建本地账户。\n开机后右键windows图标点击 powershell（管理员）\n在命令提示符(管理员)中复制粘贴输入以下指令：\nnet user User ****** /add (User是新建账户，******是新建的随机密码)　net localgroup administrators User /add (赋予该账号管理员权限)\n重启后按电源键息屏，再开启后可以切换到User账户，进去后一切正常，表示故障原因不在硬件和系统方面，肯定是第三方软件。\n新建文本粘贴以下代码\nWindows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\\LocalDumps\\explorer.exe] \u0026#34;DumpFolder\u0026#34;=hex(2):43,00,3a,00,5c,00,43,00,72,00,61,00,73,00,68,00,44,00,75,\\ 00,6d,00,70,00,73,00,00,00 重命名为1.reg，运行后会在C盘建立CrashDumps文件夹（路径C:\\CrashDumps），当系统闪屏后里面有后缀.dmp文件，把这个文件拖到Visual Studio里打开，可以排查相关的第三方软件的路径，挨个卸载。我放在vs里显示我IDM下载程序缺少二进制文件，卸载后完美进入系统。\n自用软件 本文软件均为自用，本人无意推广任何软件，所以下载地址请自行查找，一般在google可找到官方，或者在52论坛搜搜看\nwin10优雅必备 Wallpaper Engine　# 壁纸，steam购买\nEverything + uTools　# 文件快捷搜索及工具\nquicker　# 鼠标便捷操作神器\nDeskGo　# 腾讯出品的桌面软件格子\nGeek Uninstaller　# 卸载无残留\nclover　# 资源管理器多标签页\n火绒　# 屏蔽弹窗\n开发者实用工具\ntypora　# markdown记事本 joplin # markdown多端同步 Pr # 视频剪辑 Ae # 动画特效 Ps # 图片处理 Ai # 插图 win10 microsoft store工具\nWindows Terminal　#命令行 TranslucentTB　#任务栏透明 EarTrumpet　#音频管理 安卓app 浏览器：Chrome、Kiwi、三星浏览器、x浏览器\n影视：\n论坛haopanyou.net zd01.tv下载 + AdGuard　# AdGuard设置复杂请自行研究，去除视频开头广告可在日志中找到广告，把这几个广告网站地址添加到自定义过滤 音乐：lx-music　# 并不完美，希望找到更好用的\n小说：阅读　# 酷安评论区可以找书源\n阅读：ReadEra、福昕PDF阅读器\n去除启动广告：跳过广告\n手机控制\nMacroDroid、hamibot　# 手机自动化 Moonlight　# 局域网流畅投屏 AirDroid和AirMirror　# 手机远程控制手机 向日葵远程控制 其他\nzarchiver　# 文件管理和解压 星空视频壁纸 Sendapp # 提取apk ES文件浏览器 # 访问局域网文件 ","date":"2021-07-18T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/config/","title":"环境配置和软件"},{"content":"准备 1.Ubuntu\nsudo apt update # 更新 2.github账号\n3.git配置 默认保存在用户的主目录下的 .gitconfig 文件内\ngit config --global user.name \u0026#34;John Doe\u0026#34; # 配置github账号用户名 git config --global user.email johndoe@example.com # 配置邮箱 4.连接github\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # 生成SSH Keys 此为新版 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; # 此为旧版 cat ~/.ssh/id_ed25519.pub # 复制 点击github右上角头像-\u0026gt; Settings -\u0026gt; SSH and GPG Keys -\u0026gt; New SSH key添加\nssh -T git@github.com # 验证连接，输入yes 官方文档\n5.git ssh 代理设置\n非必要步骤，如果有一天ssh push网速极慢但https push正常，可尝试此操作\n创建~/.ssh/config 文件：\nHost github.com User git ProxyCommand nc -v -x 127.0.0.1:10808 %h %p # 请修改127.0.0.1:10808 安装 snap install hugo --channel=extended # 安装hugo hugo version # 验证 hugo new site myblog # 创建博客 git init # 初始化 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 删掉themes文件夹，安装stack主题作为子模块 rm config.toml \u0026amp;\u0026amp; cp themes/hugo-theme-stack/exampleSite/config.yaml . # 使用主题的配置文件 把myblog/themes/hugo-theme-stack/exampleSite/content内容移到myblog/content使用主题示例文章\n本地预览： myblog下执行\nhugo server 浏览器打开：\nhttp://localhost:1313/ 部署 注：我将介绍使用github托管源码自动化部署，如果您仅在本地存放源码，提交public文件夹即可，无需使用下列方法。\n1.虽然博客内容全都能看到，但我们可能不太希望公开源码，不开放源码使用github pages需要创建2个仓库: 创建 username.github.io.source 仓库存放源码可设为私人仓库，创建 username.github.io 仓库作为公开仓库\ngit remote add origin git@github.com:******.github.io.source.git # 连接远程仓库。注意使用ssh连接，如果使用https连接每次都要输账号密码。 点击github右上角头像-\u0026gt; Settings -\u0026gt; Developer Settings-\u0026gt; Personal access tokens -\u0026gt; Generate new token （Note随意，Select scopes全选,复制token，我们这里使用Personal tokens比Deploy keys更方便）\n找到源码仓库Settings-\u0026gt; Secrets and variables -\u0026gt; Actions -\u0026gt; New repository secret （Name写PERSONAL_TOKEN，Value粘贴token）\n2.创建github actions的workflows自动部署文件：\nmkdir -p .github/workflows \u0026amp;\u0026amp; touch ~/myblog/.github/workflows/main.yml 粘贴脚本：\nname: github pages on: push: branches: - master jobs: deploy: runs-on: ubuntu-latest #可 使用指定版本，例：runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest # 可使用指定版本，例：hugo-version: \u0026#39;0.83.1\u0026#39; extended: true - name: Build run: hugo --gc --forceSyncStatic --minify --cleanDestinationDir - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} # PERSONAL_TOKEN是源码仓库secrets的name external_repository: username/username.github.io # Pages 远程仓库 publish_branch: master # 部署的分支 publish_dir: ./public commit_message: ${{ github.event.head_commit.message }} #cname: www.example.com # 使用自定义域名 只需更改external_repository: username/username.github.io 为你的github账户名，脚本详情\n3.在myblog文件夹下创建push.sh\ntouch push.sh 粘贴脚本：\n#!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master 在myblog下运行 sh push.sh命令。\n到此已完成部署，之后任何更新如上运行push脚本即可\n修改主题 此处仅列举常见需修改内容，更多内容请看stack主题文档\n本博客修改样式来自rmdhnreza\n更多定制文章可以参考这里\n主题配置 1.修改~/myblog/config.yaml\n1 baseurl: https://username.github.io # 改为自己的 2 languageCode: zh-CN # 中文编码 4 paginate: 10 # 文章分页数 5 title: Example Site # 博客名字 30 DefaultContentLanguage: zh-cn # 中文 34 hasCJKLanguage: true # 正确计数中、日、韩文语言的字数 48 since: 2021 52 published: 2006-01-02 # 日期格式 53 lastUpdated: 2006-01-02 # 更新日期格式 56 emoji: 🍥 # 头像角标 57 subtitle: # 博客名下的简介 61 src: img/avatar.png # 头像，myblog/themes/hugo-theme-stack/assets/img 135 name: \u0026#39;首页\u0026#39; # 改中文左侧菜单home 155 startLevel: 1 # 从文章1级标题使用文章目录 195 unsafe: true # 允许Markdown嵌入html 2.左侧菜单栏 ~/myblog/content/page用于左侧菜单，请自定义\n2 title: \u0026#39;关于\u0026#39; #中文左侧菜单about，后同 3.覆盖主题样式\n直接在~/myblog下复制rmdhnreza的assets、layouts/shortcodes文件夹。\n另外修改：\n~/myblog/assets/scss/variables.scss\nlink-background-color: 0, 255, 255 链接背景颜色 注：浏览器可能缓存样式，可使用无痕模式\n创建文章 hugo new post/文件夹名/index.md #创建文章 写文章：\n1.front matter:\n--- title: hugo使用stack主题搭建博客及部署 #标题 description: #副标题，此样式不可用 date: 2021-07-04 #日期 lastUpdated: 2021-07-27 #上次修改内容的日期 slug: hugo-blog #URL的尾部，用于文章地址 categories: #文章分类 - blog --- front matter仅列举本文使用，hugo front matter官方文档\n2.常见文章markdown语法：\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n`单行代码` `` 有`需用双反引号 ``\n```html\n多行代码\n```\n[链接](https://)\n\\ 写在特殊符号前为转义；写在行尾为换行\\\n*斜体*\n**加粗**\n~~删除线~~\n* 无序列表\n双空格* 子无序列表\n![图片描述](本地图片.jpg)\n表格\n| Italics | Bold | Code | | -------- | -------- | ------ | | *italics* | **bold** | `code` | shortcodes ./myblog/layouts/shortcodes\n{{\u0026lt; spoiler text=\u0026quot;点击展开和折叠代码\u0026quot; \u0026gt;}}\n```html\ncode\n```\n{{\u0026lt; /spoiler \u0026gt;}}\n{{\u0026lt; typography font=\u0026quot;monoton\u0026quot; size=\u0026quot;30px\u0026quot; style=\u0026quot;normal\u0026quot; weight=\u0026quot;bold\u0026quot; color=\u0026quot;blue\u0026quot;\u0026gt;}} 自定义字体 {{\u0026lt; /typography \u0026gt;}}\n# font　Google 字体\n# size　大小\n# style　normal正常， italic 斜体\n# weight　bold 加粗 ， lighter 更细\n{{\u0026lt; box info \u0026gt;}} Hello there, and have a nice day {{\u0026lt; /box \u0026gt;}} Hello there, and have a nice day\n{{\u0026lt; box warning \u0026gt;}} Hello there, and have a nice day {{\u0026lt; /box \u0026gt;}} Hello there, and have a nice day\n{{\u0026lt; box important \u0026gt;}} Hello there, and have a nice day {{\u0026lt; /box \u0026gt;}} Hello there, and have a nice day\n{{\u0026lt; box tip \u0026gt;}} Hello there, and have a nice day {{\u0026lt; /box \u0026gt;}} Hello there, and have a nice day\n评论系统 waline官方文档写得非常清楚，您只需 LeanCloud设置 和 部署到Vercel ，拿到URL\n然后修改~/myblog/config.yaml\n52 provider: waline #评论系统，本文示例使用waline 73 serverURL: https:// #评论系统URL用你自己的 执行sh push.sh即可\n自定义域名 在~/myblog/config.yaml修改baseurl: https://username.github.io\n在~/myblog/.github/workflows/main.yml最后一行取消注释并修改cname: www.example.com\n执行sh push.sh即可\n启用https：参考链接\n没有域名？为了白嫖可在freenom和cloudflare进行申请域名和解析，这可能花费一些时间，如对此没有了解建议暂时跳过自定义域名。\nfreenom脚本自动续期参考后续文章\n","date":"2021-07-03T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/hugo-blog/","title":"hugo使用stack主题搭建博客及部署"}]