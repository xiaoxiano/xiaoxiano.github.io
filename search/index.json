[{"content":"原文地址\nAPI 是什么？ API的英文即 Application Programming Interface 首字母的缩写。不要被这么长的单词吓到，直译过来的意思就是：程序之间的接口。我更倾向于把API理解为，程序之间的合约。有关 API 是什么及它的意义这里就不展开讲了。\nPostman 是什么？ Postman 是一款 API 开发协作工具，它可以帮助你测试和开发 API，Postman 提供了测试 API 的友好界面和功能，使用简单便捷，安全可靠。Postman 是 API 接口测试工具的 Top 3，因为它简单可靠又免费，目前有超过 800 万开发者用户使用。特别是 API 批量测试功能，在近几次的大版本更新中，用户体验得到了极大的提升。Postman 是每一位前后端开发者必掌握的开发工具。\n如何安装 Postman 如何安装 Postman\n前往 Postman 官网免费下载，安装非常傻瓜，这里就不展开写了，如果安装过程有任何问题，欢迎评论区提问。\nPostman 支持 Windows、Mac 和 Linux，也可以直接跑在浏览器里，跨平台，使用相当便捷。\nAPI 模拟工具 GoRest 本教程使用模拟 API 工具 GoRest 进行模拟 API 测试。GoRest 有非常多的使用场景，比如，后端接口还没有准备好时，我们可以先用 GoRest 模拟测试，又或者你自己暂时不想搞服务器，也不想搭后端，也可以先用 GoRest 来测。\nGoRest 可以理解为后端工程师帮你搭好了后端服务器，而且是完全测过的，几乎不可能有 Bug。GoRest 除了其中的数据是模拟的，所有 API 响应都是完全真实的，你可以通过 API 调用的返回数据判断你的前端是否有问题。\nGoRest 的 API 调用 URL 及规则。\n通常 API 由 BaseURL + Endpoint 构成。比如上图中第一个 Resources：\nhttps://gorest.co.in/public/v1/users 这个 API 是由 https://gorest.co.in + /public/v1/users 即 BaseURL +Endpoint 组成的。一般我们可以从 API 地址看出调取信息的大意，这段 URL 是调用 GoRest 上有关 users 的信息。\n下一节，我们使用 GET 请求调用这个 API ，看看返回结果是不是与 users 信息有关。\n用 Postman 发出第一个 GET 请求 GET 请求基本操作 GET 请求是 API 中使用最频繁的请求之一，GET 请求仅从数据库中请求读取数据，不会修改服务器中的数据。\n接下来，我们来创建一个基本的 GET 请求\n（1）点击主界面「+」号，新建一个请求页\n（2）选择 GET 请求命令\n（3）输入 API 地址：\nhttps://gorest.co.in/public/v1/users 在 GoRest API 设计中 GET 请求无需鉴权（下一节 POST 请求会讲解 API 鉴权问题），所有我们直接点击「Send」即可远程调取服务器信息。\n点击「Send」，我们可以看到下方的 Body 显示了 GET API 返回值，第一段落是 users 信息概览，下面是一组组 user 信息。\n如果我们只想看调取其中一位用户的信息应该怎么办呢？我们可以在 API URL 中带上参数。\n带参数的 GET 请求 如果我们想查询 ID 为 2043 的用户信息，我们只需要在请求页面中的 Params(参数) 标签页的 KEY - VALUE 内填写对应的参数即可，之后 Postman 会自动在 API URL 中生成你填写的参数，使 URL 带上参数 GET 请求。\nhttps://gorest.co.in/public/v1/users?id=2043 设置完成后，点击「Send」\n我们可以看到，返回值中仅包含我们请求的 user id 为 2043 的用户信息。\nGET 请求中的多条件查询 有时，我们需要使用 API 进行多条件查询操作，比如想找 name 值为 kalacloud.com ，同时 gender 值为 male 的用户。（特别提示：此格式是通用写法，但最终要看 API 的开发者如何约定调用方式）\nBaseURL + ResourceName + ? + key1 = value1 + \u0026amp; + key 2 = value 2 …… 主 URL 之后使用 ? 连接参数，参数与参数之间使用 \u0026amp; 连接符连接。\nhttps://gorest.co.in/public-api/users/?name=kalacloud.com\u0026amp;gender=male 当然，我们可以直接在 Postman 的 Params 中直接填写 KEY - VALUE\n让 Postman 帮我们生成，然后点击「Send」\n可以看到 API GET 调取了我们设定的两个 VALUE 值的 data 信息。\n特别提示，你可以点击右上角的「Bulk Edit」进行参数的批量编辑\n在 Postman 中发送 POST 请求 这一节我们讲 POST 请求，POST 请求和 GET 请求最大的区别是 GET 请求仅使用只读形式读取数据，而 POST 请求会修改服务器中的数据，比如创建新用户，创建用户信息，上传图片等操作都是用 POST 完成的。\nPOST 请求前，使用 Postman 对 API 鉴权 POST 不再仅仅是读取数据，会涉及到对数据的写入，这种敏感的操作，一定会涉及到账号鉴权操作。\nGoRest 模拟 API 工具使用 HTTP Basic Authentication 鉴权方式\n这种鉴权方式可以直接放在 Headers 中以 Key - Value 的形式进行验证，本教程演示稍微复杂点的 OAuth2 鉴权方式，好让大家学到更多。\n首先在 GoRest 注册账号，然后点击顶部的「Rest Console」进入控制页，我们可以在这个页面获得自己的 Auth Token，这段就是 API 用于鉴权的密钥。\n在 Postman 请求页的 Auth 标签中，选择鉴权类型（Type）为 OAuth 2.0，然后在 Access Token 中填写网页上的这段 Value 后，在请求类型中选择 POST，输入 API 请求地址\nhttps://gorest.co.in/public/v1/users 然后点击「Send」\n如果 HTTP 响应代码返回 422，表示鉴权成功，只是没有填写数据。\n特别提示：在本案例中使用的GoRest API 是先检测 Token 是否正确，之后在检测 body 等信息。也有先检测提交信息是否正确再鉴权的 API，这取决于 API 的开发者怎么设定，那么这种情况 422 就不代表鉴权成功。所以谨慎起见，所有 4XX 开头的响应代码，你都可以理解为出现了错误。\n如果返回 401 说明鉴权验证失败（Authentication failed）你的 Token 可能复制错了，请检查后再试。\n鉴权成功后，下一节，我们通过 API POST 请求将第一组数据写入服务器数据库。\n（2）用 Postman 发出第一个 POST 请求\n上一节，我们通过 API Token 鉴权成功，下面我们在请求页设置 POST 请求信息。\n1.请求命令选择 POST，然后在地址栏填写 API 地址：\nhttps://gorest.co.in/public/v1/users 2.在「Auth」标签页根据本文上一小节设置 API 鉴权 Access Token\n3.在 Body 中选择 raw 然后选择 JSON 格式。\n4.将下列 JSON 代码填入编辑框，此为本次 POST 发送给服务器的内容。\n5.我们将注册一个新用户，用户信息包含在这个 JSON 文本里。\n{ \u0026#34;name\u0026#34;: \u0026#34;kalacloud\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;Male\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;JiangChuan@kalacloud.com\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;Active\u0026#34; } 最后，点击「Send」，发送 POST 请求。\n我们可以看到 API 返回信息，已经在服务器中注册好新用户，新用户 ID 为 2151，并一起返回了我们刚刚提交的用户注册信息。\n如果你也看到了类似的返回结果，那么恭喜，你的第一个 POST 请求被服务器成功接受，你通过 API 在服务器上注册了一个新用户。\n扩展阅读：最好的 6 个免费天气 API 接口对比测评\n用 Postman 发送第一个 PUT 更新请求 PUT 请求一般用于更新服务器已有资源，如果服务器中没有对应的资源，那么 PUT 会创建相应的资源（特别提醒：虽然 PUT 有创建新资源的功能，但是否能创建成功，最终取决于你调用的 API 是否支持此功能）\n打开你的 Postman 我们来创建一个 PUT 请求。\n点击「+」号，新建一个请求页\n请求类型选择「PUT」\n根据第6节我们使用 POST 请求创建的资源 ID 为 1475 ，又根据 GoRest API 的文档得知，修改资源的 API 地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PUT 修改 ID 为 1475 资源的请求地址应该写：\nhttps://gorest.co.in/public/v1/users/1475 选择在 Body 标签中填写 JSON 格式的资源修改信息。我们将 1475 中的邮箱由\nJiangChuan@kalacloud.com 修改为 Hi@kalacloud.com，所以我们在 Body 中填写以下代码。\n{ \u0026#34;name\u0026#34;: \u0026#34;kalacloud\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;Male\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;Hi@kalacloud.com\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;Active\u0026#34; } 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 PUT 请求 如上图所示，可以看到红4位置 响应代码返回 200 ，这说明 PUT 请求已经执行成功。 返回的 Body 信息中，email 字段已经更新为 Hi@kalacloud.com 用 Postman 发送第一个 PATCH 更新请求 PATCH 请求一般用于服务器资源的部分更新，它相对于 PUT 提交的数据更少，不用提整个数据，只需要提交需要修改的字段即可。有关 PUT 和 PATCH 的更多区别，可查看本文第9节。\n打开你的 Postman 我们来创建一个 PATCH 请求。\n点击「+」号，新建一个请求页\n请求类型选择「PATCH」\n根据第6节我们使用 POST 请求创建的资源 ID 为 1475 ，又根据 GoRest API 的文档得知，修改资源的 API 地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PATCH 修改 ID 为 1475 资源的请求地址应该写，到这里都和 PUT 请求修改资源的方法一样。\nhttps://gorest.co.in/public/v1/users/1475 选择在 Body 标签中填写 JSON 格式的资源修改信息。上一节我们已经将 ID 为 1475 资源的邮箱改为 Hi@kalacloud.com ，接着我们用 PATCH 请求把这个邮箱改为\nHelloWord@kalacloud.com { \u0026#34;email\u0026#34;:\u0026#34;HelloWord@kalacloud.com\u0026#34; } 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 PATCH 请求 如上图所示，可以看到红4位置 响应代码返回 200 ，这说明 PATCH 请求已经执行成功。\n返回的 Body 信息中，email 字段已经更新为\nHelloWord@kalacloud.com PUT 和 PATCH 的区别 在 HTTP 协议中，PUT 和 PATCH 都是用于更新服务器资源的命令，但他们有着不同的格式和用途。\nPUT 请求：一般用于更新服务器已有资源，如果服务器中没有对应的资源，那么 PUT 会创建相应的资源（特别提醒：虽然 PUT 有创建新资源的功能，但是否能创建最终取决于你调用的 API 是否支持此功能）\nPATCH 请求：用于局部更新服务器现有资源，它不用像 PUT 更新资源中的一点点也要提交所有字段信息，PATCH 更新哪个字段就提交哪个字段的更新信息即可。\n举例说明PUT 和 PATCH 的区别：\n同样是更新资源中的 Email 信息，PUT 需要带上资源中的所有信息，然后在更新（上图）\n而 PATCH 则仅需要提交更新部分，即仅提交邮箱信息即可（下图）\n那么，如果 PUT 像 PATCH 一样仅提交资源的局部信息会发生什么呢？会 400 报错。\nPUT 不论修改多少，必须把修改资源的全部字段写全，否则会 400 报错。\n用 Postman 发送第一个 DELETE 删除请求 我们在上文讲了获取(GET)，创建(POST)，更新(PUT / PATCH) 请求，接着我们来说说删除(DELETE) 请求。顾名思义，DELETE 请求执行可删除整个资源。我们来直接实践一次你就明白了。\n打开你的 Postman ，跟随本教程一起创建一个 DELETE 请求。\n点击「+」号，新建一个请求页\n请求类型选择「DELETE」\n我们来把上文刚刚创建的 ID 为 1475 的资源彻底删掉。根据 GoRest API 的文档得知，删除资源的 API 请求地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PATCH 删除 ID 为 1475 资源的请求地址应该写：\nhttps://gorest.co.in/public/v1/users/1475 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 DELETE 请求，删除对应的资源。 如上图所示，提交 DELETE 请求后，响应代码为 204 ，返回的 body 为空，删除成功。\n特别提示：在 GoRest 的文档说明中，特别说了 DELETE 删除返回值的状态。\nAPI 返回状态具体是怎么样的，还要看 API 的开发者是如何约定的，并非只有返回 200 才是成功的。\nPostman 中的全局变量、环境变量、集合变量的设置 Postman 设置变量的意义 Postman 里有多种变量，我们可以把某些重要的值抽象出来变成变量，方便我们做场景 / 条件切换。比如，我们可以把 baseURL 抽出来，在环境变量里设置「生产环境变量」和「测试环境变量」，之后，我们只需要切换标签即可快速将数据从一个环境切换到另一个环境中，非常方便。\nPostman 常用的三种变量形式 全局变量：全局变量一旦声明，即可应用到 Postman 中所有测试的 API 中。任何请求都可以直接使用全局变量，它的作用域是全局的。 环境变量：Postman 的环境变量可以理解为一组选项，当这组环境变量选项被选中时，才会生效，特别适合「生产环境」和「测试环境」之间的切换等应用场景。 集合变量：集合变量是针对集合（Collections）生效的，一个集合下可能有 N 条 API 请求，集合变量可以一次修改集合下的所有变量数值。 以上三种变量的作用域从大到小为 全局 集合 环境，当三个变量形式同时作用于一个 API 测试条时，Postman 会优先使用最小作用域变量。\n如何在 Postman 设置全局变量与环境变量 新建一个请求页，点击右上角的「小眼睛」进入变量设置页。 页面上方为「环境变量」，我们点击编辑设置环境变量名为「卡拉云_API 测试环境」 VARIABLE 设置为 baseURL，INITIAL VALUE 设置为 https://gorest.co.in ，保存之后我们就可以使用 {{baseURL}} 变量来替代 API URL 了。 页面下方为「全局变量」，VARIABLE 设置为 kalacloud_id，INITIAL VALUE 设置为 2312 (2312 为 GoRest 中的一个已存在的用户信息 ID)，保存后我们就可以使用 {{kalacloud_id}} 变量来替代 ID 值了。 我们来一起测一下刚刚设置好的「全局变量」和「环境变量」是否生效。\n新建一个 GET 请求页，地址栏填入： {{baseURL}}/public/v1/users?id={{kalacloud_id}} 点击「Send」 返回响应代码为 200 说明请求成功，返回的 Body 信息是 ID 为 2312 的用户信息，说明全局和环境变量已生效。\n如何在 Postman 设置集合变量 集合变量是指应用在整个集合所有请求中的变量，集合变量优先与其他变量应用与请求，也就是说如果有集合变量，那么其他变量与集合变量相冲突的化，优先执行集合变量。\n集合变量很适合临时修改整个集合中的变量，来针对集合进行测试。\n打开你的 Postman，我们一起操作一遍。\n选中一个集合，点击集合标题右侧「\u0026hellip;」选择编辑。 进入集合设置页，选择 Variables 设置集合变量 此时，整个集合下所有请求页，都应用了此集合变量。 如何使用 Postman Pre-request scripts 预请求脚本 Pre-request scripts 预请求脚本是在 API 请求之前执行的脚本，我们可以临时更改请求的某些变量。一般预请求脚本有这么两种常见的应用场景。(1)设置动态请求头信息。 (2)设置动态请求参数信息。比如，当我们要请求一个与时间有关的资源时，我们可以在预请求脚本中添加 timestamp 字段，这是一个动态值，我们可以通过前置请求脚本来实现。\n举例说明：比如我们要在 header 中包含一个时间戳，我们可以这样操作\n在 Pre-request scripts 中添加获取时间戳的代码 pm.environment.set(\u0026#34;TimeStampHeader\u0026#34;,new Date()); 在 header 中添加预脚本中的变量 TimeStampHeader 当请求时，Postman 会先执行预脚本获取时间戳，然后再将时间戳赋予到 header 中 timestamp 值中。 接着我们来执行这条 GET 请求，打开控制控制台，在控制台中，可以看到 Request Headers 中包含我们刚刚设置的时间戳 「timestamp」特别提示：有关控制台的讲解，在本教程第14节。 附：常用的 Pre-request scripts ：\n获取变量\n//通用语法 postman.getGlobalVariable(\u0026#34;key\u0026#34;); //获取全局变量 postman.getEnvironmentVariable(\u0026#34;key\u0026#34;); //获取环境变量 //postman native app 特有语法 pm.globals.get(\u0026#34;key\u0026#34;); //获取全局变量 pm.environment.get(\u0026#34;key\u0026#34;); //获取环境变量 设置变量\n//通用语法 postman.setGlobalVariable(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置全局变量 postman.setEnvironmentVariable(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置环境变量 //postman native app 特有语法 pm.globals.get(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置全局变量 pm.environment.get(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //设置环境变量 清除变量\n//通用语法 postman.clearGlobalVariable(\u0026#34;key\u0026#34;); //清除全局变量 postman.clearEnvironmentVariable(\u0026#34;key\u0026#34;); //清除环境变量 //postman native app 特有语法 pm.globals.unset(\u0026#34;key\u0026#34;); //清除全局变量 pm.environment.unset(\u0026#34;key\u0026#34;); //清除环境变量 将数组、嵌套对象存储到全局\u0026amp;环境变量中\n//将数组储存到环境变量中 var array = [1, 2, 3, 4]; postman.setEnvironmentVariable(\u0026#34;array\u0026#34;, JSON.stringify(array)); //将嵌套对象储存到环境变量中 var obj = { a: [1, 2, 3, 4], b: { c: \u0026#39;val\u0026#39; } }; postman.setEnvironmentVariable(\u0026#34;obj\u0026#34;, JSON.stringify(obj)); //从环境变量中获取数组对象 var array = JSON.parse(postman.getEnvironmentVariable(\u0026#34;array\u0026#34;)); //从环境变量中获取嵌套对象/json对象 var obj = JSON.parse(postman.getEnvironmentVariable(\u0026#34;obj\u0026#34;)); 如何创建 Postman Tests 测试脚本 - Postman 断言功能 在 Postman 中 Pre-request 和 Tests 是两兄弟，一个是在调用前执行（Pre-request），一个是在调用后执行（Tests），我们可以在 Tests 中使用 JavaScript 校验代码协助我们验证结果，可以说 Tests 是 Postman 的断言功能\nPostman Tests 断言的实际应用 Postman 状态类断言 1.我们首先创建一个 GET 请求，然后点击 Postman 中 Tests 标签，进入断言设置。\n2.我们可以在右侧已经预设好的断言代码，我们先点击「Status code: Code is 200」，可以看到预设的代码直接写入编辑框。这段代码的意思是，如果执行调用，服务器返回响应代码为 200 时，判断为 PASS 即调用成功。\n3.点击「Send」执行 GET 请求，返回的断言可以在 Test Results 中看到结果。\n4.绿色的 PASS，说明服务器返回的响应代码为 200 ，调用成功。\nPostman 结果比较类断言 我们再添加一条带有变量的 JavaScript 断言设置，比较预期结果和实际返回结果之间是否一致。\n我们刚刚 GET 请求了 ID 2312 的用户信息，其中 name 的值为 kalacloud\n那么我们接下来写一个 JS 判断预期与返回结果是否一致。即预期为 name 的值为「kalacloud」，写断言自动判断返回结果的name值是否也是「kalacloud」\n1.在 Tests 选项卡右侧选择「Response body:JSON value check」，我们来检测 ID 为 2312 的返回值中，name 的值是否为 kalacloud\n2.我们将「Your Test Name」替换为「检查 ID 为 2312 的 name 返回值为 kalacloud」让这条测试的名字直接反应出我们想测试的内容。\n3.使用\njsonData.data[0].name 代替jsonData.value ，即检测第一个返回值中的 name 的 value\n4.检测返回值：在 to.eql() 中输入待检测值 \u0026quot;kalacloud\u0026quot;，即需要检测的 text。\n5.代码如下，你可以复制并根据你的情况简单修改，然后在 Postman 中，跟随教程一起测试。\n特别注意：这里的 ID = 2312 是我这里的情况，你需要根据你的情况进行相应修改。\npm.test(\u0026#34;Status code is 200\u0026#34;, function () { pm.response.to.have.status(200); }); pm.test(\u0026#34;检查 ID 为 2312 的 name 返回值为 kalacloud\u0026#34;, function () { var jsonData = pm.response.json(); pm.expect(jsonData.data[0].name).to.eql(\u0026#34;kalacloud\u0026#34;); }); 如何在 Postman 中使用控制台 控制台可以非常直观的显示当前调用的一系列信息，我们可以在「菜单 → view → Show Postman Console」或者点击 Postman 左下角的「Console」图标，打开控制台。\n我们可以在 Tests 测试脚本中加入 console.log 来显示我们需要在控制台显示的调用信息。\n如上图，我们在 Test 脚本中加入以下代码\nconsole.log(\u0026#34;本次测试 id 值为\u0026#34;,pm.variables.get(\u0026#34;kalacloud_id\u0026#34;)); 可以显示隐藏在变量下面的具体变量值，方便我们测试时，进行相应的判断。\n如何使用 Runner 批量执行测试，批量更换变量测试 当我们有一组 API 且这一组之间相互关联的关系，使用手动测试效率非常低。这时，我们就要用到 Postman 的批量执行（Runner）功能，Runner 不仅可以批量执行 API 调用，还可以批量更换变量。掌握此方法，大幅度提升 API 测试效率。\n打开你的 Postman ，跟随本教程一起操作一遍吧。\n本次批量 API 测试，我们先导入一个 CSV 文件，文件中包含四组等待新建的用户信息，将 CSV 文件导入 Runner 中待用。 新建 POST 调用页，在 Body 里写上创建用户所需信息，所有值使用变量替代，这些变量将从 CSV 中读取。 新建 GET 调用页，使用 email 作为查询 KEY 进行查询，如果上一步 POST 执行成功，那么 GET 就能成功查询到新建用户对应的 email，查询到表示 POST 创建成功。 在「卡拉云_kalacloud.com_批量测试」这个集合中设置 Tests 中设置全局断言，每当一个调用执行完毕时，进行 Tests 一次判断。 pm.test(\u0026#34;Status code is 200\u0026#34;, function () { pm.response.to.have.status(200); }); 打开「卡拉云_kalacloud.com_批量测试」合集的「Run Collection」的设置页 Iterations：这是测试组，我们 CSV 文件中有 4 组测试条目 Delay：延迟，一般填 2000 毫秒，太密集的请求，容易被服务器拒绝 Data：这里选择我们刚刚的 CSV 文件：kalacloud_users.csv 导入测试数据 点击 RUN 蓝色按钮开始执行批量测试 从上图可以看到，Postman 按顺序提交了 POST 请求和 GET 请求，并连续测试了从 CSV 文件导入的 4 组数据。一键批量测试，相当高效。\n","date":"2022-08-04T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/postman/","title":"postman使用（转）"},{"content":"购买配件 配件 用途 mq2 pro 续航版 提升头戴舒适度，可以按照自己需要选择没有续航的 磁吸镜片 近视适用 USB3.0串流线 玩steam的游戏需要和电脑串流 皮质眼罩鼻垫 防汗防漏光 网络 国内quest2用户应该已经具备上外网的条件，不再赘述。\nquest2需要无线网络链接，解决网络问题一般有以下方式：\n刷路由器，这个方式比较直接，我认为日常不适用的场景较多，所以我没用。 电脑热点，下文介绍。 下面介绍通用的sstap方法。\n打开科学上网，允许局域网连接。\n下载sstap，我使用的1.1.0.1版本。\n配置并打开sstap 打开热点，并打开 网络和Internet设置 -\u0026gt; 更改适配器选项 -\u0026gt; 右键 SSTAP 1 -\u0026gt; 属性 -\u0026gt; 共享 ，然后就可以连热点了。 clash方法\n如果你安装了clash，并且有网线连接电脑，clash TUN模式开热点应该也可以。\n注册，接受邀请领取30美金奖励 使用outlook、gmail等邮箱和原生ip至少提前1天注册facebook账号。\n接受邀请比较麻烦（实际上大多玩家只玩破解版，无需受邀，无需此步骤！），有需要直接去找别人代操作受邀！！以下方式成本过高，作为邀请别人的参考！\n注意：接受邀请也是高风险的操作，由于变换ip和账号资料不完善，依然有可能封号\n我试了多地vps，原生ip也全都出现Ineligible Country​，原因是服务器厂商用的数据中心ip（type是hosting），会被识别屏蔽。所以要用住宅代理（type是isp），由于成本高，服务器厂商几乎不用，只有代理厂商的住宅代理和部分静态住宅代理才可以接受邀请。我搜索了多家代理厂商，价格便宜的只有 911s5 和 iproyal\n代理厂商 特点 价格 911s5 自有软件，pc端指定软件代理，使用简单，ip质量差，部分可以邀请使用 最低28美元/150ip，每ip可用24小时 iproyal 直接给地址端口和用户，所以在国内必须自己搭建国外节点并且中转才能使用，但是ip质量较好、使用舒适。必须实名，不实名很多网站不能访问（包括facebook），而且实名较为耗时 3美元/GB ，paypal入金最低20美元 “以xui为例的中转配置文件”\r// 直接修改\u0026#34;servers\u0026#34;即可使用 { \u0026#34;api\u0026#34;: { \u0026#34;services\u0026#34;: [ \u0026#34;HandlerService\u0026#34;, \u0026#34;LoggerService\u0026#34;, \u0026#34;StatsService\u0026#34; ], \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 62789, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;Socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;proxy.iproyal.com\u0026#34;, \u0026#34;port\u0026#34;: 12325, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34; }, { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: {} }, { \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;blocked\u0026#34; } ], \u0026#34;policy\u0026#34;: { \u0026#34;system\u0026#34;: { \u0026#34;statsInboundDownlink\u0026#34;: true, \u0026#34;statsInboundUplink\u0026#34;: true } }, \u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;inbound-12325\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;ip2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, \u0026#34;protocol\u0026#34;: [ \u0026#34;bittorrent\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;stats\u0026#34;: {} } // 配置文件详解 { \u0026#34;api\u0026#34;: { // api: 提供了一些 API 接口供远程调用 \u0026#34;services\u0026#34;: [ // services: [string] 开启的 API 列表 \u0026#34;HandlerService\u0026#34;, // HandlerService:添加、删除一个入站、出站代理在一个入站代理中添加、删除一个用户 \u0026#34;LoggerService\u0026#34;, // 内置Logger \u0026#34;StatsService\u0026#34; // 内置的数据统计服务 ], \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; // tag: string api中的tag是**出站**代理标识 }, \u0026#34;inbounds\u0026#34;: [ // 入站 -\u0026gt; 路由 不用修改 { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 62789, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, // 任意门,可以监听一个本地端口 \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ], \u0026#34;outbounds\u0026#34;: [ // 出站 ##################此处开始添加################## { // 添加出站节点 \u0026#34;protocol\u0026#34;: \u0026#34;Socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 12325, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34; }, #################此处结束添加################### { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, // 向任意网络发送（正常的）TCP 或 UDP 数据 \u0026#34;settings\u0026#34;: {} }, { \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, // 禁止访问 \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;blocked\u0026#34; } ], \u0026#34;policy\u0026#34;: { \u0026#34;system\u0026#34;: { \u0026#34;statsInboundDownlink\u0026#34;: true, \u0026#34;statsInboundUplink\u0026#34;: true } }, \u0026#34;routing\u0026#34;: { // 路由 -\u0026gt; 出站 \u0026#34;rules\u0026#34;: [ ##################此处开始添加################## { // 添加路由，xui的\u0026#34;inboundTag\u0026#34;规则是\u0026#34;inbound-port\u0026#34; \u0026#34;inboundTag\u0026#34;: [ \u0026#34;inbound-12325\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;ip2\u0026#34;, // -\u0026gt; \u0026#34;outbounds\u0026#34;: {\u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34;} \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, #################此处结束添加################### { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, // -\u0026gt; \u0026#34;api\u0026#34;: {\u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34;} \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, // -\u0026gt; 禁止访问 \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, // -\u0026gt; 禁止访问 \u0026#34;protocol\u0026#34;: [ \u0026#34;bittorrent\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;stats\u0026#34;: {} } 激活 下载Oculus App，quest2联网后配对，配对成功就说明Quest2激活成功了。\n安装第三方应用 便携方式 87vr助手安装热门游戏和应用，安卓apk可以通过QQ发送直接安装。 更多破解应用可以看看极客VR（1元注册）、VR魔趣网。\n常规方式 首先需要开启开发者模式。在Oculus开发者网站创建一个开发者组织，再去Oculus APP菜单 -\u0026gt; 设备 -\u0026gt; 开发者模式 -\u0026gt; 打开 。 下载SideQuest并安装。 下载Oculus ADB驱动。右键单击android_winusb.inf选择“安装”。然后用USB线将头显和电脑连接起来，在头显中点击“允许”。 然后就可以安装apk了。 如果apk附带文件夹，就拖入obb文件夹。 进入头显的未知来源就可以使用了。 SKYBOX 《SkyBox VR》是最优秀的vr视频播放器，而且可以使用本地网络播放电脑上的影片。\nvr影片体积超过10G的很常见，quest2装不了多少。\n在电脑上共享存放影片的文件夹。 关闭共享密码。 去quest2 SKYBOX 本地网络查看。 常见问题 恢复出厂设置 手机配对后在app菜单 -\u0026gt; 设备 -\u0026gt; 高级设置 -\u0026gt; 恢复出场设置\n登陆Oculus官网 -\u0026gt; 点头像 -\u0026gt; Oculus settings -\u0026gt; Devices DELETE -\u0026gt; DEVICE DATA\n截图 按住右手柄Oculus Home键（椭圆键） + 扳机按键（食指键）\n","date":"2022-05-14T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/quest2/","title":"quest2入门使用汇总"},{"content":"安装 配置 JDK、安装配置Android Studio\nflutter(windows) flutter安装\nset PUB_HOSTED_URL=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/dart-pub\u0026#34; #配置国内镜像 set FLUTTER_STORAGE_BASE_URL=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/flutter\u0026#34; 安装遇坑 //配置build.gradle(project:android) allprojects { repositories { google() jcenter() maven { url \u0026#34;https://storage.googleapis.com/download.flutter.io\u0026#34; } } } 更新 flutter upgrade flutter doctor 创建 Flutter 项目 dart 变量 # 创建一个变量并将其初始化 var name = \u0026#39;Bob\u0026#39;; # 指定类型 String name = \u0026#39;Bob\u0026#39;; # 如果对象(name)不局限于单一的类型(String),可以将其指定为 Object（或 dynamic）类型 Object name = \u0026#39;Bob\u0026#39;; ? 可空类型 int? a=123; // int? 表示a是一个可空类型 ! 类型断言 a! // a不为空 常量 final 和 const final在被使用到的时候才会进行初始化, 如果只是被定义, 而没有被使用到, 那么这个变量一直没有被初始化 (\u0026lsquo;懒加载\u0026rsquo;); 而const修饰的变量, 一经定义就会在编译期间对其进行初始化\nfinal name = \u0026#39;Bob\u0026#39;; // Without a type annotation final String nickname = \u0026#39;Bobby\u0026#39;; 类型 内置类型 int 整数值 double 浮点数字 String 字符串 bool 布尔类型 List 集合类型 Set 无序集合 Map 字典型 不常用类型 enum　枚举类型,用于表示固定数量的常量值。在switch语句中运行良好。\nObject　对象类型，允许任何类型。\ndynamic　动态类型，不仅接受所有对象，而且还允许所有操作\nvoid main() { dynamic foo=\u0026#34;bar\u0026#34;; print(foo); foo=123; print(foo); } Set　无序集合，主要的功能就是去除数组重复内容 void main(){ List myList=[\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;,\u0026#39;西瓜\u0026#39;,\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;,\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;]; var s=new Set(); s.addAll(myList); print(s); print(s.toList()); } 几乎不用的类型 runes 暴露了字符串的 Unicode 代码点（Unicode 为每个字母、数字和符号定义了一个唯一的数值）。例如，用于表情符号，(😆) 是\\u{1f606}。\nSymbol 表示标识符，例如#。\nvoid main() { assert(Symbol(\u0026#39;bar\u0026#39;)==#bar); } // true 类型转换 String -\u0026gt; int myint = int.parse(myString); String -\u0026gt; double mydouble = double.parse(myString); int -\u0026gt; String myString = myint.toString(); double -\u0026gt; String myString = 3.14159.toStringAsFixed(2); // myString = \u0026#39;3.14\u0026#39; 将 list 映射为 widget List MyList.map((item) =\u0026gt; SomeWidget(item)).toList(); 函数 bool isNoble(int atomicNumber) { // bool:返回类型 return _nobleGases[atomicNumber] != null; } 箭头函数 =\u0026gt;\n=\u0026gt; expr 是 { return expr; }的简写\n运算符 算术运算符\n+(加)　–(减)　-(负)　*(乘)　/(除)　~/(取整)　%（取余）\n关系运算符\n==　！=　\u0026gt;　\u0026lt;　\u0026gt;=　\u0026lt;=\n逻辑运算符\n!(取反)　\u0026amp;\u0026amp;(与)　||(或)\n赋值运算符\n基础赋值运算符　=　??=(为 null 的变量赋值)\n复合赋值运算符　+=　-=　*=　/=　%=　~/=\n其他运算符 ()　使用一个方法\n[]　访问 List\n?[]　访问 List,左侧可以为null\n.　访问成员\n?.　访问成员,左侧可以为null\nif-else的表达式：\ncondition ? expr1 : expr2 如果条件为真，则计算expr1（并返回其值）；否则，计算并返回expr2的值。\nexpr1 ?? expr2 如果expr1不为 null，则返回其值；否则，计算并返回expr2的值。\n类 抽象类、抽象方法 抽象类常用于定义接口，抽象类常常会包含抽象方法 abstract class Doer { // Define instance variables and methods... void doSomething(); // Define an abstract method. } class EffectiveDoer extends Doer { void doSomething() { // Provide an implementation, so the method is not abstract here... } } 泛型 泛型常用于需要要求类型安全的情况，可以减少代码重复。 @override 注解来表示你重写了一个成员 异步 // 示例：等待返回自己ip import \u0026#39;package:http/http.dart\u0026#39;as http; import \u0026#39;dart:convert\u0026#39;; Future getIPAddress() async { final url =\u0026#39;https://httpbin.org/ip\u0026#39;; var response = await http.get(Uri.parse(url)); String ip = json.decode(response.body)[\u0026#39;origin\u0026#39;]; return ip; } void main() async { final ip = await getIPAddress(); print(ip); } flutter double width = MediaQuery.of(context).size.width; 屏幕宽度\ndouble height = MediaQuery.of(context).size.height; 屏幕高度\n","date":"2022-04-30T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/flutter/","title":"flutter基础备忘录"},{"content":"root（不同手机不同操作，刷机有变砖风险！） 以前手机都是用虚拟机 VMOS Pro，应用权限是有了，但现手机不能自动开屏幕锁自动执行任务，于是我就找了旧手机root，以荣耀8青春版为例。 大概分为以下几个步骤：\n解bl锁 各品牌手机解锁有所不同，大部分厂商官方给解锁码，我仅简述我本次华为旧机解锁，我用的是github的potatoNV短接解锁，如果其中没有你的手机，直接淘宝不要浪费时间。作者在youtube有教程，照做就好了，视频简介的USB com 1.0连接教程也要看，他的点击DriverSetup操作很快，不要漏了，短接点可以参考这里。获得解锁码搜华为工具箱即可解锁。\n刷入 TWRP recovery 建议不要刷机软件一键刷机，都是垃圾系统，就用官方系统刷适合你手机的TWRP，我在这个网站找到华为的TWRP，我当时看到他的网站干净无广告就刷了，是可以用的，此网站应该靠谱。Fastboot模式运行run脚本就行了。\nroot 安卓7及以上使用magisk，有大神建议用20.4版本，github下载zip放进手机储存卡，进入TWRP recovery安装，开机后酷安装magisk app即可。\nMacroDroid 基础 设置：\n防止系统清理：进入系统最近任务界面，点击应用旁边的小锁，锁定应用不被系统清理 忽略电池优化：依次打开系统设置，应用和通知，应用管理，设置，特殊访问权限，忽略电池优化（直接在设置搜索栏搜索电池也能找到），允许忽略应用 设置启动管理：依次打开系统设置，电池，启动管理，关闭应用自动管理后弹出的对话框中选中：允许自启动，允许关联启动，允许后台活动 权限全部打开 shell shell命令很方便定义操作（点击的坐标可以在手机开发者选项中打开指针位置）。shell命令摘录网站\n#按键事件 input text \u0026lt;string\u0026gt; #输入文本 input keyevent 20 #向下 input keyevent 4 #返回 input keyevent 3 #Home input keyevent 6 #挂机 input keyevent 84 #搜索 input keyevent 26 #电源，息屏 input keyevent 24 #音量+ input keyevent 25 #音量- #模拟点击 input tap 100 100 #滑动 input swipe x1 y1 x2 y2 ms input swipe 100 100 400 100 300 #左往右 input swipe 400 100 100 100 300 #右往左 input swipe 100 100 100 400 300 #上往下 input swipe 100 400 100 100 300 #下往上 input swipe 100 100 400 400 300 #上往下斜 input swipe 400 400 100 100 300 #下往上斜 #长按 input swipe 100 100 100 100 1000 //在 100 100 位置长按 1000毫秒 ","date":"2021-11-24T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/phone-root/","title":"root手机和自动化"},{"content":"本github actions方法已于2022-07-15完全被封，请去仓库看文档 freenom自动续期 Fork luolongfei大佬的freenom库，再添加以下workflow： “点击展开完整代码”\r# 1、Fork 本仓库 # 2、在你 Fork 的本仓库下的 Settings \u0026gt; Secrets 画面追加以下几个 secret 变量： # FREENOM_USERNAME、FREENOM_PASSWORD、MULTIPLE_ACCOUNTS、MAIL_USERNAME、MAIL_PASSWORD、TO、MAIL_ENABLE、TELEGRAM_CHAT_ID、 # TELEGRAM_BOT_TOKEN、TELEGRAM_BOT_ENABLE、NOTICE_FREQ # （注：此处列出了所有可用变量，你只用追加你需要用到的变量，变量的具体含义请参考本项目的 .env 文件中的说明，一般情况下，.env 文件中的某些 # 项存在默认值，如果默认值满足你的需求则可不追加到 Secrets，它们会保持默认） # # 下面定时任务中的时间是世界时间，每天 10:00（本示例已改为2:00） 执行，由于创建虚拟环境会消耗时间，故任务会延迟 30 秒左右执行 # # @Author of yml configuration file: RouRouX \u0026lt;https://github.com/RouRouX\u0026gt; \u0026amp; mybsdc \u0026lt;mybsdc@gmail.com\u0026gt; # ###### end 说明 ###### name: Run it on action on: push: branches: - main schedule: - cron: 00 02 * * * workflow_dispatch: jobs: run-it: runs-on: ubuntu-18.04 name: Run it on action steps: - name: Checkout master uses: actions/checkout@v2 - name: Setup PHP uses: shivammathur/setup-php@v2 with: php-version: \u0026#39;7.2\u0026#39; - name: Setting run: | echo \u0026#39;Renew freenom domain name automatically.\u0026#39; echo \u0026#39;@Author of yml configuration file: RouRouX \u0026lt;https://github.com/RouRouX\u0026gt; \u0026amp; mybsdc \u0026lt;mybsdc@gmail.com\u0026gt;\u0026#39; echo \u0026#39;@Url: https://github.com/luolongfei/freenom\u0026#39; cp .env.example .env if [[ (\u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39; == \u0026#39;\u0026#39; || \u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39; == \u0026#39;\u0026#39;) \u0026amp;\u0026amp; \u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39; == \u0026#39;\u0026#39; ]]; then echo \u0026#39;你在 Github 的当前项目的 Settings \u0026gt; Secrets 画面没有设置任何与账户信息相关的 secret 值，无法正常运行，请添加新的 secret 值，设置 FREENOM_USERNAME 与 FREENOM_PASSWORD，或者设置 MULTIPLE_ACCOUNTS，以及 .env 文件中其它必要项，各项的具体含义与格式参考本项目 .env 文件中的说明。\u0026#39;; fi if [ \u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^FREENOM_USERNAME=.*$/FREENOM_USERNAME=\u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^FREENOM_PASSWORD=.*$/FREENOM_PASSWORD=\u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MULTIPLE_ACCOUNTS=.*$/MULTIPLE_ACCOUNTS=\u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_USERNAME }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_USERNAME=.*$/MAIL_USERNAME=\u0026#39;${{ secrets.MAIL_USERNAME }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_PASSWORD }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_PASSWORD=.*$/MAIL_PASSWORD=\u0026#39;${{ secrets.MAIL_PASSWORD }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TO }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TO=.*$/TO=\u0026#39;${{ secrets.TO }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_ENABLE }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_ENABLE=.*$/MAIL_ENABLE=\u0026#39;${{ secrets.MAIL_ENABLE }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_CHAT_ID }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_CHAT_ID=.*$/TELEGRAM_CHAT_ID=\u0026#39;${{ secrets.TELEGRAM_CHAT_ID }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_BOT_TOKEN }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_BOT_TOKEN=.*$/TELEGRAM_BOT_TOKEN=\u0026#39;${{ secrets.TELEGRAM_BOT_TOKEN }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_BOT_ENABLE }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_BOT_ENABLE=.*$/TELEGRAM_BOT_ENABLE=\u0026#39;${{ secrets.TELEGRAM_BOT_ENABLE }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.NOTICE_FREQ }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^NOTICE_FREQ=.*$/NOTICE_FREQ=\u0026#39;${{ secrets.NOTICE_FREQ }}\u0026#39;/\u0026#34; .env; fi sed -i \u0026#34;s/^ON_GITHUB_ACTIONS=.*$/ON_GITHUB_ACTIONS=true/\u0026#34; .env - name: Run run: | php run # 以下为保活所需step - name: curl id: enable_workflow env: REST_TOKEN: ${{ secrets.REST_TOKEN }} API_ADDRESS: ${{ secrets.API_ADDRESS }} run: | echo \u0026#34;Enable Workflow Start...\u0026#34; curl -X PUT -H \u0026#34;Authorization: token $REST_TOKEN\u0026#34; \u0026#34;$API_ADDRESS\u0026#34; echo \u0026#34;Finished\u0026#34; 在你 Fork 的本仓库下的 Settings -\u0026gt; Secrets 页面追加以下几个secret秘密环境变量\n变量名 含义 默认值 是否必须 备注 FREENOM_USERNAME freenom 账户 - 是 只支持邮箱账户，不支持也不打算支持第三方社交账户登录 FREENOM_PASSWORD freenom 密码 - 是 某些特殊字符可能需要转义，在Github actions环境，请在除字母数字以外的字符前加上“\\”，否则可能无法正确读取密码，此举是防止某些字符在shell命令行被解析，举个例子，比如我密码是fei.,:!~@#$%^\u0026amp;*?233-_abcd^$$，那么写到秘密变量时就应写为fei\\.\\,\\:\\!\\~\\@\\#\\$\\%\\^\\\u0026amp;\\*\\?233\\-\\_abcd\\^\\$\\$。而在普通VPS环境，则只用在密码中的“#”或单双引号前加“\\”，请参考.env.example文件内的注释，应该没人会设置那么变态的密码吧 MULTIPLE_ACCOUNTS 多账户支持 - 否 多个账户和密码的格式必须是“\u0026lt;账户1\u0026gt;@\u0026lt;密码1\u0026gt;|\u0026lt;账户2\u0026gt;@\u0026lt;密码2\u0026gt;|\u0026lt;账户3\u0026gt;@\u0026lt;密码3\u0026gt;”，如果设置了多账户，上面的FREENOM_USERNAME和FREENOM_PASSWORD可不设置 MAIL_USERNAME 机器人邮箱账户 - 是 支持Gmail、QQ邮箱以及163邮箱，尽可能使用163邮箱或者QQ邮箱，而非之前推荐的Gmail。因为谷歌的安全机制，每次在新设备登录 Gmail 都会先被限制，需要手动解除限制才行，而Github Actions每次创建的虚拟环境都会分配一个新的设备IP，相当于每次都是从新设备登录Gmail，而我们不可能每次都去手动为Gmail解除登录限制，所以这种机制会导致无法发出通知邮件。具体的配置方法参考「 配置发信邮箱 」 MAIL_PASSWORD 机器人邮箱密码 - 是 Gmail填密码，QQ邮箱或163邮箱填授权码 TO 接收通知的邮箱 - 是 你自己最常用的邮箱，推荐使用QQ邮箱，用来接收机器人邮箱发出的域名相关邮件 MAIL_ENABLE 是否启用邮件推送功能 true 否 true：启用false：不启用默认启用，如果设为false，不启用邮件推送功能，则上面的MAIL_USERNAME、MAIL_PASSWORD、TO变量变为非必须，可不设置 TELEGRAM_CHAT_ID 你的chat_id - 否 通过发送/start给@userinfobot可以获取自己的id TELEGRAM_BOT_TOKEN 你的Telegram bot的token - 否 TELEGRAM_BOT_ENABLE 是否启用Telegram Bot推送功能 false 否 true：启用false：不启用默认不启用，如果设为true，则必须设置上面的TELEGRAM_CHAT_ID和TELEGRAM_BOT_TOKEN变量 NOTICE_FREQ 通知频率 1 否 0：仅当有续期操作的时候1：每次执行 REST_TOKEN 如后文所示 - 否 保活所需 API_ADDRESS 如后文所示 - 否 保活所需 （注：你只用关注上面表格中的必须项，非必须项可不设置，将保持默认值。更多相关变量的含义、格式以及默认值，请参考本项目的.env.example文件内的注释）\n启用 Actions ，完成。 保活 Fork zhzhzhy/Workflow-Keep-Alive库\n创建 sercets ：\n变量名 值 备注 REST_TOKEN 个人访问令牌（Personal access tokens） 个人资料照片-\u0026gt;设置-\u0026gt;Developer settings API_ADDRESS https://api.github.com/repos/{owner}/{target-repo}/actions/workflows/enable_workflow/enable 修改{owner}/{target-repo} 运行 github action。\n相互唤醒，再次在目标 repo 的工作流程中执行上述步骤，并添加所需 Github Action step（此步骤已标注请回看）。\n附 github workflow 语法文档\n修改定时任务 —— Cron示例\n","date":"2021-11-19T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/freenom/","title":"freenom自动续期（废弃）"},{"content":"actions部署前后端分离项目 参考文章\n本文使用github actions + docker compose部署到github container registry（这适用于中小型项目） 附：容器注册平台对比\n准备好你的dockerfile，如无docker和docker-compose基础请先看文档和前文。\n使用github actions “点击展开示例actions”\ron: push: branches: - master workflow_dispatch: env: REGISTRY: ghcr.io IMAGE_NAME: ${{ github.repository }} jobs: build-and-push-image: runs-on: ubuntu-latest permissions: contents: read packages: write strategy: matrix: node: [ \u0026#39;14\u0026#39; ] steps: - name: Checkout repository uses: actions/checkout@v2 - name: Setup node uses: actions/setup-node@v2 with: node-version: ${{ matrix.node }} - name: npm install run: | cd web #进入前端dockerfile目录 npm install - name: Set up QEMU uses: docker/setup-qemu-action@v1 - uses: docker/setup-buildx-action@v1 id: builder1 - uses: docker/setup-buildx-action@v1 id: builder2 - name: Log in to the Container registry uses: docker/login-action@v1 with: registry: ${{ env.REGISTRY }} username: ${{ github.actor }} password: ${{ secrets.GITHUB_TOKEN }} # 用于消毒标签，tag是此动作的重要功能之一，本示例没使用，请见文档 - name: Extract metadata (tags, labels) for Docker id: meta1 uses: docker/metadata-action@v3 with: images: ghcr.io/username/server # images地址 - name: Extract metadata (tags, labels) for Docker id: meta2 uses: docker/metadata-action@v3 with: images: ghcr.io/username/web # images地址 - name: Build and push Docker image 1 uses: docker/build-push-action@v2 with: builder: ${{ steps.builder1.outputs.name }} context: ./server # 服务端dockerfile目录 file: ./server/Dockerfile # 服务端dockerfile push: true tags: ${{ steps.meta1.outputs.tags }} labels: ${{ steps.meta1.outputs.labels }} cache-from: type=gha cache-to: type=gha,mode=max - name: Build and push Docker image 2 uses: docker/build-push-action@v2 with: builder: ${{ steps.builder2.outputs.name }} context: ./web # 前端dockerfile目录 file: ./web/Dockerfile # 前端dockerfile push: true tags: ${{ steps.meta2.outputs.tags }} labels: ${{ steps.meta2.outputs.labels }} cache-from: type=gha cache-to: type=gha,mode=max deploy: runs-on: ubuntu-latest needs: build-and-push-image steps: - uses: appleboy/ssh-action@master with: host: ${{ secrets.host }} #仓库设置中添加Secrets：HOST username: root password: ${{ secrets.PASSWORD }} #仓库设置中添加Secrets：PASSWORD port: 22 script: | echo $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin # 用户名 docker-compose -f docker-compose-nginx.yaml -f docker-compose-app.yaml pull # docker-compose名 docker-compose -f docker-compose-nginx.yaml -f docker-compose-app.yaml up -d # docker-compose名 # 此actions许多参数由github自动提供，无需添加，需修改的均已注释 在服务器上完成向 Container registry 验证\n具体操作：打开/etc/profile\nexport CR_PAT=YOUR_TOKEN source /etc/profile echo $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin 新建docker-compose-app.yaml和代理容器docker-compose-nginx.yaml,示例文档。如有不懂，请多看几遍acme-companion和示例文档。最后，Issues中的实例可能会有帮助。 ","date":"2021-11-15T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/auto-deploy/","title":"docker自动化部署"},{"content":"docker 安装docker：\n#更新apt包索引 sudo apt-get update #安装包以允许apt通过 HTTPS 使用存储库 sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release #添加Docker官方的GPG密钥 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg #设置稳定存储库 echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null #安装最新版本的Docker Engine和containerd sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io #hello-world 映像验证 sudo docker run hello-world # 使用脚本安装 curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh Dockerfile “点击展开go语言示例”\r# 这个参考示例来自李文周大佬的bluebell项目 FROM golang:alpine AS builder # 为我们的镜像设置必要的环境变量 ENV GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 # 移动到工作目录：/build WORKDIR /build # 复制项目中的 go.mod 和 go.sum文件并下载依赖信息 COPY go.mod . COPY go.sum . RUN go mod download # 将代码复制到容器中 COPY . . # 将我们的代码编译成二进制可执行文件 bluebell_app RUN go build -o bluebell_app . ################### # 接下来创建一个小镜像 ################### FROM debian:stretch-slim COPY ./wait-for.sh / COPY ./templates /templates COPY ./static /static COPY ./conf /conf # 从builder镜像中把/dist/app 拷贝到当前目录 COPY --from=builder /build/bluebell_app / RUN set -eux; \\ apt-get update; \\ apt-get install -y \\ --no-install-recommends \\ netcat; \\ chmod 755 wait-for.sh # 声明服务端口 EXPOSE 8084 # 需要运行的命令 #ENTRYPOINT [\u0026#34;/bluebell_app\u0026#34;, \u0026#34;conf/config.yaml\u0026#34;] 基础知识参考 以下简介节选自docker文档：\n**卷（volumes）**存储在由 Docker管理的主机文件系统（在 Linux 上的/var/lib/docker/volumes/ ）。卷完全由 Docker 管理，非 Docker 进程不应修改文件系统的这一部分。卷是在 Docker 中持久化数据的最佳方式。 # 将当前目录的相对路径挂载到/app目录中 volumes: - ./:/app docker compose 安装docker compose：\n#单独下载和安装 Compose，不装Docker CLI #下载 Docker Compose 的当前稳定版本 curl -SL https://github.com/docker/compose/releases/download/v2.7.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose #对二进制文件应用可执行权限 sudo chmod +x /usr/local/bin/docker-compose #测试安装 docker compose version # 脚本 curl -fsSL https://get.docker.com -o get-docker.sh \u0026amp;\u0026amp; \\ sudo sh get-docker.sh \u0026amp;\u0026amp; \\ docker -v \u0026amp;\u0026amp; \\ curl -SL https://github.com/docker/compose/releases/download/v2.7.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose \u0026amp;\u0026amp; \\ sudo chmod +x /usr/local/bin/docker-compose \u0026amp;\u0026amp; \\ docker compose version docker-compose.yaml “点击展开和折叠代码”\rversion: \u0026#39;3.7\u0026#39; services: mysql5.7: # 镜像名 image: \u0026#39;mysql:5.7\u0026#39; # 容器名(以后的控制都通过这个) container_name: mysql5.7 # 重启策略 restart: always environment: # 时区上海 TZ: Asia/Shanghai # root 密码 MYSQL_ROOT_PASSWORD: root # 初始化数据库(后续的初始化sql会在这个库执行) MYSQL_DATABASE: nacos_config # 初始化用户(不能是root 会报错, 后续需要给新用户赋予权限) MYSQL_USER: nacos # 用户密码 MYSQL_PASSWORD: nacos # 映射端口 ports: - 3306:3306 volumes: # 数据挂载 #- /root/mysql/data/:/var/lib/mysql/ # 配置挂载 #- /root/mysql/conf/:/etc/mysql/conf.d/ # 初始化目录挂载，注意此处我只跑了这个挂载，只是为了说明其他配置不应该数据初始化 - /root/mysql/init/:/docker-entrypoint-initdb.d/ command: # 将mysql8.0默认密码策略 修改为 原先 策略 (mysql8.0对其默认策略做了更改 会导致密码无法匹配) --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 networks: - proxy server: image: ghcr.io/USERNAME/server:master container_name: server ports: - 8082:8082 expose: - \u0026#34;8082\u0026#34; depends_on: - mysql5.7 restart: always volumes: - \u0026#39;./data:/data/\u0026#39; networks: - proxy web: image: ghcr.io/USERNAME/web:master container_name: web depends_on: - server restart: always ports: - 3000:3000 expose: - \u0026#34;3000\u0026#34; environment: - VIRTUAL_HOST=example.com - VIRTUAL_PORT=3000 - LETSENCRYPT_HOST=example.com - LETSENCRYPT_EMAIL=mail@example.com networks: - proxy networks: proxy: external: name: nginx-proxy “点击展开nginx-proxy代码”\rversion: \u0026#39;3\u0026#39; services: nginx-proxy: image: jwilder/nginx-proxy container_name: nginx-proxy ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; volumes: - conf:/etc/nginx/conf.d - vhost:/etc/nginx/vhost.d - html:/usr/share/nginx/html - dhparam:/etc/nginx/dhparam - certs:/etc/nginx/certs:ro - /var/run/docker.sock:/tmp/docker.sock:ro restart: always networks: - nginxproxy labels: - \u0026#34;com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy\u0026#34; letsencrypt: image: jrcs/letsencrypt-nginx-proxy-companion container_name: nginx-proxy-le depends_on: - nginx-proxy volumes: - vhost:/etc/nginx/vhost.d - html:/usr/share/nginx/html - dhparam:/etc/nginx/dhparam:ro - certs:/etc/nginx/certs - acme:/etc/acme.sh - /var/run/docker.sock:/var/run/docker.sock:ro ################## # 由于LETSENCRYPT证书速率限制，可使用ZeroSSL # 注释掉web服务environment中的： - LETSENCRYPT_HOST=example.com - LETSENCRYPT_EMAIL=mail@example.com # 需添加如下environment environment: - ACME_CA_URI=https://acme.zerossl.com/v2/DV90 - ZEROSSL_API_KEY= ################## restart: always networks: - nginxproxy volumes: conf: vhost: html: dhparam: certs: acme: networks: nginxproxy: external: name: nginx-proxy 基础知识参考 以下简介节选自docker compose文档：\nCompose 中的网络: Compose默认为您的应用程序设置单个网络。服务中的每个容器都加入默认网络。例如，假设您的应用程序是在一个名为myapp的目录，运行docker-compose up时会创建一个名为myapp_default的网络，服务中使用web和db的配置创建的容器会以web和db的名字加入myapp_default。\n但是，当你使用external（外部网络，例如你有2个或多个docker-compose.yml）时，Compose不会创建默认网络，你必须使用docker network create Your_Nerwork预先创建网络。\n常用命令 Docker命令 docker run [可选参数] imagename #新建并启动容器 --name = \u0026#34;name\u0026#34; 容器取名 -it 交互模式进入容器 -d 后台启动容器 注意：一般后台启动要有前台的应用，否则很可能被守护程序杀掉 -p ip:主机端口:容器端口 #指定端口映射 查看： docker search xxx #搜索dockerhub-镜像 docker images [-a][-q] #列出本地主机的-镜像 -a 显示所有信息 -q 显示所有id docker ps [-a][-q] #显示当前正在运行的容器 -a 显示当前运行的容器，并显示历史运行过的容器 -q 只显示运行容器的编号 docker logs 容器id #日志 docker top 容器id #查看容器中进程信息 docker inspect 容器id #查看容器的详细信息 操作： docker pull 镜像：版本号 #拉取-镜像 docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止容器 docker kill 容器id #强制停止容器 docker rm 容器id #删除停止状态的容器 docker rm -f 容器id #强制删除容器 docker rmi -f xxx #删除单个-镜像 docker rmi -f $(docker images -aq) #删除所有-镜像 docker stop $(docker ps -a -q) #停止所有容器运行 docker rm $(docker ps -a -q) #删除所有容器 docker network rm $(docker network ls -q) #删除所有network docker system prune --all --force --volumes #删除一切 exit 容器停止并退出 ctrl+p+q 容器不停止退出 docker exec -it mysql /bin/bash #进入正在执行的mysql容器 docker inspect -f \u0026#39;{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}\u0026#39; container_name_or_id #查看容器ip 从容器拷贝内容到主机： docker cp 容器id: 路径 主机目的路径 #此处不必进入容器，容器可以是关闭的。 Docker-compose命令 docker-compose up -d # 在后台启动服务 docker-compose pull # 拉取 docker-compose -f docker-compose.yml up -d # 指定docker-compose.yml docker-compose -f docker-compose.yml pull # 指定docker-compose.yml，后同 查看： docker-compose ps # 查看正在运行中的容器 docker-compose ps -a # 查看所有编排容器，包括已停止的容器 docker-compose images # 列出Compose文件构建的镜像 docker-compose logs # 查看日志 docker-compose logs [serviceName] # 查看某服务的日志 docker-compose logs -f [serviceName] # 查看某服务的实时日志 操作： docker-compose stop # 停止服务 docker-compose start # 启动已经存在的服务 docker-compose pause [serviceName] # 暂停服务 docker-compose unpause [serviceName] # 恢复服务 docker-compose restart [serviceName] # 重启服务 docker-compose rm # 删除所有（停止状态的）服务容器 docker-compose down # 删除所有容器 docker-compose down --remove-orphans # 删除orphans容器 docker-compose config -q # 验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容 docker-compose exec --index=1 [serviceName] sh # 进入某服务的第1个容器执行命令 docker-compose --help # 帮助 ","date":"2021-10-27T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/docker-compose/","title":"docker和docker-compose"},{"content":"git git命令 官网git备忘表比各种教程都易看\npush脚本 #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master 公开仓库fork为私有仓库 fork一个公开仓库 使用github导入功能，写fork仓库的地址，并创建私有仓库 本地操作 git clone git@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git #克隆到本地 git remote add upstream git@github.com:\u0026lt;original_owner\u0026gt;/\u0026lt;original_repo\u0026gt;.git #添加上游(源)仓库用于更新 git remote set-url --push upstream DISABLE #禁用推送到上游(源)仓库 git remote -v可以看到： origin\tgit@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git (fetch) origin\tgit@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git (push) upstream\tgit@github.com:\u0026lt;original_owner\u0026gt;/\u0026lt;original_repo\u0026gt;.git (fetch) upstream\tDISABLE (push) 拉取更新 git fetch upstream git merge upstream/master Linux 文件 i 键可以对文件进行修改， Esc + :+ wq 退出并保存修改之后的文件\nsudo gedit ~/File //编辑 touch File //新建文件 mkdir -p Folder/a/src //新建文件夹 sudo rm -r Folder //删除文件夹 安装包 apt sudo apt update \u0026amp;\u0026amp; apt upgrade //更新 dpkg --list //显示所有软件 sudo apt-get install 包名 //安装 sudo apt-get remove 包名 //卸载不删除配置文件 sudo apt-get --purge remove 包名 //软件及其配置文件一并删除 snap sudo snap list //列出已经安装的snap包 sudo snap install \u0026lt;snap name\u0026gt; //安装一个snap包 sudo snap refresh \u0026lt;snap name\u0026gt; //更新一个snap包，如果后面不加包的名字更新所有的snap包 sudo snap remove \u0026lt;snap name\u0026gt; //删除一个snap包 端口 sudo apt-get install lsof //安装lsof lsof -i:80 //查看80端口 kill -9 pid //强制杀进程 命令 local #用于声明局部变量 source systemctl stop service # 停止一个服务 systemctl daemon-reload # 重载所有修改过的配置文件 systemctl enable #将服务设置为每次开机启动 set -eux #用于脚本开头设置 #-e 若指令传回值不等于0，则立即退出shell。0表示没有错误 #-u 当执行时使用到未定义过的变量，则显示错误信息。 #-x 执行指令后，会先显示该指令及所下的参数。 grep 、sed、awk grep 、sed、awk被称为linux中的\u0026quot;三剑客\u0026quot;。\ngrep 更适合单纯的查找或匹配文本 sed 更适合编辑匹配到的文本 awk 更适合格式化文本，对文本进行较复杂格式处理 sed sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为\u0026quot;pattern space\u0026quot;，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。\n语法 sed [option] \u0026#39;command\u0026#39; fileName 选项\n-n 使用安静silent模式。在一般sed的用法中，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来\n-e 直接在指令列模式上进行 sed 的动作编辑\n-f 直接将 sed 的动作写在一个文件内，-f filename则可以执行filename内的sed命令\n-r 让sed命令支持扩展的正则表达式(默认是基础正则表达式)\n-i 直接修改读取的文件内容，而不是由屏幕输出\n命令\na\\：追加行，a\\的后面跟上字符串s(多行字符串可以用\\n分隔)，则会在当前选择的行的后面都加上字符串s\nc\\：替换行，c\\后面跟上字符串s(多行字符串可以用\\n分隔)，则会将当前选中的行替换成字符串s\ni\\：插入行，i\\后面跟上字符串s(多行字符串可以用\\n分隔)，则会在当前选中的行的前面都插入字符串s\nd：删除行delete，该命令会将当前选中的行删除\np：打印print，该命令会打印当前选择的行到屏幕上\ny：替换字符，通常y命令的用法是这样的：y/Source-chars/Dest-chars/，分割字符/可以用任意单字符代替，用Dest-chars中对应位置的字符替换掉Soutce-chars中对应位置的字符\ns：替换字符串，通常s命令的用法是这样的：1,$s/Regexp/Replacement/Flags，分隔字符/可以用其他任意单字符代替，用Replacement替换掉匹配字符串\n替换选项\n\\digit：Replacement中可含有后向引用中的\\digit(digit是1至9)，引用前面定义的子表达\n\u0026amp;：代表模版空间中的整个匹配部分\n\\L：将在其后的替换部分转换成小写字母，直到发现一个\\U或\\E，GNU扩展功能\n\\l：将下一个字符转换成小写字母，GNU扩展功能\n\\U：将在其后的替换部分转换成大写字母，直到发现一个\\L或\\E，GNU扩展功能\n\\u：将下一个字符转换成大写字母，GNU扩展功能\n\\E：停止由\\L或\\U指示开始的大小写转换，GNU扩展功能\n标志选项\ng：将用Replacement替换模版空间中所有匹配Regexp的部分，则不仅仅是第一个匹配部分\ndigit：只用Replacement替换模版空间中第digit(digit是1至9)个匹配Regexp的部分\np：若发生了替换操作，指示显示模版空间中新的数据\nw file-name：若发生了替换操作，指示将模版空间中新的数据写入指定的文件file-name中\ni：表示进行Regexp匹配时，是不区分大小写字母的\n示例 a命令 sed '1,$a\\add one' test.txt 从第一行到最后一行所有行后追加\u0026quot;add one\u0026quot;字符串行\nsed '/first/a\\add one' test.txt 在匹配到first行追加\u0026quot;add one\u0026quot;字符串行\ni命令 与a命令类似，只不过在匹配的行前面插入字符串行，不举例了。\nc命令 sed '1,$c\\add one' test.txt 从第一行到最后一行所有行替换为\u0026quot;add one\u0026quot;字符串行\nsed '/first/c\\add one' test.txt 将匹配到first行替换为\u0026quot;add one\u0026quot;字符串行\nd命令 sed '4,$d' test.txt 从第四行到最后一行全部删除\np命令 sed -n '/^first.*end$/p' test.txt 以first开头end结尾的所有行全部打印\ns命令 sed 's/line/text/g' test.txt 将所有行的line替换为text，g代表全局选项，没有g只替换所有行的第一个匹配项\nsed '/^first.*end$/s/line/text/g' test.txt 匹配以first开头end结尾的所有行，然后将line全部替换为text\nsed 's/\\(.*\\)line$/\\1/g' test.txt 本例中的\\(\\)中包裹的内容表示正则表达式的第n部分，.*表示任意字符串，所以此例相当于删除所有行末的line\n脚本语言备忘录 shell 原文地址\nname=\u0026#34;MyName\u0026#34; //定义变量 echo $name 或 echo ${name} //使用变量 val=`expr 2 + 2` #expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 echo \u0026#34;Total value : $val\u0026#34; 2\u0026gt;\u0026amp;1 把\u0026#34;标准错误输出\u0026#34;重定向到\u0026#34;标准输出\u0026#34; 特殊变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2 $# 传递给脚本或函数的参数个数总和 $* 传递给脚本或函数的所有参数，当被双引号 \u0026quot; \u0026quot; 包含时，所有的位置参数被看做一个字符串 $@ 传递给脚本或函数的所有参数，当被双引号 \u0026quot; \u0026quot; 包含时，每个位置参数被看做独立的字符串 $? 上个命令的退出状态，或函数的返回值 $$ 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。 测试符 描述 -eq，equal 等于 -ne，not equal 不等于 -gt，greater than 大于 -lt，lesser than 小于 -ge，greater or equal 大于或等于 -le，lesser or equal 小于或等于 -z 检测字符串长度是否为 0，为 0 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 待续\n正则表达式 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n\u0026lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“`(. (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`( (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95 (?\u0026lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?\u0026lt;=95 (?\u0026lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?\u0026lt;!95 x|y 匹配x或y。例如，“`z [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \\d 匹配一个数字字符。等价于[0-9]。 \\D 匹配一个非数字字符。等价于[^0-9]。 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04\u0026amp;1”。正则表达式中可以使用ASCII编码。. *num* 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。 *n* 标识一个八进制转义值或一个向后引用。如果*n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n*为一个八进制转义值。 *nm* 标识一个八进制转义值或一个向后引用。如果*nm之前至少有nm个获得子表达式，则nm为向后引用。如果*nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则*nm将匹配八进制转义值nm*。 *nml* 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$ 非零的负整数：^-[1-9][]0-9″$ 或 ^-[1-9]\\d$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*))|0?.0+|0$ 正浮点数：^[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0?.0+|0)$ 二、校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20} 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%\u0026amp;’,;=?$\\”等字符：[^%\u0026amp;’,;=?$\\x22]+ 禁止输入含有~的字符[^~\\x22]+ 其它： .*匹配除 \\n 以外的任何字符。\n/[\\u4E00-\\u9FA5]/ 汉字\n/[\\uFF00-\\uFFFF]/ 全角符号\n/[\\u0000-\\u00FF]/ 半角符号\n三、特殊需求表达式 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%\u0026amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 1.有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$\n2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0″不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$\n3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$\n4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$\n5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$\n6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$\n7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$\n8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$\n备注：这就是最终结果了,别忘了+可以用*替代,如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\nxml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：\u0026lt;(\\S*?)[^\u0026gt;]\u0026gt;.?\u0026lt;/\\1\u0026gt;|\u0026lt;.*? /\u0026gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) IP-v4地址：\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b (提取IP地址时有用) 校验IP-v6地址:(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 子网掩码：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 校验日期:^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。) 抽取注释：\u0026lt;!–(.*?)–\u0026gt; 查找CSS属性:^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1} 提取页面超链接:(\u0026lt;a\\s*(?!.\\brel=)[^\u0026gt;])(href=”https?:\\/\\/)((?!(?:(?:www\\.)?’.implode(‘|(?:www\\.)?’, $follow_list).’))[^” rel=”external nofollow” ]+)”((?!.\\brel=)[^\u0026gt;])(?:[^\u0026gt;]*)\u0026gt; 提取网页图片:\\\u0026lt; [img][^\\\\\u0026gt;][src] *= [\\”\\’]{0,1}([^\\”\\’\\ \u0026gt;]) 提取网页颜色代码:^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 文件扩展名效验:^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)[^\\/:?”\u0026lt;\u0026gt;|]+\\.txt(l)?$ 判断IE版本：^.*MSIE 5-8?(?!.Trident\\/[5-9]\\.0).$ ","date":"2021-07-22T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/ubuntu/","title":"常用命令"},{"content":"部分电脑配置记录 win10 config git git config --global http.proxy http://127.0.0.1:port.http git config --global https.proxy https://127.0.0.1:port.http 文件路径：C:\\Users\\90487\\.gitconfig，90487是我的用户名\nTerminal（临时使用） set http_proxy=http://127.0.0.1:port.http #临时命令行代理 set https_proxy=http://127.0.0.1:port.http #临时命令行代理 VM Ubuntu config 代理 Windows中使用ipconfig查看VMware Network Adapter VMnet8的ip地址，ubuntu中进入“设置”-“网络”-“proxy”，在Socks Host里写入之前查到的ip地址\ngit config\ngit config --global user.name \u0026#34;John Doe\u0026#34; #配置github账号用户名 git config --global user.email johndoe@example.com #配置邮箱 git ssh 代理 创建~/.ssh/config 文件：\nHost github.com User git ProxyCommand nc -v -x ip:port.socks %h %p #写自己ip 终端代理（临时使用）\n方法一：直接在命令前加proxychains\n方法二：直接在.bashrc最后加入：\nexport http_proxy=\u0026#34;http://ip:port.http\u0026#34; #写自己ip export https_proxy=\u0026#34;http://ip:port.http\u0026#34; #写自己ip source ~/.bashrc #使配置生效 Ubuntu安装go sudo apt install snap #安装snap，使用snap更易安装、更新 sudo snap install go --classic #安装go sudo vim /etc/profile #编辑profile export GOROOT=/snap/go #在最后一行添加 export PATH=$PATH:$GOROOT/bin source /etc/profile #保存 go version #验证 export GO111MODULE=on export GOPROXY=https://goproxy.cn #设置 go get 为国内源（无代理） Goland 使用 goland无限试用，方法适用IDEA系列\ngoland中添加第三方插件仓库地址：https://plugins.zhile.io 安装插件：IDE Eval Reset 下载 直接把zip包拖进IDE的窗口来进行插件的安装 Help -\u0026gt; Eval Reset 勾选Auto reset before per restart 原文地址，本段仅进行简述，使操作简明\n不能输入中文（Ubuntu） 在goland.sh注释之后的首行添加\nexport XMODIFIERS=\u0026#34;@im=ibus\u0026#34; export GTK_IM_MODULE=\u0026#34;ibus\u0026#34; export QT_IM_MODULE=\u0026#34;ibus\u0026#34; goland.vmoptions添加-Drecreate.x11.input.method=true\n自用软件 本文软件均为自用，本人无意推广任何软件，所以下载地址请自行查找，一般在google可找到官方，或者在52论坛搜搜看\nwin10优雅必备 Wallpaper Engine　#壁纸，steam购买\nEverything + uTools　#文件快捷搜索及工具\nquicker　#鼠标便捷操作神器\nDeskGo　#腾讯出品的桌面软件格子\nGeek Uninstaller　#卸载无残留\nclover　#资源管理器多标签页\n火绒　#屏蔽弹窗\ntypora　#markdown记事本，据说notion在线笔记，我把博客当作在线笔记了\nwin10 microsoft store工具\nWindows Terminal　#命令行 TranslucentTB　#任务栏透明 EarTrumpet　#音频管理 安卓app 浏览器：Chrome、Kiwi、x浏览器\n影视：zd01.tv下载 + AdGuard　# AdGuard设置复杂请自行研究，去除视频开头广告可在日志中找到广告，把这几个广告网站地址添加到自定义过滤\n音乐：listen1　# 并不完美，希望找到更好用的\n小说：阅读　# 酷安评论区可以找书源\n阅读：ReadEra、福昕PDF阅读器\n去除启动广告：跳过广告\n手机控制\nMacroDroid、hamibot　#手机自动化 Moonlight　#局域网流畅投屏 AirDroid和AirMirror　#手机远程控制手机 向日葵远程控制 其他\nzarchiver　#文件管理和解压 星空视频壁纸 Sendapp #提取apk ","date":"2021-07-18T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/config/","title":"环境配置和软件"},{"content":"准备 1.Ubuntu\nsudo apt update #更新 2.github账号\n3.git配置\ngit config --global user.name \u0026#34;John Doe\u0026#34; #配置github账号用户名 git config --global user.email johndoe@example.com #配置邮箱 4.连接github\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; #生成SSH Keys 此为新版 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; #此为常用版 cat ~/.ssh/id_ed25519.pub #复制 点击github右上角头像-\u0026gt; Settings -\u0026gt; SSH and GPG Keys -\u0026gt; New SSH key添加\nssh -T git@github.com #验证连接，输入yes 官方文档\n5.git ssh 代理设置\n非必要步骤，如果有一天ssh push网速极慢但https push正常，可尝试此操作\n创建~/.ssh/config 文件：\nHost github.com User git ProxyCommand nc -v -x 127.0.0.1:10808 %h %p #请修改127.0.0.1:10808 安装 snap install hugo --channel=extended #安装hugo hugo version #验证 hugo new site myblog #创建博客 git init #初始化 git remote add origin git@github.com:**** #连接远程仓库 git clone https://github.com/CaiJimmy/hugo-theme-stack/ #安装stack主题 rm config.toml \u0026amp;\u0026amp; cp themes/hugo-theme-stack/exampleSite/config.yaml . #使用主题的配置文件 把myblog/themes/hugo-theme-stack/exampleSite/content内容移到myblog/content使用主题示例文章\n本地预览： myblog下执行\nhugo server 浏览器打开：\nhttp://localhost:1313/ #目前本地运行不显示文章目录，估计是操作系统原因 部署 注：我将介绍使用github托管源码自动化部署，如果您仅在本地存放源码，提交public文件夹即可，无需使用下列方法。\n1.虽然博客内容全都能看到，但我们可能不太希望公开源码，不开放源码使用github pages需要创建2个仓库: 创建 username.github.io.source 仓库存放源码可设为私人仓库，创建 username.github.io 仓库作为公开仓库\n点击github右上角头像-\u0026gt; Settings -\u0026gt; Developer Settings-\u0026gt; Personal access tokens -\u0026gt; Generate new token （Note随意，Select scopes全选,复制token，我们这里使用Personal tokens比Deploy keys更方便）\n找到源码仓库Settings-\u0026gt; Secrets -\u0026gt; New repository secret （Name写PERSONAL_TOKEN，Value粘贴token）\n2.创建github actions的workflows自动部署文件：\nmkdir -p .github/workflows \u0026amp;\u0026amp; touch ~/myblog/.github/workflows/main.yml 粘贴脚本：\nname: github pages on: push: branches: - master jobs: deploy: runs-on: ubuntu-latest #可使用指定版本，例：runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest #可使用指定版本，例：hugo-version: \u0026#39;0.83.1\u0026#39; extended: true - name: Build run: hugo --gc --forceSyncStatic --minify --cleanDestinationDir - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} # PERSONAL_TOKEN是源码仓库secrets的name external_repository: username/username.github.io # Pages 远程仓库 publish_branch: master # 部署的分支 publish_dir: ./public commit_message: ${{ github.event.head_commit.message }} #cname: www.example.com # 使用自定义域名 只需更改external_repository: username/username.github.io 为你的github账户名，脚本详情\n3.在myblog文件夹下创建push.sh\ntouch push.sh 粘贴脚本：\n#!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master 在myblog下运行 sh push.sh命令\n到此已完成部署，之后任何更新如上运行push脚本即可\n修改主题 此处仅列举常见需修改内容，更多内容请看stack主题文档\n本博客修改样式来自rmdhnreza\n更多定制文章可以参考这里\n主题配置 1.修改~/myblog/config.yaml\n1 baseurl: https://username.github.io #改为自己的 2 languageCode: zh-CN #中文编码 4 paginate: 10 #文章分页数 5 title: Example Site #博客名字 30 DefaultContentLanguage: zh-cn #中文 34 hasCJKLanguage: true #正确计数中、日、韩文语言的字数 48 since: 2021 52 published: 2006-01-02 #日期格式 53 lastUpdated: 2006-01-02 #更新日期格式 56 emoji: 🍥 #头像角标 57 subtitle: #博客名下的简介 61 src: img/avatar.png #头像，myblog/themes/hugo-theme-stack/assets/img 135 name: \u0026#39;首页\u0026#39; #改中文左侧菜单home 155 startLevel: 1 #从文章1级标题使用文章目录 2.左侧菜单栏 ~/myblog/content/page用于左侧菜单，请自定义\n2 title: \u0026#39;关于\u0026#39; #中文左侧菜单about，后同 3.覆盖主题样式\n直接在~/myblog下复制复制我的assets、layouts文件夹，本主题来源于rmdhnreza。\n另外修改：\n~/myblog/assets/scss/variables.scss\nlink-background-color: 0, 255, 255 链接背景颜色 注：浏览器可能缓存样式，可使用无痕模式\n创建文章 hugo new post/文件夹名/index.md #创建文章 写文章：\n1.front matter:\n--- title: hugo使用stack主题搭建博客及部署 #标题 description: #副标题，此样式不可用 date: 2021-07-04 #日期 lastmod: 2021-07-27 #上次修改内容的日期 slug: hugo-blog #URL的尾部，用于文章地址 categories: #文章分类 - blog --- front matter仅列举本文使用，hugo front matter官方文档\n2.常见文章markdown语法：\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n`单行代码` `` 有`需用双反引号 ``\n```html\n多行代码\n```\n[链接](https://)\n\\ 写在特殊符号前为转义；写在行尾为换行\\\n*斜体*\n**加粗**\n~~删除线~~\n* 无序列表\n双空格* 子无序列表\n![图片描述](本地图片.jpg)\n表格\n| Italics | Bold | Code | | -------- | -------- | ------ | | *italics* | **bold** | `code` | shortcodes ./myblog/layouts/shortcodes\n{{\u0026lt; spoiler text=\u0026quot;点击展开和折叠代码\u0026quot; \u0026gt;}}\n```html\ncode\n```\n{{\u0026lt; /spoiler \u0026gt;}}\n{{\u0026lt; typography font=\u0026quot;monoton\u0026quot; size=\u0026quot;30px\u0026quot; style=\u0026quot;normal\u0026quot; weight=\u0026quot;bold\u0026quot; color=\u0026quot;blue\u0026quot;\u0026gt;}} 自定义字体 {{\u0026lt; /typography \u0026gt;}}\n# font　Google 字体\n# size　大小\n# style　normal正常， italic 斜体\n# weight　bold 加粗 ， lighter 更细\n评论系统 waline官方文档写得非常清楚，您只需 LeanCloud设置 和 部署到Vercel ，拿到URL\n然后修改~/myblog/config.yaml\n52 provider: waline #评论系统，本文示例使用waline 73 serverURL: https:// #评论系统URL用你自己的 执行sh push.sh即可\n自定义域名 在~/myblog/config.yaml修改baseurl: https://username.github.io\n在~/myblog/.github/workflows/main.yml最后一行取消注释并修改cname: www.example.com\n执行sh push.sh即可\n启用https：参考链接\n没有域名？为了白嫖可在freenom和cloudflare进行申请域名和解析，这可能花费一些时间，如对此没有了解建议暂时跳过自定义域名。\nfreenom脚本自动续期参考后续文章\n","date":"2021-07-03T00:00:00Z","permalink":"https://www.jiangdaoli.cf/p/hugo-blog/","title":"hugo使用stack主题搭建博客及部署"}]