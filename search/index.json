[{"content":"跑步 手表 专业跑表：推荐佳明，数据专业，用于参加马拉松及越野\n日常的跑表：可以选自己手机品牌的（例如OPPO Watch X），认准双频GPS，不仅准确，而且使用esim完全不用带手机\n不选手环：每次跑步都需要连接手机，并要在手机网络信号好的地方用，否则单频GPS误差相当大，只能看心率。\n跑鞋 国际四大跑鞋：\n索康尼 胜利21：舒适度拉满，韧弹型，长距离完全不泄力，但我是小体重，脚感硬，长期训练量大的话会伤跟腱 新百伦 1080v13：脚感软，后程有泄力但能接受，内部材质差，稍作修改后还算舒适，可以作为慢跑主力 亚瑟士 nimbus26：又厚！又磨脚！鞋底很软也很泄力，我感觉完全脱离了跑步鞋的范畴，用作走路比较好。唯一好评的是鞋垫，可以复购鞋垫 布鲁克斯 甘油：待测 衣服 部分科技面料介绍\n面料名称 特点 品牌 羽绒 蓬松度、充绒量、含绒量是衡量保暖性的关键指标 蓬松度越高，保暖性越好，价格越高 鹅绒优于鸭绒 大多数羽绒服品牌 Primaloft（P棉） 仿生羽绒 人造纤维，拒水性好，湿了也暖和，耐磨且养护容易 ROSSIGNOL、Timberland、Converse等 POLARTEC 合成羊毛 抓绒和摇粒绒材质，保暖、轻便、透气，不掉绒 分100、200、300系列，保暖性依次递增 TNF、Marmot、Patagonia等 GORE-TEX（戈尔特斯） 防水、防风、透气性极佳 防止雨水进入，同时排出汗气 始祖鸟、北面、Vans、波司登等 CORDURA（考杜拉） 耐磨耐造，耐用性极高 抗擦伤、抗磨损、抗撕裂、防穿刺 UFPRO、OSPREY、始祖鸟、凯乐石等 COOLMAX 四管道纤维材料，透气性好，快干性能是纯棉的5倍 TNF、凯乐石、飞爽等 Climashield（C棉） 耐用、轻质、热效率高、可压缩、阻燃 Thinsulate（新雪丽） 轻薄且保暖 列举常见跑步品牌\n上衣 轻工-热力怪：薄款热力怪60（未知面料），厚款热力怪100（未知面料） UTO 引擎鸟 内道：薄款聚能卷为POLARTEC，厚款棉服为金标P棉。外观版型欠佳。 马甲 薄上衣速干即可 腰包裤：马孔多 袜子：悍将、feetures、乔丹 山地车 选车 参考：2024山地车选购指南\n尺寸 轮径26、车架17 适合身高165cm-175cm 刹车 首选油压碟刹 次选机械碟刹 不选V刹 前叉避震 首选气压 次选油、弹簧 弹簧 变速：禧玛诺、速联 21速=3齿盘×7飞轮 24速=3齿盘×8飞轮 27速=3齿盘×9飞轮 品牌 首选线下：捷安特、美利达、喜德盛(性价比) 品控好：千里达(性价比)、福玛特 其它：邦德富士达、迪卡侬、崔克、闪电 3000左右山地车选购 美利达公爵600 千里达 X7Elite 喜德盛传奇500plus 调试 前变速器 前拨：前轮盘移动链条的装置\n导链板：链条上方的一个罩子，将链条引导至对应轮盘 H限位螺钉：限制前拨最外侧，顺时针旋转限位移向外侧\nL限位螺钉：限制前拨最内侧，逆时针旋转限位移向内侧 变速线：改变档位到对应的轮盘位置的缆线\n筒式调节器（线束调节纽）：缆线末端旋钮，用于调节缆线长度，逆时针旋转缩短缆线，将导链板向外侧移动 调试前变速器\n确定导链板位置正确 导链板和轮齿之间的间隙应为2-3毫米 导链板应与轮盘平行 L螺钉调节 将前、后拨链器都换至内侧轮。\n检查变速线张力应为松弛状态。\n如果变速线绷紧，则顺时针1-2圈筒式调节器将其松弛。 如果筒式调节器已完全转入，则松开变速线螺拴，松开变速线，重新拧紧螺拴。 检查链条和内链板之间的间隙（约1mm）\n我们可以有意将 L螺钉顺时针旋转，使链条与内链板摩擦，再将 L螺钉逆时针旋转1/4圈。再次检查间隙并重复，直到出现微小间隙。\n逆时针1-2圈回调筒式调节器。\n测试变速 手动拉动变速线线来换档（不要使用变速杆，避免混淆电缆张力问题），向外移动一个轮盘并回到最小轮盘。\n如果链条向内移动得足够快，则L形螺钉设置已完成。 如果链条向内出现明显延迟，L形螺钉逆时针旋转1/4圈，再次测试。 H螺钉调节 将后、前拨链器换至最外侧轮。\n检查变速线\n如果链条蹭导链板（或不移动至最大轮），则缆线太松，逆时针转动筒式调节器。 如果筒式调节器的旋转次数不够，将其完全旋入，然后再旋出2圈，前变速器调回最小档使链条位于最小轮盘，松开变速线螺栓，稍拉紧变速线（中等张力，最紧处松约1-2mm，能挂最大盘且线最紧处），重新拧紧螺栓。 如果仍然不能移动至最大轮，逆时针转动H螺钉。 检查链条和外链板之间的间隙（1mm）\n当移动至最大轮时，我们可以再逆时针转动H螺钉2圈，有意将H螺钉设置得太松。\n压住变速杆，保持变速线最大的压力，链条和外链板之间的间隙应为1mm。\n如果间隙太大，松开变速杆，顺时针拧紧H型螺钉1/4圈，直到链条间隙约1毫米。\n测试变速 压住变速杆，最大轮盘向内移动一个轮盘并返回。\n如果换档很慢，逆时针松开H型螺钉不超过1/4圈。 如果链条从大齿圈外侧掉出，则顺时针拧紧H螺钉1/4圈并再次测试。 变速线调节 将后、前拨链器换至最外侧轮。 查看外笼板和链条之间的间隙 压住变速杆，如果导链板没有移动，顺时针转动筒形调节器以延长变速线。重复操作，直到导链板有轻微的移动。当移动时，将筒式调节器逆时针旋转半圈，重复操作，直到导链板不会向外移动，此时设置完成。\n后变速器 后拨：后轮盘移动链条的装置 T滑轮（齿轮）：下部滑轮，为链条下部提供张力 G滑轮（导轮）：上部滑轮，将链条引导至对应轮盘 筒式调节器（线束调节纽）：逆时针旋转缩短缆线，将G滑轮向内移动\nH限位螺钉：限制后拨最外侧，顺时针旋转限位移向外侧\nL限位螺钉：限制后拨最内侧，逆时针旋转限位移向内侧\nB螺钉：控制导轮和轮盘之间的间隙大小 调试后变速器\nH螺钉调节 将前、后拨链器换至最外侧轮（并确保变速杆也处于最外档）。 如果链条没有换到最小的齿轮，逆时针旋转H螺钉几圈。\n将筒式调节器顺时针旋转几圈，放松变速线，防止混淆换挡位置和限位螺钉。\n我们要有意把H螺钉顺时针拧紧半圈，直到听到链条摩擦内侧齿轮的噪音。此时将H螺钉拧松1/4圈，直到噪音停止，这样较紧的H螺钉位置为准确位置。\n变速线调节 将筒式调节器逆时针旋转几圈，大致恢复到之前的位置。\n如果有两个前链轮，换至最大的链轮上，如果有三个前链轮，则换到中间的链轮。后拨链器换至最小轮。\n转动踏板，将变速器换档，只换一个档位。\n如果链条没有换到下一个档位，则将变速杆返回最外档，逆时针旋转圆筒调节器一整圈。再次换档并重复，直到换档成功。 如果筒式调节器松脱，则完全拧回，然后拧出一两圈。 确保后拨链器换至最小轮（变速杆也要处于最外档），然后松开变速线螺栓，稍拉紧变速线（中等张力，最紧处松约1-2mm，能挂最大盘且线最紧处），重新拧紧螺栓\n如果变速器换档一次会移动两个链轮，换至最小轮，将调节器顺时针旋转一圈，再次测试，现在应该换档正常。\n我们有意逆时针转动筒式调节器，直到听到链条摩擦内侧齿轮的噪音。将筒式调节器顺时针旋转1/4圈 ，直到噪音停止。 向内逐个换档，检查（除最大轮盘外）其他轮盘，如果听到有噪音，将筒式调节器顺时针旋转1/4圈。\n向外逐个换档，检查（除最大轮盘外）其他轮盘，如果向外换档的速度很慢，顺时针旋转1/4圈。\nL螺钉调节 将前、后拨链器均换到第二大轮。\n有意将L螺钉逆时针拧过紧再寻找正确的位置，尝试后拨链器移到最大轮。\n如果链条没有移动，那么 L那么螺钉过紧了。 如果链条缓慢地移到最大轮，也是 L螺钉过紧了。 如果链条在最大轮上时有噪音，也是 L螺钉过紧了。 如果链条没有噪音、也没有缓慢的移动，那么 L螺钉没有过紧。将变速器向外移动一次，顺时针拧紧L螺钉一圈，再次检查，直到 L螺钉过紧。 一旦L螺钉过紧，将 L螺钉逆时针旋出1/4圈，并检查换档至最大齿轮，直到过度噪音和换档缓慢的症状消失。 L螺钉设置已完成。\n检测\n压住变速杆，后拨链器不应向内移动。\nB螺钉（可跳过） B螺钉用于调节导轮与齿轮之间的间距。\n大多数公路和山地自行车变速器需要5-6毫米的间隙（或查阅制造商的规格），可以用6毫米六角扳手测量。\n如果自行车变速良好，B螺钉可能在正常范围，不要太纠结于此。\n如果您确实对B螺钉进行了重大更改，请仔细检查变速线调节，否则变速器已调整正确。\n将链条换到前面最小轮，后面最大轮上。\n要增加间隙，拧紧B螺钉。要减少间隙，松开B螺钉。\n结语 因为骑行的压力与在维修时的压力不同，您可能需要将筒式调节器或限位螺钉再旋转1/4圈。\n如果还有问题，请查看下列高级故障排除表。\n检查项目 问题描述 检查方法 解决方案 变速线系统 线缆摩擦或生锈导致变速不良。 - 检查外壳和止动件是否有裂缝。 - 滑动外壳检查活动度。灰尘和砂砾可能会进入外壳内部。 - 润滑线缆。 - 更换电缆和外壳。 吊架 撞击或摔倒导致吊架弯曲。 从车后观察吊架是否与车轮和链轮平行。 使用吊架校准工具（如 DAG-2.2 或 DAG-3）修复。 不兼容的设备 部件之间的不兼容可能导致变速问题。 - 检查变速器、壳体和链条的兼容性。 - 更换为兼容的部件。 链条问题 链条磨损或润滑不足导致变速迟缓。 - 检查链条磨损程度。 - 检查链条润滑情况。 - 更换链条。 - 润滑链条。 变速器磨损 变速器的枢轴和连杆松动。 横向活动下部支架检查磨损情况。 更换新的变速器。 变速杆磨损 变速杆齿轮磨损或污染导致线缆移动不顺畅。 检查磨损情况。 冲洗齿轮，最好更换变速杆。 常见问题 跳链 变速线设置不佳 调整变速线 换档缓慢 变速线系统摩擦 润滑或更换变速线和外壳 向内换档缓慢 电缆松弛过多 逆时针旋转筒式调节器 向外换档缓慢 变速位置太靠内 顺时针旋转筒式调节器 链条在变速杆压力下跳动 链轮和链条可能磨损 更换链轮和链条 ","date":"2024-11-10T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/sports/","title":"运动装备推荐"},{"content":"fiddler fiddler的缺点是不支持中文，也可以使用另一款针对安卓的抓包软件reqable（前身HttpCanary）。\nSystem Proxy：Fiddler通过系统代理的形式来进行监听请求和响应\n证书：fiddler默认只抓取http协议，要抓取https协议需要在设置中rust Fiddler CA，勾选Capture HTTPS traffic和Ignore server certificate errors\n允许远程连接：\nFilters：过滤器，匹配想要的请求\n更多内容参考官方文档\nAndroid 模拟器 模拟器中，mumu支持android12兼容性最强，雷电模拟器也可以用，而BlueStacks5 不支持代理，夜神的性能较差。\n别的文章说要网络桥接，这样模拟器会断连，无需使用\n打开root权限 打开写入权限(可能会自动关闭，使用时检查) 查看电脑ip，打开WLAN设置填写代理 打开浏览器，输入IP:8888，DOWNLOAD CERTIFICATE，在状态栏点击安装\n移动证书，因为部分应用使用系统证书，需要把证书移动至系统证书目录（以下方法适用于Android 7 到 Android 13）\n在windows窗口运行adb：\n# 查看设备连接 adb devices # 获得权限 adb root \u0026amp;\u0026amp; adb remount # 进入shell adb shell # 切换root用户 su # 查看用户证书的名称 ls /data/misc/user/0/cacerts-added/ # 将用户证书挪至系统证书目录 mv /data/misc/user/0/cacerts-added/[证书] /system/etc/security/cacerts/ # 如果查看证书可以下载MT管理器 真机 用真机肯定麻烦点，但有些app不支持使用模拟器打开。\nroot，Magisk\nWindows放行端口\n控制面板 -\u0026gt; Windows Defender 防火墙 -\u0026gt; 高级设置 -\u0026gt; 入站规则 -\u0026gt; 新建规则\u0026hellip; -\u0026gt; 端口8888\n查看电脑ip，打开WLAN设置填写代理 打开浏览器，输入IP:8888，DOWNLOAD CERTIFICATE，在状态栏点击安装\nMagisk安装模块（允许真机启用 adb root）\n适用于 Android 9/10、适用于 Android 11+\nadb移动证书 # 查看设备连接 adb devices # 获得权限 adb root \u0026amp;\u0026amp; adb remount # 进入shell adb shell # 切换root用户 su # 重新挂载具有读写权限的根（/）分区 mount -o rw,remount / # 查看用户证书 ls /data/misc/user/0/cacerts-added/ # 将用户证书挪至系统证书目录 mv /data/misc/user/0/cacerts-added/[证书] /system/etc/security/cacerts/ # 恢复只读状态 mount -o ro,remount / # 如果查看证书可以下载MT管理器 可以抓包了。如果看到二进制加密数据，就需要破解apk，以后再详细研究。\n","date":"2024-08-30T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/capture/","title":"Fiddler5抓包APP数据"},{"content":" 执业医师考试(中国大陆)专用，精简了大量内容，不作为诊疗建议\n执医技能2024 ","date":"2024-05-26T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/medical/","title":"医学"},{"content":"经济 流动性 流动性，是股市的领先指标，也是影响股价最重要的因素之一。\n中国市场 方法1：看M2同比与名义GDP同比的差值，其逻辑在于央行说的“货币供应量要与名义GDP增速相一致”，如果两者缺口大，那就是出现了过剩的流动性。 点击展开和折叠\r日期 货币供应量-货币和准货币(M2) 同比(季合计) 国内生产总值(GDP) 同比 同比差值 2024年06月份 3050161.54 20.40% 616836 5.00% 15.40% 2024年03月份 3047952.16 25.70% 296299.5 5.30% 20.40% 2023年12月份 2922713.33 30.00% 1260582.1 5.20% 24.80% 2023年9月 2896659.11 31.60% 913027 5.20% 26.40% 2023年6月 2873023.83 35.30% 593034.2 5.50% 29.80% 2023年3月 2814566.31 38.20% 284996.6 4.50% 33.70% 2022年12月 2664320.84 36.00% 1210207.2 3.00% 33.00% 2022年9月 2626600.92 36.30% 874699.3 3.00% 33.30% 2022年6月 2581451.2 33.00% 565428.7 2.50% 30.50% 2022年3月 2497688.34 28.70% 271509.2 4.80% 23.90% 2021年12月 2382899.56 26.20% 1149237 8.10% 18.10% 2021年9月 2342829.7 24.80% 823337.5 9.80% 15.00% 2021年6月 2317788.36 25.00% 532049.4 12.70% 12.30% 2021年3月 2276488.45 28.90% 249200.2 18.30% 10.60% 2020年12月 2186795.89 31.30% 1013567 2.30% 29.00% 2020年9月 2164084.8 32.00% 717948.2 0.70% 31.30% 2020年6月 2134948.66 33.30% 453592.5 -1.60% 34.90% 2020年3月 2080923.41 27.30% 205244.8 -6.80% 34.10% 2019年12月 1986488.82 25.30% 986515.2 6.10% 19.20% 2019年9月 1952250.49 24.70% 709717.2 6.20% 18.50% 2019年6月 1921360.19 25.50% 458670.9 6.30% 19.20% 2019年3月 1889412.14 25.00% 217168.3 6.40% 18.60% 2018年12月 1826744.22 24.10% 919281.1 6.60% 17.50% 2018年9月 1801665.58 25.00% 660472.2 6.70% 18.30% 2018年6月 1770178.37 24.60% 425997.9 6.80% 17.80% 2018年3月 1739859.48 25.60% 202035.7 6.80% 18.80% 2017年12月 1690235.31 26.06% 832035.9 6.90% 19.16% 2017年9月 1663666.05 26.43% 596607.3 6.90% 19.53% 2017年6月 1639497.05 28.07% 383818 6.90% 21.17% 2017年3月 1607938.98 31.27% 181867.7 6.90% 24.37% 2016年12月 1550066.67 34.30% 746395.1 6.70% 27.60% 2016年9月 1516360.5 33.10% 534828.9 6.70% 26.40% 2016年6月 1490491.83 36.40% 343818.2 6.70% 29.70% 2016年3月 1446198.03 40.70% 162410 6.70% 34.00% 2015年12月 1392278.11 40.50% 688858.2 6.90% 33.60% 2015年9月 1359824.06 39.70% 496285.3 6.90% 32.80% 2015年6月 1333375.36 32.70% 319687.6 7.00% 25.70% 2015年3月 1275332.78 34.90% 151137.9 7.00% 27.90% 2014年12月 1228374.81 37.10% 643563.1 7.30% 29.80% 2014年9月 1202051.41 39.20% 462734.2 7.30% 31.90% 2014年6月 1209587.2 41.30% 297249.5 7.40% 33.90% 2014年3月 1160687.38 38.60% 140759.8 7.40% 31.20% 2013年12月 1106524.98 42.10% 592963.2 7.80% 34.30% 2013年9月 1077379.16 43.40% 425190.9 7.80% 35.60% 2013年6月 1054403.69 45.90% 272968.2 7.70% 38.20% 2013年3月 1035858.37 46.80% 129449.6 7.90% 38.90% 2012年12月 974148.8 41.80% 538580 7.90% 33.90% 2012年9月 943688.75 42.20% 386767.9 7.80% 34.40% 2012年6月 924991.2 39.60% 248678.3 7.90% 31.70% 2012年3月 895565.5 38.80% 117357.6 8.10% 30.70% 2011年12月 787406.2 39.20% 487940.2 9.50% 29.70% 2011年9月 787406.2 41.24% 349928 9.80% 31.44% 2011年6月 780820.85 46.30% 223365.8 10.10% 36.20% 2011年3月 758130.88 49.50% 104469.9 10.20% 39.30% 2010年12月 725851.79 58.50% 412119.3 10.60% 47.90% 2010年9月 696471.5 55.80% 292812.4 10.90% 44.90% 2010年6月 673921.72 60.98% 186848.7 11.40% 49.58% 2010年3月 649947.46 74.00% 87501.3 12.20% 61.80% 2009年12月 610224.52 86.84% 348517.7 9.40% 77.44% 2009年9月 585405.34 86.26% 247691.9 8.50% 77.76% 2009年6月 568916.2 80.15% 157845 7.30% 72.85% 2009年3月 530626.71 64.78% 73979.2 6.40% 58.38% 2008年12月 475166.6 47.64% 319244.6 9.70% 37.94% 2008年9月 452898.71 47.64% 230545.6 10.60% 37.04% 2008年6月 443141.02 52.38% 148085.5 11.20% 41.18% 2008年3月 423054.53 52.46% 69373.6 11.50% 40.96% 看国债收益率，低于3.3%时被认为是流动性过剩，4%以上则意味着流动性的收紧。\n美国市场 净流动性 = 美联储资产负债表 - 财政部一般账户 - 反向回购\nA股 通达信公式系统 公式 公式类型\n公式类型 用途 技术指标公式 编写指标在界面上形成曲线，以寻找有意义的技术图形 条件选股公式 选出符合条件的股票 专家系统公式 用于买卖信号指示 五彩K线公式 将满足条件的连续K线形态赋予颜色，区别于其它的K线 公式说明（条件公式为例）\nA:UPNDAY(CLOSE,N);{返回是否CLOSE连涨N个周期} A 指标名称 : 衔接符 := 赋值，该函数输出值可在后续公式中（作为参数）被引用 UPNDAY(CLOSE,N) 输出值 ; 结束符 {返回是否CLOSE连涨N个周期} 注释 函数 参考公式大师\n函数类型 行情函数 财务函数 计算函数 交易函数 其他函数 即时行情 专业财务 逻辑函数 交易信号 时间函数 资金流向 关联财务 选择函数 账号函数 引用函数 序列行情 数学函数 线形和资源 形态函数 统计函数 绘图函数 板块函数 操作符 指数标的 行情函数 即时行情 函数名称 功能描述 示例用法 INDEXA 返回大盘的成交额 INDEXA\n返回上证指数、深证成指、中小板指和创业板指的成交额 INDEXC 返回大盘的收盘价 INDEXC\n返回上证指数、深证成指、中小板指和创业板指的收盘价 INDEXH 返回大盘的最高价 INDEXH\n返回上证指数、深证成指、中小板指和创业板指的最高价 INDEXL 返回大盘的最低价 INDEXL\n返回上证指数、深证成指、中小板指和创业板指的最低价 INDEXO 返回大盘的开盘价 INDEXO\n返回上证指数、深证成指、中小板指和创业板指的开盘价 INDEXV 返回大盘的成交量 INDEXV\n返回上证指数、深证成指、中小板指和创业板指的成交量 暂不能用（供券商用）\r函数名称 功能描述 示例用法 支持情况 INDEXADV 返回大盘的上涨家数 INDEXADV\n返回上证指数、深证成指、中小板指和创业板指的上涨家数 尚未支持 INDEXDEC 返回大盘的下跌家数 INDEXDEC\n返回上证指数、深证成指、中小板指和创业板指的下跌家数 尚未支持 HY_INDEXA 返回行业指数的成交额 HY_INDEXA\n返回对应行业指数的成交额 尚未支持 HY_INDEXADV 返回行业指数的上涨家数 HY_INDEXADV\n返回对应行业指数的上涨家数 尚未支持 HY_INDEXC 返回行业指数的收盘价 HY_INDEXC\n返回对应行业指数的收盘价 尚未支持 HY_INDEXDEC 返回行业指数的下跌家数 HY_INDEXDEC\n返回对应行业指数的下跌家数 尚未支持 HY_INDEXH 返回行业指数的最高价 HY_INDEXH\n返回对应行业指数的最高价 尚未支持 HY_INDEXL 返回行业指数的最低价 HY_INDEXL\n返回对应行业指数的最低价 尚未支持 HY_INDEXO 返回行业指数的开盘价 HY_INDEXO\n返回对应行业指数的开盘价 尚未支持 HY_INDEXV 返回行业指数的成交量 HY_INDEXV\n返回对应行业指数的成交量 尚未支持 DPZSCODE 返回所属大盘指数的代码 CALCSTOCKINDEX(DPZSCODE,'KDJ',3) 尚未支持 UNDERLYC 返回对应标的的收盘价 UNDERLYC\n返回对应标的的收盘价 尚未支持 资金流向 暂不能用（限制版本）\r函数名称 功能描述 详细说明 参数说明 使用限制 ACTINVOL 主动买成交量 相当于L2_VOL(0,2) + L2_VOL(1,2) + L2_VOL(2,2) + L2_VOL(3,2)，用于沪深品种的资金流向功能。 无 仅支持日线级别计算 ACTOUTVOL 主动卖成交量 相当于L2_VOL(0,3) + L2_VOL(1,3) + L2_VOL(2,3) + L2_VOL(3,3)，用于沪深品种的资金流向功能。 无 仅支持日线级别计算 AVGBIDPX 最新委买均价 专业版（资金流向功能）沪深品种行情专用。 无 仅支持日线级别计算 AVGOFFERPX 最新委卖均价 专业版（资金流向功能）沪深品种行情专用。 无 仅支持日线级别计算 BIDCANCELVOL 累计总有效撤买量 累计总有效委买量 - 累计总有效撤买量 = 总买 + 总成交量，专业版（资金流向功能）沪深品种行情专用。 无 仅支持日线级别计算 BIDORDERVOL 累计总有效委买量 累计总有效委买量 - 累计总有效撤买量 = 总买 + 总成交量，专业版（资金流向功能）沪深品种行情专用。 无 仅支持日线级别计算 CUR_BUYORDER 当前总委买量 专业版（资金流向功能）沪深品种行情专用。 无 仅支持日线级别计算 CUR_SELLORDER 当前总委卖量 专业版（资金流向功能）沪深品种行情专用。 无 仅支持日线级别计算 L2_AMO(N,M) 成交额分档 单数分档，按：N(0--3)：超大/大/中/小四档处理，M(0--3)：买入/卖出/主买/主卖四类。 N: 0-3, M: 0-3 仅支持日线级别计算 L2_VOL(N,M) 成交量分档 单数分档，按：N(0--3)：超大/大/中/小四档处理，M(0--3)：买入/卖出/主买/主卖四类。 N: 0-3, M: 0-3 仅支持日线级别计算 L2_VOLNUM(N,M) 单数分档 单数分档，按：N(0--1)：(超大+大)/(中+小)，M(0--1)：买/卖二类。 N: 0-1, M: 0-1 仅支持日线级别计算 LARGEINTRDVOL 逐笔买入大单成交量 相当于L2_VOL(0,0) + L2_VOL(1,0)，沪深品种的资金流向功能专用。 无 仅支持日线级别计算 LARGEOUTTRDVOL 逐笔卖出大单成交量 相当于L2_VOL(0,1) + L2_VOL(1,1)，沪深品种的资金流向功能专用。 无 仅支持日线级别计算 LARGETRDINNUM 逐笔买入大单成交单数 相当于L2_VOLNUM(0,0)，沪深品种的资金流向功能专用。 无 仅支持日线级别计算 LARGETRDOUTNUM 逐笔卖出大单成交单数 相当于L2_VOLNUM(0,1)，沪深品种的资金流向功能专用。 无 仅支持日线级别计算 OFFERCANCELVOL 累计总有效撤卖量 累计总有效委卖量 - 累计总有效撤卖量 = 总卖 + 总成交量，专业版（资金流向功能）沪深品种行情专用。 无 仅支持日线级别计算 OFFERORDERVOL 累计总有效委卖量 累计总有效委卖量 - 累计总有效撤卖量 = 总卖 + 总成交量，专业版（资金流向功能）沪深品种行情专用。 无 仅支持日线级别计算 TRADEINNUM 逐笔买入成交单数 相当于L2_VOLNUM(0,0) + L2_VOLNUM(1,0)，沪深品种的资金流向功能专用。 无 仅支持日线级别计算 TRADENUM 总成交单数 逐笔成交总单数，沪深品种的资金流向功能专用。 无 仅支持日线级别计算 TRADEOUTNUM 逐笔卖出成交单数 相当于L2_VOLNUM(0,1) + L2_VOLNUM(1,1)，沪深品种的资金流向功能专用。 无 仅支持日线级别计算 序列行情 函数名称 功能描述 C（CLOSE） 返回该周期的收盘价 O（OPEN） 返回该周期的开盘价 H（HIGH） 返回该周期的最高价 L（LOW） 返回该周期的最低价 AMO（AMOUNT） 返回该周期的成交额，单位为元 V（VOL） 返回该周期的成交量，单位为手 ADVANCE 返回该周期的上涨家数，仅对沪深指数有效 DECLINE 返回该周期的下跌家数，仅对沪深指数有效 最好不用（特殊）\r函数名称 功能描述 备注 DCLOSE 返回不定周期的收盘价 未来函数（紫色标记） DHIGH 返回不定周期的最高价 未来函数（紫色标记） DLOW 返回不定周期的最低价 未来函数（紫色标记） DOPEN 返回不定周期的开盘价 未来函数（紫色标记） DVOL 返回不定周期的成交量 未来函数（紫色标记） HKSHORTVOL 返回该周期的抛空量 仅对港股有意义 QHJSJ 返回该周期的结算价 仅对期货和期权有意义 VOLINSTK 返回该周期的持仓量 仅对期货和期权有意义 ZSTJJ 返回该周期的分时图均价线 仅对分时图周期指标有效 SECTOTIME 求0时后若干秒是什么时间，有效秒数为0~86399 仅支持日线级别 TIMETOSEC 求指定时间距0时有多长时间，单位为秒，有效时间为0~235959 仅支持日线级别 形态函数 待写\n板块函数 待写\n指数标的 待写\n财务函数 专业财务 专业财务数据需要每天及时下载更新：通达信软件 -\u0026gt; 选项 -\u0026gt; 专业财务数据\n函数名称 功能描述 FINVALUE(ID) 引用专业财务数据。如果当期没有出来，引用最近一期的数据。 FINONE(ID,Y,MMDD) 引用指定年和月日的某类型的财务数据。 参数：ID为数据编号\nID详情\r分类 编号 指标名称 0 返回报告期(YYMMDD格式),150930表示为2015年第三季 每股指标 1 基本每股收益 2 扣除非经常性损益每股收益 3 每股未分配利润 4 每股净资产 5 每股资本公积金 6 净资产收益率 7 每股经营现金流量 资产负债表 8 货币资金 9 交易性金融资产 10 应收票据 11 应收账款 12 预付款项 13 其他应收款 14 应收关联公司款 15 应收利息 16 应收股利 17 存货 18 其中：消耗性生物资产 19 一年内到期的非流动资产 20 其他流动资产 21 流动资产合计 22 可供出售金融资产 23 持有至到期投资 24 长期应收款 25 长期股权投资 26 投资性房地产 27 固定资产 28 在建工程 29 工程物资 30 固定资产清理 31 生产性生物资产 32 油气资产 33 无形资产 34 开发支出 35 商誉 36 长期待摊费用 37 递延所得税资产 38 其他非流动资产 39 非流动资产合计 40 资产总计 41 短期借款 42 交易性金融负债 43 应付票据 44 应付账款 45 预收款项 46 应付职工薪酬 47 应交税费 48 应付利息 49 应付股利 50 其他应付款 51 应付关联公司款 52 一年内到期的非流动负债 53 其他流动负债 54 流动负债合计 55 长期借款 56 应付债券 57 长期应付款 58 专项应付款 59 预计负债（非流动负债） 60 递延所得税负债 61 其他非流动负债 62 非流动负债合计 63 负债合计 64 实收资本（或股本） 65 资本公积 66 盈余公积 67 减：库存股 68 未分配利润 69 少数股东权益 70 外币报表折算价差 71 非正常经营项目收益调整 72 所有者权益（或股东权益）合计 73 负债和所有者（或股东权益）合计 利润表 74 其中：营业收入 75 其中：营业成本 76 营业税金及附加 77 销售费用 78 管理费用 79 勘探费用 80 财务费用 81 资产减值损失 82 加：公允价值变动净收益 83 投资收益 84 其中：对联营企业和合营企业的投资收益 85 影响营业利润的其他科目 86 三、营业利润 87 加：补贴收入 88 营业外收入 89 减：营业外支出 90 其中：非流动资产处置净损失 91 加：影响利润总额的其他科目 92 四、利润总额 93 减：所得税 94 加：影响净利润的其他科目 95 五、净利润 96 归属于母公司所有者的净利润 97 少数股东损益 现金流量表 98 销售商品、提供劳务收到的现金 99 收到的税费返还 100 收到其他与经营活动有关的现金 101 经营活动现金流入小计 102 购买商品、接受劳务支付的现金 103 支付给职工以及为职工支付的现金 104 支付的各项税费 105 支付其他与经营活动有关的现金 106 经营活动现金流出小计 107 经营活动产生的现金流量净额 108 收回投资收到的现金 109 取得投资收益收到的现金 110 处置固定资产、无形资产和其他长期资产收回的现金净额 111 处置子公司及其他营业单位收到的现金净额 112 收到其他与投资活动有关的现金 113 投资活动现金流入小计 114 购建固定资产、无形资产和其他长期资产支付的现金 115 投资支付的现金 116 取得子公司及其他营业单位支付的现金净额 117 支付其他与投资活动有关的现金 118 投资活动现金流出小计 119 投资活动产生的现金流量净额 120 吸收投资收到的现金 121 取得借款收到的现金 122 收到其他与筹资活动有关的现金 123 筹资活动现金流入小计 124 偿还债务支付的现金 125 分配股利、利润或偿付利息支付的现金 126 支付其他与筹资活动有关的现金 127 筹资活动现金流出小计 128 筹资活动产生的现金流量净额 129 四、汇率变动对现金的影响 130 四(2)、其他原因对现金的影响 131 五、现金及现金等价物净增加额 132 期初现金及现金等价物余额 133 期末现金及现金等价物余额 现金流量表补充资料 134 净利润 135 加：资产减值准备 136 固定资产折旧、油气资产折耗、生产性生物资产折旧 137 无形资产摊销 138 长期待摊费用摊销 139 处置固定资产、无形资产和其他长期资产的损失 140 固定资产报废损失 141 公允价值变动损失 142 财务费用 143 投资损失 144 递延所得税资产减少 145 递延所得税负债增加 146 存货的减少 147 经营性应收项目的减少 148 经营性应付项目的增加 149 其他 150 经营活动产生的现金流量净额2 151 债务转为资本 152 一年内到期的可转换公司债券 153 融资租入固定资产 154 现金的期末余额 155 减：现金的期初余额 156 加：现金等价物的期末余额 157 减：现金等价物的期初余额 158 现金及现金等价物净增加额 偿债能力分析 159 流动比率（非金融类指标） 160 速动比率（非金融类指标） 161 现金比率（%）（非金融类指标） 162 利息保障倍数（非金融类指标） 163 非流动负债比率（%）（非金融类指标） 164 流动负债比率（%）（非金融类指标） 166 有形资产净值债务率（%） 167 权益乘数（%） 168 股东的权益/负债合计（%） 169 有形资产/负债合计（%） 170 经营活动产生的现金流量净额/负债合计（%）（非金融类指标） 171 EBITDA/负债合计（%）（非金融类指标） 经营效率分析 172 应收账款周转率（非金融类指标） 173 存货周转率（非金融类指标） 174 运营资金周转率（非金融类指标） 175 总资产周转率（非金融类指标） 176 固定资产周转率（非金融类指标） 177 应收账款周转天数（非金融类指标） 178 存货周转天数（非金融类指标） 179 流动资产周转率（非金融类指标） 180 流动资产周转天数（非金融类指标） 181 总资产周转天数（非金融类指标） 182 股东权益周转率（非金融类指标） 发展能力分析 183 营业收入增长率（%） 184 净利润增长率（%） 185 净资产增长率（%） 186 固定资产增长率（%） 187 总资产增长率（%） 188 投资收益增长率（%） 189 营业利润增长率（%） 190 扣非每股收益同比（%） 191 扣非净利润同比（%） 192 暂无 获利能力分析 193 成本费用利润率（%） 194 营业利润率（非金融类指标） 195 营业税金率（非金融类指标） 196 营业成本率（非金融类指标） 197 净资产收益率 198 投资收益率 199 销售净利率（%） 200 总资产净利率 201 净利润率（非金融类指标） 202 销售毛利率（%）（非金融类指标） 203 三费比重（非金融类指标） 204 管理费用率（非金融类指标） 205 财务费用率（非金融类指标） 206 扣除非经常性损益后的净利润 207 息税前利润（EBIT） 208 息税折旧摊销前利润（EBITDA） 209 EBITDA/营业总收入（%）（非金融类指标） 资本结构分析 210 资产负债率（%） 211 流动资产比率（非金融类指标） 212 货币资金比率（非金融类指标） 213 存货比率（非金融类指标） 214 固定资产比率 215 负债结构比（非金融类指标） 216 归属于母公司股东权益/全部投入资本（%） 217 股东的权益/带息债务（%） 218 有形资产/净债务（%） 现金流量分析 219 每股经营性现金流（元） 220 营业收入现金含量（%）（非金融类指标） 221 经营活动产生的现金流量净额/经营活动净收益（%） 222 销售商品提供劳务收到的现金/营业收入（%） 223 经营活动产生的现金流量净额/营业收入 224 资本支出/折旧和摊销 225 每股现金流量净额（元） 226 经营净现金比率（短期债务）（非金融类指标） 227 经营净现金比率（全部债务） 228 经营活动现金净流量与净利润比率 229 全部资产现金回收率 单季度财务指标 230 营业收入 231 营业利润 232 归属于母公司所有者的净利润 233 扣除非经常性损益后的净利润 234 经营活动产生的现金流量净额 235 投资活动产生的现金流量净额 236 筹资活动产生的现金流量净额 237 现金及现金等价物净增加额 股本股东 238 总股本 239 已上市流通A股 240 已上市流通B股 241 已上市流通H股 242 股东人数（户） 243 第一大股东的持股数量 244 十大流通股东持股数量合计（股） 245 十大股东持股数量合计（股） 机构持股 246 机构总量（家） 247 机构持股总量（股） 248 QFII机构数 249 QFII持股量 250 券商机构数 251 券商持股量 252 保险机构数 253 保险持股量 254 基金机构数 255 基金持股量 256 社保机构数 257 社保持股量 258 私募机构数 259 私募持股量 260 财务公司机构数 261 财务公司持股量 262 年金机构数 263 年金持股量 更多新增指标 软件内参见函数 参数：Y、MMDD表示年、月日\nY MMDD 解释 0 0 最新财报数据 0 1-300 前推 MMDD 期的数据 0 0331、0630、0930、1231 0331最近一季报、0630最近二季报、0930最近三季报、1231最近四季报 n 0 最近一期向前推 n 年的同期数据 关联财务函数 函数名称 功能描述 CAPITAL 获取当前流通股本的数量（以手为单位）。 FINANCE(ID) 引用财务数据。如果当期数据尚未发布，则引用最近一期的数据。 TOTALCAPITAL 返回当前总股本的数量（以手为单位）。 最好不用（特殊）\r函数名称 功能描述 MINDIFF 返回某品种的最小变动价位（即交易价格的最小间隔单位）。 MULTIPLIER 返回期货每手的乘数。 SETCODE 返回市场类型的代码，例如：0（深圳）、1（上海）、47（中金所期货）等。 TQFLAG 返回当前的复权状态：0（无复权）、1（前复权）、2（后复权）。 USEDDATANUM 返回当前使用的数据个数。 计算函数 逻辑函数 函数名称 功能描述 示例/用法 CROSS 判断两条线是否交叉 CROSS(A, B): 当A从下方向上穿过B时返回1，否则返回0。 DOWNNDAY 判断是否连续下跌 DOWNNDAY(CLOSE, M): 连续M个周期下跌，M为常量。 EVERY 判断条件是否一直成立 EVERY(CLOSE \u0026gt; OPEN, 10): 前10日内一直为阳线。 EXIST 判断条件是否存在 EXIST(CLOSE \u0026gt; OPEN, 10): 前10日内存在阳线。 LAST 判断条件是否持续存在 LAST(CLOSE \u0026gt; OPEN, 10, 5): 前10日到前5日内一直为阳线。 LONGCROSS 判断两条线在维持周期后交叉 LONGCROSS(A, B, N): A在N周期内都小于B，本周期从下方向上穿过B时返回1。 NDAY 判断条件是否连续成立 NDAY(CLOSE, OPEN, 3): 连续3日收阳线。 NOT 逻辑取反 NOT(ISUP): 表示平盘或收阴。 UPNDAY 判断是否连续上涨 UPNDAY(CLOSE, M): 连续M个周期上涨，M为常量。 选择函数 函数名称 功能 描述 用法 示例 IF 条件判断 根据条件求不同的值。 IF(X,A,B) IF(CLOSE\u0026gt;OPEN,HIGH,LOW)，表示该周期收阳则返回最高值，否则返回最低值。 IFF 条件判断 根据条件求不同的值。 IFF(X,A,B) IFF(CLOSE\u0026gt;OPEN,HIGH,LOW)，表示该周期收阳则返回最高值，否则返回最低值。 IFN 条件反判断 根据条件求不同的值，同IF判断相反。 IFN(X,A,B) IFN(CLOSE\u0026gt;OPEN,HIGH,LOW)，表示该周期收阴则返回最高值，否则返回最低值。 VALUEWHEN 条件跟随 当COND条件成立时，取X的当前值，否则取VALUEWHEN的上个值。 VALUEWHEN(COND,X) 最好不用（特殊）\r函数名称 功能 描述 用法 示例 IFC 条件判断，可中止 根据条件求不同的值，可中止。 IFC(X,A,B) IFC(CLOSE\u0026gt;OPEN,HIGH,TESTSKIP(1))，表示当日收阳则返回最高值，并执行下一句代码，否则退出公式计算。 TESTSKIP 是否就此返回 满足A则直接返回。表示如果满足条件A则该公式直接返回，不再计算接下来的表达式。 TESTSKIP(A) TESTSKIP(1)，满足条件则直接返回，不再计算后续表达式。 数学函数 函数名称 功能 用法示例 详细描述 ABS 绝对值 ABS(-34) 返回 34 返回输入值的绝对值。 ACOS 反余弦 ACOS(X) 返回输入值的反余弦值。 ASIN 反正弦 ASIN(X) 返回输入值的反正弦值。 ATAN 反正切 ATAN(X) 返回输入值的反正切值。 CEILING 向上舍入 CEILING(12.3) 返回 13 返回沿数值增大方向最接近的整数。 COS 余弦 COS(X) 返回输入值的余弦值。 EXP 指数 EXP(CLOSE) 返回 e 的输入值次幂。 FLOOR 向下舍入 FLOOR(12.3) 返回 12 返回沿数值减小方向最接近的整数。 FRACPART 小数部分 FRACPART(X) 返回输入值的小数部分。 IINTPART 整数部分 INTPART(12.3) 返回 12 返回输入值的整数部分。 LN 自然对数 LN(CLOSE) 返回输入值的自然对数（以 e 为底）。 LOG 对数 LOG(100) 返回 2 返回输入值的常用对数（以 10 为底）。 MAX 较大值 MAX(CLOSE-OPEN, 0) 返回两个输入值中的较大值。 MIN 较小值 MIN(CLOSE, OPEN) 返回两个输入值中的较小值。 MOD 余数 MOD(5,3) 返回 2 返回输入值的模（余数）。 POW 乘幂 POW(CLOSE,3) 返回第一个输入值的第二个输入值次幂。 RAND 随机正整数 RAND(N) 返回范围在 1 到 N 之间的随机整数。 ROUND 四舍五入 ROUND(X) 返回输入值四舍五入到个位的数值。 ROUND2 四舍五入 ROUND2(X, N) 返回输入值四舍五入到 N 位小数的数值。 SIGN 符号 SIGN(X) 返回输入值的符号。当 X\u0026gt;0，X=0，X\u0026lt;0 时，分别返回 1，0，-1。 SIN 正弦 SIN(X) 返回输入值的正弦值。 SQRT 开方 SQRT(CLOSE) 返回输入值的平方根。 TAN 正切 TAN(X) 返回输入值的正切值。 BETWEEN 介于 BETWEEN(CLOSE, MA(CLOSE,10), MA(CLOSE,5)) 判断输入值是否介于两个指定值之间。如果介于其中，则返回 1，否则返回 0。 统计函数 函数名称 功能描述 用法示例 AVEDEV 平均绝对偏差 AVEDEV(X,N) COVAR 协方差 COVAR(X,Y,N) DEVSQ 数据偏差平方和 DEVSQ(X,N) RELATE 相关系数 RELATE(X,Y,N) SLOPE 线性回归斜率 SLOPE(X,N) STD 估算标准差 STD(X,N) STDP 总体标准差 STDP(X,N) VAR 估算样本方差 VAR(X,N) VARP 总体样本方差 VARP(X,N) 最好不用（特殊）\r函数名称 功能描述 用法示例 BETA β系数 BETA(N) BETAEX 相关放大系数 BETAEX(X,Y,N) BLOCKSETNUM 板块股个数 BLOCKSETNUM(板块名称) FORCAST 线性回归预测值 FORCAST(X,N) HORCALC 板块统计 HORCALC(板块名称,数据项,计算方式,权重) INSORT 板块指标排序 INSORT(板块名称,指标名称,指标线,升降序) INSUM 板块指标统计 INSUM(板块名称,指标名称,指标线,计算类型) IVOLAT 期权波动率 IVOLAT(N,M) STDDEV 标准偏差 STDDEV(X,N) 操作符 操作符 功能 描述 != 不等于 用于判断两个值是否不相等。 \u0026amp;\u0026amp; 逻辑“与” 用于组合多个条件，只有所有条件都为真时结果才为真。 ' 单引号 用于字符串或文本内容。 () 括号 用于改变运算优先级或组合表达式。 * 乘法 用于数值相乘。 + 加法 用于数值相加。 , 逗号 用于分隔函数参数或多个表达式。 - 减法 用于数值相减。 / 除法 用于数值相除。 : 输出操作符 用于输出结果。 := 赋值操作符 将值赋给变量。 ; 分号 用于分隔语句或结束语句。 \u0026lt; 小于 用于判断 X 是否小于 Y。 \u0026lt;= 小于等于 用于判断 X 是否小于等于 Y。 \u0026lt;\u0026gt; 不等于 与 != 用法相同。 \u0026gt; 大于 用于判断 X 是否大于 Y。 \u0026gt;= 大于等于 用于判断 X 是否大于等于 Y。 AND 逻辑“与” 用于组合多个条件，只有所有条件都为真时结果才为真。 OR 逻辑“或” 用于组合多个条件，只要其中一个条件为真，结果即为真。 {} 注释 用于添加注释内容。 || 逻辑“或” 与OR相同。 = 等于 用于判断两个值是否相等。 最好不用（特殊）\r操作符 功能 描述 \u0026quot; 双引号 用于引用特定数据 # 跨周期引用符号 用于引用不同周期的数据 $ 引用特定数据 用于引用特定股票代码的数据 . 引用指标输出 用于引用指标的输出值 交易函数 待写\n其他函数 待写\n美股 开户 主要账户类型 账户用途 Checking Account 支票账户 平时开支消费专用。 Savings Account 储蓄账户 活期账户，通常用来保持资金流动。 Certificates of Deposits 定期存款账户 用于存定期存款的账户。 美国银行开户需要准备的资料：\n美国实体手机卡：Paygo、redpacket 美国私人地址（用来申请银行账号/信用卡、美国税号TIN）：AnytimeMailbox ITIN（作为身份验证、银行要求提供的地址证明） 美国独立IP 券商 互联网券商富途证券、老虎证券，不被允许面向境内投资者开展跨境证券业务之后，美国本土券商的选择有嘉信理财（Chales Schwab）、富达证券（fidelity）、Etrade、美林证券、TradeKing、盈透（Interactive Broker）、德美利（TD Ameritrade）、第一证券等。较好的选择有盈透证券、嘉信理财、富达证券。\n嘉信理财 盈透证券 储蓄 0.45% 4.58%（资金大于1万美元） 固定收益产品（国债、企业债） 三个月约5% \\ 佣金 0 1美元~交易价值的1% 客户端 网页（交易价格劣势） 专业APP 银行卡 2023-08后大陆不给（全球免费取款） 大陆不给开 中文客服 有 \\ 全球交易需求 \\ 免费多币种转换，且无汇率差额 融资/杠杆 13% 6.570% 出金 免费 每个月第一笔免费（如果有中转银行可能收费） 转账 一般转到 Checking Account，频繁转账容易风控\n转账方式：\nZelle　美国银行间的即时转账系统，限额$1500～$2500/天, $5000～$10000/月，免费 ACH　自动清算系统，1～3个工作日到帐，限额取决于转出行（比Zelle多一些），大部分银行免费（BOA等银行转出需$3） 电汇　可大额、跨境，手续费高 参考资料：course.yiwiz.com\n","date":"2023-09-16T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/stocks/","title":"投资港美A股"},{"content":"不可逆算法（哈希HASH） 哈希算法 哈希算法：将一段（通常是较大的）数据映射为较短小的数据。这段小数据就是大数据的哈希值，它是唯一的，一旦大数据发生变化，他的哈希值也会发生变化。\n哈希碰撞\n哈希碰撞是指，两个不同的输入得到了相同的输出：\n\u0026#34;AaAaAa\u0026#34;.hashCode(); // 0x7460e8c0 \u0026#34;BBAaBB\u0026#34;.hashCode(); // 0x7460e8c0 碰撞能不能避免，哈希算法的输出长度越长，碰撞概率越小。\n算法 输出长度（位） 输出长度（字节） MD5 128 bits 16 bytes SHA-1 160 bits 20 bytes RipeMD-160 160 bits 20 bytes SHA-256 256 bits 32 bytes SHA-512 512 bits 64 bytes 应用：\n用于密码管理 - 把用户的密码以MD5值（或类似的其它算法）的方式保存起来，用户注册的时候，系统是把用户输入的密码计算成 MD5 值，然后再去和系统中保存的 MD5 值进行比较，如果密文相同，就可以认定密码是正确的，否则密码错误。通过这样的步骤，系统在并不知道用户密码明码的情况下就可以确定用户登录系统的合法性。如果数据库泄漏，黑客也无法拿到用户的原始口令，如果黑客有一个预先计算好的常用口令和它们的MD5的对照表（彩虹表），就能反查到原始口令，我们可以采取措施来抵御，方法是对每个口令额外添加随机数，这个方法称之为加盐。 电子签名 - 使用 MD5算法就可以为任何文件（不管其大小、格式、数量）产生一个独一无二的数字指纹，借助这个数字指纹，通过检查文件前后 MD5 值是否发生了改变，就可以知道源文件是否被改动。 基于密钥的哈希算法 HMAC:类似“加盐”的MD5，Hmac本质上就是把安全key混入摘要的算法。\n可逆算法 对称加密 加密：明文 -\u0026gt; 密钥加密 -\u0026gt; 密文。\n解密：密文 -\u0026gt; 密钥解密 -\u0026gt; 明文。\n经典加密算法有三种 ：\nDES(Data Encryption Standard)：数据加密标准(现在用的比较少，因为它的加密强度不够，能够暴力破解) 3DES：原理和DES几乎是一样的，只是使用3个密钥，对相同的数据执行三次加密，增强加密强度。(缺点：要维护3个密钥，大大增加了维护成本) AES(Advanced Encryption Standard)：高级加密标准，目前美国国家安全局使用的，苹果的钥匙串访问采用的就AES加密。是现在公认的最安全的加密方式，是对称密钥加密中最流行的算法。 加密模式 ：\nECB模式（默认）：电码本模式 Electronic Codebook Book，就是每个块都是独立加密 CBC模式：密码分组链接模式 Cipher Block Chaining，使用一个密钥和一个初始化向量(IV)对数据执行加密转换 CTR模式：计算器模式 Counter CFB模式：密码反馈模式 Cipher FeedBack OFB模式：输出反馈模式 Output FeedBack 加密模式是加密过程对独立数据块的处理。对于较长的明文进行加密需要进行分块加密，在实际开发中，推荐使用CBC的，ECB的要少用。\n非对称加密RSA 发送公钥 -\u0026gt; 对方用公钥加密 -\u0026gt; 收到密文、私钥解密\n常见的非对称加密算法有：RSA、DSA(美国国家标准局提出)、ECC(椭圆曲线密码学)、DH等。\nECC 算法比 RSA、DSA 速度更快，基于 ECC 的签名算法主要有两种：ECDSA 与 EdDSA， EdDSA 比 ECDSA 更简洁更快一点，因此现在通常更推荐使用 EdDSA 算法。目前 EdDSA 有两个方案：Ed25519 和 Ed448。\n","date":"2023-08-13T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/encrypt/","title":"加密算法"},{"content":"想要体验二合一笔记本，大约有这些选择：\nsurface pro ROG 幻X，高配显卡反而拉低续航，二合一的屏幕尺寸也不适合打游戏 Chromebook，折腾。 x-station？ 目前结论：\n推荐Surface Pro 11 ，兼容性最好，性能现在也挺强了。但这个价格很多人也会考虑买性能强大、也算轻便的Mac（少了触屏）。\nChromebook duet5 硬件尚可，续航高，但Chrome OS还不成熟，不适配的bug很多，体验不佳。不过使用其它Android平板或Ipad体验也很一般，只轻度使用（电子书、视频等）可以尝试。\nChromebook duet5 开启开发者模式 首先SSTap分享网络登录进去（参考前文）。\n从主机上取下可拆卸键盘，按住[提高音量]+[降低音量]+[电源按钮]约 10 秒钟，然后松开，您应该看到恢复模式屏幕。（Chromebook duet5和其他机型的方法有所不同）\n音量键可以切换语言，然后选中高级-\u0026gt;开发者模式-\u0026gt;从内部磁盘启动，系统将发出哔哔声重新启动并开始设置。\n双拼输入法 项目地址\n谷歌插件商店，先安装IME UI控件 ，然后再安装IME Decoder(chrome \u0026gt; 102) 。\n系统设置-\u0026gt;语言与输入法-\u0026gt;添加输入法,找到\u0026quot;中文双拼输入法\u0026quot;添加并选择启用输入。\n","date":"2023-04-16T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/chromebook/","title":"二合一笔记本"},{"content":"购买vps一般需要注意性能、带宽和线路。\n性能是根据自身需要的，一般只需要看内存，跑代理512M足够了（考虑到有邻居还是建议1G），跑业务最好在2G以上。\n带宽只要搜一下商家的测评，注意共享带宽的实际速度、晚高峰速度就行了。\n线路却是一个相对复杂的问题。不仅海内外线路繁多，不同运营商、不同省市的情况也不同，所以最好自己测试（测试方法见下文）。如果不想测，可以去主机测评网等网站看测评，或者电信用CN2、联通用AS9929、移动用CMI。\n使用机场最好用IPLC/IEPL线路，几乎不会断连，有名的telegram测评频道前女友们用过的机场可以参考。用机场隐私泄露风险较高。\n常见线路 国内运营商 IPLC/IEPL国际私用出租线路\n电信的163骨干网自治系统编号 AS4134\n电信的CN2骨干网自治系统编号 AS4809 （优秀）\n联通的169骨干网自治系统编号 AS4837\n联通的A网骨干网自治系统编号 AS9929 （优秀）\n移动的CMNET境内骨干网自治系统编号 AS9808\n移动的CMI境外骨干网自治系统编号 AS58453\nCERNET（教育网，主用于高校）骨干网自治系统编号 AS4538\nCSTNET（科技网）骨干网自治系统编号 AS7497\nBGP 边界网关协议，主要是用来连接网络上的独立系统的路由选择协议。主要功能是在传输过程中会选择最优的路由线路。比一般线路要好，但不使用cn2这种最优质线路。\n国外运营商 日本 常见线路：NTT、KDDI、IIJ、SoftBank（软银）、Telstra、PCCW\n新加坡 常见线路：NTT、Tata通信、Telstra、PCCW、sg.gs\n韩国 常见线路：KT、SK、LG\n香港 常用线路：PCCW、Telstra、HKBN、HKT、HGC、NTT（香港）、Azure、Google Cloud Platform、Gcorelabs、Tata通信\n俄罗斯 常见线路：RosTelecom（俄罗斯电信）、TTK（俄罗斯铁通）、MTS、Megfon、RETN\n英国 常见线路：Telia、Cogentco、Level3、Zayo、Tata通信\n实际体验（以往返总延迟排序） 最优： 香港IPLC/IEPL、日本IPLC/IEPL、香港CN2 GIA：价格高。\n日本SoftBank（推荐）：约100+ms。\n次优： 新加坡CN2：约200ms，价格稍高。\n日本IIJ：约200+ms。\n香港CMI：约200+ms。移动网可能好用（我不是），有高峰期。\n新加坡NTT：约300+ms。慎买。\n美国CN2\\美国AS9929（推荐）：约500ms。性价比高，网络审查宽松，且访问的大多服务器设在美国。\n差线路： racknerd等很廉价，绕路线路，但适合测试用。\n优质VPS推荐 BandwagonHost（搬瓦工）：日本软银$169/年（高配）。香港 CN2 GIA最低$899.99/年。\nv.ps(需实名):日本软银特价款约39、49欧元/年（经常缺货）。\nDMIT：美国CN2特价款$36.90/年（经常缺货）。\nZgoCloud（2021年新商家）：美国AS9929特价款$38.90/年。\nvmiss（2022年新商家）：有日本IIJ， 美国CN2、9929的平价大带宽产品。需要注意，他家IP虽然可以解锁大多服务，但使用的是广播ip。\n其它卖优质VPS的商家还有Vultr、Linode、digitalocean等。\n提示：\n机场很可能跑路，用机场一定要月付。\n北方地区日本线路表现更好。\n有些商家线路会绕路欧美，最好自测。\n香港vps：很可能有高峰期，便宜商家的机房容易受到攻击。认准口碑商家，否则不要买。\n韩国vps：用过1次，一个月后要求韩国身份实名，不知道是不是都这样。\n推荐：美国、新加坡vps表现好价格合适。日本vps极少数小问题，不影响使用。\n测试线路 测试全国到VPS的延迟 ipip.net的ping工具输入ip，选择中国，然后ping。\n路由跟踪 去程路由跟踪 方式一：下载BestTrace软件，点路由跟踪，输入ip，开始。\n方式二：ipip.net的traceroute工具选地区，输入ip，查看。\n回程路由跟踪 回程跟踪需要连接到VPS，执行以下命令\nyum install -y wget unzip \u0026amp;\u0026amp; wget https://cdn.ipip.net/17mon/besttrace4linux.zip \u0026amp;\u0026amp; unzip best ./besttrace [你的本地ip] -g cn ","date":"2023-03-13T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/vps/","title":"VPS 选购"},{"content":"排列组合 1.特殊元素和特殊位置优先策略 例 1. 由 0,1,2,3,4,5 可以组成多少个没有重复数字五位奇数？\n解析\r先排末位共有 $C_3^1$, 然后排首位共有 $C_4^1$, 最后排其它位置共有 $A_4^3$, 由分步计数原理得 $C_4^1 C_3^1 A_4^3=288$ 。\n2.相邻问题捆绑法: 题目中规定相邻的几个元素捆绑成一个组，当作一个大元素参与排列.\n例 1. A,B,C,D,E 五人并排站成一排，如果 A,B必须相邻且 B在 A的右边，则不同的排法有（ ）\nA、60 种 B、48 种 C、36 种 D、24 种\n解析\r把 A,B 视为一人，且 B 固定在 A 的右边，则本题相当于 4 人的全排列，$A_4^4$=24 种， 答案： D .\n例 2. 7 人站成一排 ,其中甲乙相邻且丙丁相邻,共有多少种不同的排法.\n解析\r可先将甲乙两元素捆绑成整体并看成一个复合元素，同时丙丁也看成一个复合元素，再与其它元素进行排列，同时对相邻元素内部进行自排。由分步计数原理可得共有 $A_5^5$$A_2^2$$A_2^2$= 480种不同的排法\n3.相离问题插空策略: 元素相离（即不相邻）问题，可先把无位置要求的几个元素全排列，再把规定的相离的几个 元素插入上述几个元素的空位和两端.\n例 1. 七人并排站成一行，如果甲乙两个必须不相邻，那么不同的排法种数是（ ）\nA、1440 种 B、3600 种 C、4820 种 D、4800 种\n解析\r除甲乙外，其余 5 个排列数为$A_5^5$种，再用甲乙去插 6 个空位有$A_6^2$种，不同的排法种数是$A_5^5$$A_6^2$=3600 种， 选 B.\n例 2. 某人射击八枪,命中四枪,四枪中恰好有三枪连在一起的情形的不同种数为?\n解析\r把连续命中的三枪看做一个整体a,剩下命中的一枪看做一个整体b,用插空法,把a,b两个元素按一定顺序插到剩下四枪形成的5个空隙里,是$A_5^2$=20\n4.定序问题: 例 1. 7 人排队，其中甲乙丙 3 人顺序一定（可以不相邻），共有多少不同的排法?\n解析\r(倍缩法) 对于某几个元素顺序一定的排列问题，可先把这几个元素与其他元素一起进行排列，然后用总排列数除以这几个元素之间的全排列数，则共有不 同排法种数是: $A_7^7 / A_3^3$\n(空位法) 设想有7把椅子让除甲乙丙以外的四人就坐共有$A_7^4$ 种方法，其余的三个位置甲乙丙共有（1）种坐法，则共有$A_7^4$ 种方法。\n5.有序分配问题逐分法: 有序分配问题指把元素分成若干组，可用逐步下量分组法.\n例 1. 有甲乙丙三项任务，甲需 2 人承担，乙丙各需一人承担，从 10 人中选出 4 人承担这三项任务，不同的选法种数是（ ）\nA、1260 种 B、2025 种 C、2520 种 D、5040 种\n解析\r先从 10 人中选出 2 人承担甲项任务，再从剩下的 8 人中选 1 人承担乙项任务，第三步从另外的 7 人中选1 人承担丙项任务，不同的选法共有 $C_{10}^{2}$$C_8^1$$C_7^1$=2520 种，选 C.\n例 2. 12 名同学分别到三个不同的路口进行流量的调查，若每个路口 4 人，则不同的分配方案有（ A）\nA、$C_{12}^{4}$$C_8^4$$C_4^4$ 种 B、3$C_{12}^{4}$$C_8^4$$C_4^4$ 种 C、$C_{12}^{4}$$C_8^4$$A_3^3$ 种 D、$\\frac{C_{12}^{4}C_8^4C_4^4}{A_3^3}$ 种\n6.元素不同的分配问题先选后排: 例 1. 4 名优秀学生全部保送到 3 所学校去，每所学校至少去一名，则不同的保送方案有多少种？\n解析\r把四名学生分成 3 组有 $C_4^2$ 种方法，再把三组学生分配到三所学校有 $A_3^3$ 种，故共有 $C_4^2$$A_3^3$=36 种方法.\n例 2. 5 本不同的书，全部分给 4 个学生，每个学生至少一本，不同的分法种数为（ ）\nA、480 种　B、240 种 C、120 种 D、96 种\n解析\rB. $C_5^3$$A_4^4$=240\n7.元素相同的分配问题隔板法: 例 1： 10 个三好学生名额分到 7 个班级，每个班级至少一个名额，有多少种不同分配方案？\n解析\r10 个名额分到 7 个班级，就是把 10 个名额看成 10 个相同的小球分成 7 堆，每堆至少一个，可以在 10 个小球的 9 个空位中插入 6 块木板，每一种插法对应着一种分配方案，故共有不同的分配方案为$C_9^6$=84 种.\n例 2： 若x+y+z+w=100,求这个方程组的自然数解的组数.\n解析\r我们认为0是自然数，所有存在0+0+0+100=100的情况，所以这里的元素 个数应为104个，即3个 0和100个1，这104个元素间有103个空位，中间插入 4个隔板，就会把这104个元素分成4堆，每堆对应 x,y,x,w,而挡板的放置方法有$C_{103}^{3}$\n8.限制条件的分配问题分类法: 例 1. 某高校从某系的 10 名优秀毕业生中选 4 人分别到西部四城市参加中国西部经济开发建设，其中甲同学不到银川，乙不到西宁，共有多少种不同派遣方案？\n解析\r因为甲乙有限制条件，所以按照是否含有甲乙来分类，有以下四种情况： ①若甲乙都不参加，则有派遣方案 $A_8^4$ 种；②若甲参加而乙不参加，先安排甲有 3 种方法，然后安排其余学生有 $A_8^3$方法，所以共有 3$A_8^3$；③若乙参加而甲不参加同理也有 3$A_8^3$种；④若甲乙都参加，则先安排甲乙，有 7 种方法， 然 后 再 安 排 其 余 8 人 到 另 外 两 个 城 市 有 $A_8^2$种 ， 共 有 7$A_8^2$方 法 . 所 以 共 有 不 同 的 派 遣 方 法 总 数 为 $A_8^4$ + 3$A_8^3$ + 3$A_8^3$ + 7$A_8^2$=4088 种.\n9.多元问题分类法： 例 1 （1）由数字 0，1，2，3，4，5 组成没有重复数字的六位数，其中个位数字小于十位数字的共有（ ）\nA、210 种 B、300 种 C、464 种 D、600 种\n（2）从 1，2，3…，100 这 100 个数中，任取两个数，使它们的乘积能被 7 整除，这两个数的取法（不计顺序）共有多少种？\n（3）从 1，2，3，…，100 这 100 个数中任取两个数，使其和能被 4 整除的取法（不计顺序）有多少种？\n解析\r（1）按题意，个位数字只可能是 0，1，2，3，4 共 5 种情况，分别有 $A_5^5$个，$A_4^1$$A_3^1$$A_3^3$ , $A_3^1$$A_3^1$$A_3^3$ , $A_2^1$$A_3^1$$A_3^3$ , $A_3^1$$A_3^3$个，合并总计 300 个,选 B.\n（2）被取的两个数中至少有一个能被 7 整除时，他们的乘积就能被 7 整除，将这 100 个数组成的集合视为全集I,能被 7 整除的数的集合记做 $\\overline{A}$ = { 7，14，21，$\\cdots$，98 } 共有 14 个元素,不能被 7 整除的数组成的集合记做 $\\overline{A}$ = { 1，2，3，4,$\\cdots$，100 } 共有 86 个元素；由此可知，从 A中任取 2 个元素的取法有 $C_{14}^{2}$，从 A中任取一个，又从$\\overline{A}$中任取一个共有 $C_{14}^{1}$$C_{86}^{1}$，两种情形共符合要求的取法有 $C_{14}^{2}$ + $C_{14}^{1}$$C_{86}^{1}$=1295 种.\n（3）将 I = { 1,2,3,$\\cdots$，100 } 分成四个不相交的子集，能被 4 整除的数集 A = { 4,8,12,$\\cdots$，100 }；能被 4 除余 1 的数集B = { 1,5,9,$\\cdots$，97 } ，能被 4 除余 2 的数集 C = { 2,6,$\\cdots$，98 } ，能被 4 除余 3 的数集 D = { 3,7,11,$\\cdots$，99 } ，易见这四个集合中每一个有 25 个元素；从 A中任取两个数符合要；从B,D 中各取一个数也符合要求；从 C中任取两个数也符合要求；此外其它取法都不符合要求；所以符合要求的取法共有 $C_{25}^{2}$ + $C_{25}^{1}$$C_{25}^{1}$ + $C_{25}^{2}$ 种.\n10.交 叉 问 题 集 合 法 ： 例 1. 从 6 名运动员中选出 4 人参加 4×100 米接力赛，如果甲不跑第一棒，乙不跑第四棒，共有多少种不同的参赛方案？\n解析\r设全集= {6 人中任取 4 人参赛的排列} ，A={甲跑第一棒的排列} ，B={乙跑第四棒的排列} ，根据求集合元素个数的公式得参赛方法共有： n(I)-n(A)-n(B)+n(A $\\cap$ B ) = $A_6^4$-$A_5^3$-$A_5^3$+$A_4^2$ = 252\n11.配对问题： 例 1. 5双相异的鞋共10只,现随机地取出6只,恰好能配成2双鞋的取法是多少?\n解析\r$C_{5}^{2} C_{6}^{1} C_{4}^{1}$=240\n12.多排问题单排法: 例 1. 8人排成前后两排，每排4人，其中甲乙在前排，丙在后排，共有多少排法？\n解析\r看成一排，某 2 个元素在前半段四个位置中选排 2 个，有 $A_4^2$种，某 1 个元素排在后半段的四个位置中选一个有 $A_4^1$种，其余 5 个元素任排 5 个位置上有 $A_5^5$种，故共有 $A_4^2$$A_4^1$$A_5^5$=5760 种排法.\n13.“至少”“至多”问题用间接排除法或分类法: 例 1. 从 4 台甲型和 5 台乙型电视机中任取 3 台，其中至少要甲型和乙 型电视机各一台，则不同的取法共有（ ）\nA、140 种 B、80 种 C、70 种 D、35 种\n解析\r至少要甲型和乙 型电视机各一台可分两种情况：甲型 1 台乙型 2 台；甲型 2 台乙型 1 台；故不同的取法有 $C_5^2$$C_4^1$ + $C_5^1$$C_4^2$ =70 台,选 C.\n14.部分合条件问题排除法: 例 1. （1）以正方体的顶点为顶点的四面体共有（ ）\nA、70 种 B、64 种 C、58 种 D、52 种\n（2）四面体的顶点和各棱中点共 10 点，在其中取 4 个不共面的点，不同的取法共有（ ）\nA、150 种 B、147 种 C、144 种 D、141 种\n解析\r（1）正方体 8 个顶点从中每次取四点，理论上可构成 $C_8^4$四面体，但 6 个表面和 6 个对角面的四个顶点共面都不能构成四面体，所以四面体实际共有$C_8^4$-12= 58 个.\n（2）10 个点中任取 4 个点共有 $C_{10}^{4}$种，其中四点共面的有三种情况：①在四面体的四个面上，每面内四点共面的情况为 $C_6^4$，四个面共有 4$C_6^4$个；②过空间四边形各边中点的平行四边形共 3 个；③过棱上三点与对棱中点的三角形共 6 个.所以四点不共面的情况的种数是 $C_{10}^{4}$ - 4$C_6^4$ -3-6=141 种.\n15.可重复的排列求幂法: 例 1. 把 6 名实习生分配到 7 个车间实习共有多少种不同方法？\n解析\r完成此事共分 6 步，第一步；将第一名实习生分配到车间有 7 种不同方案，第二步：将第二名实习生分配到车间也有 7 种不同方案，依次类推，由分步计数原理知共有 $A_{7}^{6}$种不同方案.\n16.上楼梯问题: 例 1. 10级台阶，某人可一步跨一级，也可跨两级，也可跨三级。 （1）他6步就可上完台阶的方法数是多少？ （2）他上完台阶的方法总数是多少？\n解析\r（1）按照 3，3，1，1，1，1 的走法有 $C_{6}^{2}$ 种，按照 3，2，2，1，1，1 的走法有 $C_{6}^{1} C_{5}^{2}$ 种，按照 2，2，2，2，1，1 的走法有 $C_{6}^{4}$ 种，所以恰好6步上完台阶的方法种数是 $C_{6}^{2}$+$C_{6}^{1} C_{5}^{2}$+$C_{6}^{4}$=15+60+15=90 .\n（2）上楼梯问题是典型的斐波那契数列，设爬n级台阶的解法总数为f(n)，因为规定每一步只能跨一级或两级或三级，则f(n)=f(n-1)+f(n-2)+f(n-3)。易知f(1)=1，f(2)=2，f(3)=4,递推可得f(4)=7,f(5)=13,f(6)=24,f(7)=44,f(8)=81,f(9)=149,f10)=274\n17.元素个数较少的排列组合问题可以考虑枚举法: 例 1. 设有编号为 1，2，3，4，5 的五个球和编号为 1，2，3，4，5 的盒子现将这 5 个球投入 5 个盒子要求每个盒子放一个球，并且恰好有两个球的号码与盒子号码相同，问有多少种不同的方法？\n解析\r从 5 个球中取出 2 个与盒子对号有 $C_5^2$种，还剩下 3 个球与 3 个盒子序号不能对应，利用枚举法分析，如果剩下 3，4，5 号球与 3，4，5 号盒子时，3 号球不能装入 3 号盒子，当 3 号球装入 4 号盒子时，4，5 号球只有1 种装法，3 号球装入 5 号盒子时，4，5 号球也只有 1 种装法，所以剩下三球只有 2 种装法，因此总共装法数为2$C_5^2$= 20 种.\n28.复杂的排列组合问题也可用分解与合成法: 例 1.（1）30030 能被多少个不同偶数整除？\n（2）正方体 8 个顶点可连成多少队异面直线？\n解析\r（1）先把 30030 分解成质因数的形式：30030=2×3×5×7×11×13；依题意偶因数 2 必取，3，5，7，11，13这 5 个因数中任取若干个组成成积，所有的偶因数为$C_5^0$+$C_5^1$+$C_5^2$+$C_5^3$+$C_5^4$+$C_5^5$= 32 个.\n（2）因为四面体中仅有 3 对异面直线，可将问题分解成正方体的 8 个顶点可构成多少个不同的四面体，从正方体 8 个顶点中任取四个顶点构成的四面体有$C_8^4$-12= 58 个，所以 8 个顶点可连成的异面直线有 3×58=174 对.\n19.利用对应思想转化法: 例 1. （1）圆周上有 10 点，以这些点为端点的弦相交于圆内的交点有多少个？\n（2）某城市的街区有 12 个全等的矩形组成，其中实线表示马路，从 A到 B的最短路径有多少种？\n解析\r（1）因为圆的一个内接四边形的两条对角线相交于圆内一点，一个圆的内接四边形就对应着两条弦相交于圆内的一个交点，于是问题就转化为圆周上的 10 个点可以确定多少个不同的四边形，显然有 $C_{10}^{4}$个，所以圆周上有10 点，以这些点为端点的弦相交于圆内的交点有 $C_{10}^{4}$个.\n（2）可将图中矩形的一边叫一小段，从 A到 B最短路线必须走 7 小段，其中：向东 4 段，向北 3 段；而且前一段的尾接后一段的首，所以只要确定向东走过 4 段的走法，便能确定路径，因此不同走法有 $C_{7}^{4}$种.\n20.全错位排列问题公式法: 例 1. 分别编有 1，2，3，4，5 号码的人与椅，其中i 号人不坐i 号椅（i = 1,2,3,4,5）的不同坐法有多少种？\n解析\r全错位排列是组合数学中的经典问题之一，使用公式不容易出错： $$ D(n)=(n-1) \\cdot[D(n-1)+D(n-2)] . $$ 又易知, $D(1)=0, D(2)=1$. 由递推公式可得: $D(3)=2, D(4)=9，D(5)=44$\n21.环排问题 例 1. 8 人围桌而坐,共有多少种坐法?\n解析\r$\\mathrm{n}$ 个不同元素作圆形排列,共有 $(\\mathrm{n}-1)$!种排法.即7! 如果从 $\\mathrm{n}$ 个不同元素中取出 $\\mathrm{m}$ 个元素作圆形排列共有 $\\frac{1}{n} A_n^m$ 。\n22.正难则反策略 例 1. 从 0,1,2,3,4,5,6,7,8,9 这十个数字中取出三个数，使其和为不小于 10 的 偶数,不同的取法有多少种？\n解析\r这问题中如果直接求不小于 10 的偶数很困难, 可用总体淘汰法。这十个数字 中有 5 个偶数 5 个奇数, 所取的三个数含有 3 个偶数的取法有 $C_5^3$, 只含有 1 个偶数 的取法有 $C_5^1 C_5^2$, 和为偶数的取法共有 $C_5^1 C_5^2+C_5^3$ 。再淘汰和小于 10 的偶数共 9 种, 符合条件的取法共有 $C_5^1 C_5^2+C_5^3-9$\n23.平均分组问题 例 1. 6 本不同的书平均分成 3 堆,每堆 2 本共有多少分法？\n解析\r分三步取书得 $C_6^2 C_4^2 C_2^2$ 种方法, 但这里出现重复计数的现象, 不妨记 6 本书为 $A B C D E F$, 若第一步取 $A B$, 第二步取 $C D$, 第三步取 $E F$ 该分法记为 (AB, $C D, E F)$, 则 $C_6^2 C_4^2 C_2^2$ 中还有 (AB, $\\left.\\mathrm{EF}, \\mathrm{CD}\\right)$, (CD, AB, $\\mathrm{EF}$ ), (CD, EF, AB) (EF, CD, AB), (EF, AB, CD) 共有 $A_3^3$ 种取法, 而这些分法仅是 ( $\\left.\\mathrm{AB}, \\mathrm{CD}, \\mathrm{EF}\\right)$ 一种分法, 故共有 $C_6^2 C_4^2 C_2^2 / A_3^3$ 种分法。\n24.分类与分步策略 例 1. 有红、黄、兰色的球各 5 只,分别标有 A、B、C、D、E 五个字母,现从中取 5 只,要求各字母均有且三色齐备,则共有多少种不同的取法\n解析\r按颜色分有1 1 3和1 2 2 两种，各3种方案。2.分字母，1 1 3对应有$C_5^1$$C_4^1$$C_3^3$共20种，1 2 2对应$C_5^1$$C_4^2$$C_2^2$共30种，320+330=150\n例 2. 在一次演唱会上共 10 名演员,其中 8 人能能唱歌,5 人会跳舞,现要演出一个 2 人唱歌 2 人伴舞的节目,有多少选派方法？\n解析\r10 演员中有 5 人只会唱歌, 2 人只会跳舞 3 人为全能演员。选上唱歌人员为 标准进行研究只会唱的 5 人中没有人选上唱歌人员共有 $C_3^2 C_3^2$ 种, 只会唱的 5 人中只 有 1 人选上唱歌人员 $C_5^1 C_3^1 C_4^2$ 种, 只会唱的 5 人中只有 2 人选上唱歌人员有 $C_5^2 C_5^2$ 种, 由分类计数原理共有 $C_3^2 C_3^2+C_5^1 C_3^1 C_4^2+C_5^2 C_5^2$ 种。\n","date":"2022-12-10T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/math/","title":"数学"},{"content":"Let’s Encrypt 是一个免费的，自动化的，开放的证书颁发机构（CA），为公众的利益而运行。 它是一项由 Internet Security Research Group（ISRG）提供的服务。\nacme.sh 则是实现了 acme 协议, 可以从 letsencrypt 生成免费的证书。\nLet’s Encrypt 速率限制 每个注册网域(Registered Domain) 的凭证颁发数量，限制为每周50 张 更新凭证受到重复凭证限制，一个星期内仅能颁发5 张重复的凭证。 网域验证失败限制，对于每个帐号每域名每小时5 次的限制。 每个IP 位置每3 个小时最多能建立10 个帐号。 如果你达到速率限制，你只能等待一个星期直到速率限制结束。\nacme申请证书 安装 acme.sh curl https://get.acme.sh | sh sudo apt install socat # 安装socat 选择默认 CA Zerossl 从 acme.sh v 3.0.0 开始，acme.sh 使用 Zerossl 作为默认 ca，您必须先注册帐户（一次），然后才能颁发新证书。\n~/.acme.sh/acme.sh –register-account -m xxxx@xxxx.com Let\u0026rsquo;s Encrypt 如果需要更换Let\u0026rsquo;s Encrypt可以使用如下命令：\n~/.acme.sh/acme.sh --set-default-ca --server letsencrypt 通过 http 方式申请证书 Webroot模式 这种方式需要你的服务器上面已经部署了网站环境。Acme 自动在你的网站根目录下放置一个文件,来验证你的域名所有权,完成验证. 然后就可以生成证书了.\n# 生成 RSA 证书： ~/.acme.sh/acme.sh --issue -d example.com -w /var/www/_letsencrypt/ # 生成 ECC 证书： ~/.acme.sh/acme.sh --issue -d example.com -w /var/www/_letsencrypt/ --keylength ec-256 /var/www/_letsencrypt/ 为 example.com 站点下的 /.well-known/acme-challenge/ 证书请求目录。\n80 端口空闲的证书申请方式 ~/.acme.sh/acme.sh --issue -d example.com --standalone 安装证书到指定文件夹 # 把密钥和证书安装到 /root 目录，并改名为 private.key 和 cert.crt。 ~/.acme.sh/acme.sh --installcert -d mydomain.com --key-file /root/cert/private.key --fullchain-file /root/cert/cert.crtchmod -R 755 /root/cert 更新（后续操作） 更新证书 手动更新 ~/.acme.sh/acme.sh --renew -d example.com --force 自动更新 安装 acme.sh 时会自动创建一个 cronjob，每天定期检查所有证书，如果证书需要更新会自动更新证书。 通过 crontab -l 查看 crontab 任务:\n46 0 * * * \u0026#34;/root/.acme.sh\u0026#34;/acme.sh --cron --home \u0026#34;/root/.acme.sh\u0026#34; \u0026gt; /dev/null 更新 Acme 脚本 升级 Acme.sh 到最新版本\n~/.acme.sh/acme.sh --upgrade 如果你不想手动升级, 可以开启自动升级:\n~/.acme.sh/acme.sh --upgrade --auto-upgrade DNS 申请证书(通常只支持付费域名) 几个 CA 的简单对比\n功能 LE Buypass ZeroSSL SSL.com Google Public CA 有效期 90 天 180 天 90 天 90 天 90 天 多域名 支持 支持，最多 5 个 支持 收费支持 支持 泛域名 支持 不支持 支持 收费支持 支持 Rate Limit 有 有 收费无 未知 有 GUI 管理 否 否 有 有 无 ECC 证书链 否 否 有 未知 无 客户支持 社区 收费 收费 收费 收费 cloudflare 使用全局 API 密钥，您需要登录您的 Cloudflare 帐户以获取您的API 密钥\nexport CF_Key=\u0026#34;sdfsdfsdfljlbjkljlkjsdfoiwje\u0026#34; export CF_Email=\u0026#34;xxxx@sss.com\u0026#34; 颁发证书：\n./acme.sh --issue --dns dns_cf -d example.com -d www.example.com 阿里云 DNS 申请方式 export Ali_Key=\u0026#34;abcd\u0026#34; export Ali_Secret=\u0026#34;xxxxxxxxxx\u0026#34; # RSA 证书 acme.sh --issue --dns dns_ali -d example.com -d *.example.com # ECC 证书 acme.sh --issue --dns dns_ali -d example.com -d *.example.com --keylength ec-256 Ali_Key 和 Ali_Secret 需要从阿里云RAM访问控制中获取。\nDNSPod 申请方式 export DP_Id=\u0026#34;1234\u0026#34; export DP_Key=\u0026#34;xxxxxxxxxxx\u0026#34; acme.sh --issue --dns dns_dp -d example.com -d www.example.com 文档 如何颁发证书\n使用 DNS API\n选项和参数\n","date":"2022-10-24T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/acme/","title":"acme.sh 申请证书"},{"content":"前言 云是我们常用的服务，aws是头部厂商，但我们还有更多选择，以降低价格。即使aws有高昂且复杂的定价，仍有很多人使用，所以本文也将介绍。\n目前我在使用的云存储是Backblaze B2（兼容S3 API），价格仅为 Amazon S3、Microsoft Azure 和 Google Cloud 的1/4。\n我们同样需要一个CDN缓存加速（cloudflare 与传统 CDN 不同，CloudFlare 处理对网站的所有请求，能够阻止针对网站的攻击，可以再加到传统CDN前作为防护），CDN在用户第一次请求后，会在接近用户的区域缓存源服务器的静态资源（没人请求不缓存，不主动和服务器保持同步），后续访问就更加快速，并降低服务器压力，可以使用cloudfront免费套餐，如果每月传出超过 1T 数据，可以考虑使用 bunny CDN。\nS3 Bucket桶 桶就类似于根文件夹，其命名必须全局性唯一。也就是说，如果别人已经创建了命为X的Bucket，你就不能再用X作为桶的名字了。\nEvents事件 在S3中，可以定义很多事件及其处理函数。比如当文件被创建，修改，删除，复制时，触发Lambda。这样就可以构建Event Driven Architecture，比如：新文件到S3 -\u0026gt; 触发Lambda处理函数 -\u0026gt; 处理结束后通知AppSync/GraphQL API -\u0026gt; 通知用户文件已经处理完毕。\nS3费用决定因素 官方：存储和管理数据时需要考虑六大 Amazon S3 成本组成：存储定价、请求和数据检索定价、数据传输和传输加速定价、数据管理和分析定价、复制定价以及使用 S3 Object Lambda 处理数据的价格。\n通常我们关注存储类型、储存数据量、请求量、数据传输的费用。\n存储类型 S3 标准 S3 标准是一种通用对象存储平台，提供较低的延迟和较高的吞吐量，因此非常适合各种使用案例，包括云应用程序、动态网站、内容分发、移动和游戏应用程序以及大数据分析。\nS3 智能分层 ——通用选它 S3 智能分层可自动识别并将不常访问的数据（30天内未访问的数据）移动到成本较低的基础架构中。当访问不频繁层中的对象时，它会自动移回更高性能层，并且30天时钟重新启动。在访问模式发生变化时，在两个访问层（频繁访问层和不频繁访问层）之间移动数据来实现自动节省成本，非常适用于访问模式未知或不断变化的数据。\nS3标准-IA（不频繁访问）——备份选它 S3 Standard-IA 适用于不常访问（超过30天访问一次）、但在需要时要求快速访问的数据。提供与“S3 标准”相同的高持久性、高吞吐量和低延迟，成本较低且性能出色使得“S3标准–IA”很适合长期存储和备份，以及用作灾难恢复文件的数据存储。\nS3 单区域 - IA（不频繁访问） S3标准-IA 的单区域存储，此类别不会自动在至少三个AZ上存储数据。\nS3 Glacier 即时检索 Amazon S3 Glacier Instant Retrieval 是一种归档存储类，可以为很少访问（超过90天访问一次）且需要毫秒级检索速度的长期数据提供最低成本的存储。\nS3 Glacier 灵活检索（前称为 S3 Glacier） S3 Glacier Flexible Retrieval 为每年访问 1—2 次且异步检索的归档数据提供低成本存储，数据检索时间可配置，从数分钟到数小时不等。\nAmazon S3 Glacier 深度档案 支持长期保留和数字化保存一年可能访问一到两次的数据，数据检索时间为 12 小时以内。\ncloudfront Origin domain ：源域，选S3 存储桶需配置Alternate Domain Names作为加速站点，写自己解析过的域名即为加速的站点\nAmazon S3 存储桶– DOC-EXAMPLE-BUCKET.s3.us-west-2.amazonaws.com\n配置为网站的 Amazon S3 存储桶– https://DOC-EXAMPLE-BUCKET.s3-website.us-west-2.amazonaws.com\nMediaStore 容器– examplemediastore.data.mediastore.us-west-1.amazonaws.com\nMediaPackage 端点– examplemediapackage.mediapackage.us-west-1.amazonaws.com\n亚马逊 EC2 实例– ec2-203-0-113-25.compute-1.amazonaws.com\nElastic Load Balancing 负载均衡器– example-load-balancer-1234567890.us-west-2.elb.amazonaws.com\n您自己的网络服务器– https://www.example.com\n自选ip失败经历 查看官方公布的ip段（我们只需要边缘节点ip-\u0026ldquo;CLOUDFRONT_REGIONAL_EDGE_IP_LIST\u0026rdquo;，因为GLOBAL站点会自动判断离边缘节点最近的区域和进行健康检查，再连到边缘节点） 由于给的ip是CIDR格式，我们需要转换。先JSON转列表。然后CIDR转ip（因为在线转不支持批量转换，所以建议下载这个工具），重命名为cidr2ip.exe，新建cidrs.txt，把列表复制进去，cmd执行cidr2ip -f cidrs.txt可得很大一列ip。最后ip批量查询，下载后可以看到ip地区，复制你所需地区的ip（查询速度会很慢，我的vps是日本的，排在最前面，运气很好没有查询很久）。\n创建Cloud front测速链接\naws首页搜索cloud front 创建分配\n源域填写能测速的地址：cachefly.cachefly.net 协议：匹配查看器\n自动压缩对象：No 缓存键和源请求（选择第二项）：Legacy cache settings 创建\n复制得到的域名 打开显示为测速地址即可（需要等到部署完成）\n使用CloudflareSpeedTest](https://github.com/XIU2/CloudflareSpeedTest)优选ip， cmd输入CloudflareST.exe -url xxxxxxxxxxx.cloudfront.net/100mb.test发现ip全部不能用。 aws查看vcpu ","date":"2022-10-07T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/cloud-service/","title":"云服务"},{"content":"postman中文文档\nAPI API的英文即 Application Programming Interface 首字母的缩写，直译过来的意思就是：程序之间的接口。我更倾向于把API理解为，程序之间的合约。有关 API 是什么及它的意义这里就不展开讲了。\nchrome浏览器开发者工具\n勾选上谷歌开发者工具的preserve log，保留上一个页面接口调用信息，从而方便我们查看\nPostman 界面导航说明 请求：\nparams：get请求传参。\nAuthrization：鉴权\nHeaders：请求头\naccept:客户端接收的数据类型。\ncontent-type:客户端发送给服务器的数据类型\nuser-agent:客户端的类型\nxmlhttprequest:异步请求\nBody：Post请求传参\nnone：没有参数\nform-data：文件上传（包含键值对和文件上传）\nx-www-from-urlencodeed：表单请求（键值对）\nraw：使用原始数据格式请求（JSON，XML，HTML，Text，Javascript）\nbinary：二进制文件上传。\nPre-request-script：请求之前的脚本。\nTests；请求之后的脚本。\nSetting：设置\nCookies：用于自动管理Cookie的功能\n响应：\nBody：返回的信息\nPretty（各种格式查看返回数据）\nRaw（文本格式）\nPreview（网页）\nCookie：响应Cookie\ntoken鉴权码：\ncsrf_token：一般情况下有效期是7-15天。\naccess_token：一般情况下有效期是10分钟-2小时\nHeaders：响应头\nTestResults：测试结果\n200 响应码\nGET 请求 GET 请求基本操作 （1）点击主界面「+」号，新建一个请求页\n（2）选择 GET 请求命令\n（3）输入 API 地址\n在 GoRest API 设计中 GET 请求无需鉴权，所有我们直接点击「Send」即可远程调取服务器信息。\n如果我们只想看调取其中一位用户的信息应该怎么办呢？我们可以在 API URL 中带上参数。\n带参数的 GET 请求 如果我们想查询 ID 为 2043 的用户信息，我们只需要在请求页面中的 Params(参数) 标签页的 KEY - VALUE 内填写对应的参数即可，之后 Postman 会自动在 API URL 中生成你填写的参数，使 URL 带上参数 GET 请求。\nhttps://gorest.co.in/public/v1/users?id=2043 设置完成后，点击「Send」\n我们可以看到，返回值中仅包含我们请求的 user id 为 2043 的用户信息。\nGET 请求中的多条件查询 有时，我们需要使用 API 进行多条件查询操作，比如想找 name 值为 kalacloud.com ，同时 gender 值为 male 的用户。（特别提示：此格式是通用写法，但最终要看 API 的开发者如何约定调用方式）\nBaseURL + ResourceName + ? + key1 = value1 + \u0026amp; + key 2 = value 2 …… 主 URL 之后使用 ? 连接参数，参数与参数之间使用 \u0026amp; 连接符连接。\nhttps://gorest.co.in/public-api/users/?name=kalacloud.com\u0026amp;gender=male 当然，我们可以直接在 Postman 的 Params 中直接填写 KEY - VALUE\n让 Postman 帮我们生成，然后点击「Send」\n可以看到 API GET 调取了我们设定的两个 VALUE 值的 data 信息。\n特别提示，你可以点击右上角的「Bulk Edit」进行参数的批量编辑\nPOST 请求 POST 方式一：模仿浏览器\n在发送一个get请求之后，postman会自动保存cookis，我们只需复制 Payload 的数据格式到 body ，复制 x-csrf-token 到 Headers ，发送这个 POST 请求\n自动方式可以参考\nPOST 方式二：鉴权 在 Authorization 中添加鉴权方式和密钥，postman会自动添加到Headers，按照api写入所需body，发送这个 POST 请求\n用 Postman 发送第一个 PUT 更新请求 PUT 请求一般用于更新服务器已有资源，如果服务器中没有对应的资源，那么 PUT 会创建相应的资源（特别提醒：虽然 PUT 有创建新资源的功能，但是否能创建成功，最终取决于你调用的 API 是否支持此功能）\n打开你的 Postman 我们来创建一个 PUT 请求。\n点击「+」号，新建一个请求页\n请求类型选择「PUT」\n根据第6节我们使用 POST 请求创建的资源 ID 为 1475 ，又根据 GoRest API 的文档得知，修改资源的 API 地址为\nhttps://gorest.co.in/public/v1/users/{{ID}} ，所以我们要使用 PUT 修改 ID 为 1475 资源的请求地址应该写：\nhttps://gorest.co.in/public/v1/users/1475 选择在 Body 标签中填写 JSON 格式的资源修改信息。我们将 1475 中的邮箱由\nJiangChuan@kalacloud.com 修改为 Hi@kalacloud.com，所以我们在 Body 中填写以下代码。\n{ \u0026#34;name\u0026#34;: \u0026#34;kalacloud\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;Male\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;Hi@kalacloud.com\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;Active\u0026#34; } 选择 Auth 标签，进行 API 鉴权，鉴权方法详见本文第6节《使用 Postman 对 API 鉴权》 点击 「Send」发送 PUT 请求 如上图所示，可以看到红4位置 响应代码返回 200 ，这说明 PUT 请求已经执行成功。 返回的 Body 信息中，email 字段已经更新为 Hi@kalacloud.com ","date":"2022-08-04T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/test/","title":"测试接口"},{"content":"购买配件 配件 用途 mq2 pro 续航版 提升头戴舒适度，可以按照自己需要选择没有续航的 磁吸镜片 近视适用 USB3.0串流线 玩steam的游戏需要和电脑串流 网络 国内quest2用户应该已经具备上外网的条件，不再赘述。\nquest2需要无线网络链接，解决网络问题一般有以下方式：\n软路由openwrt 刷路由器，这个方式比较直接，我认为日常不适用的场景较多，所以没有用。 电脑开个VMware虚拟机安装OpenWrt,有点麻烦。参考文章 电脑热点 sstap方法(推荐) 打开科学上网，注意用全局模式并且允许局域网连接。\n下载sstap，我使用的1.0.9.9版本。\n配置并打开sstap 打开热点，并打开 网络和Internet设置 -\u0026gt; 更改适配器选项 -\u0026gt; 右键 SSTAP 1 -\u0026gt; 属性 -\u0026gt; 共享 ，然后就可以连热点了。 TUN模式方法 如果你的电脑同时有网线和无线网卡，clash和v2rayN的TUN模式开热点应该也可以。\n注册，接受邀请领取30美金奖励 只玩破解版无需受邀，无需此步骤！\n使用outlook、gmail等邮箱和原生ip至少提前1天注册facebook账号。\n接受邀请比较麻烦，有需要直接去找别人代操作受邀！\n以下方式成本过高，仅作为邀请别人的参考！\n我试了多地vps，原生ip也全都出现Ineligible Country​，原因是服务器厂商用的数据中心ip（type为hosting），会被识别屏蔽。所以要用住宅代理（type为isp），由于成本高，服务器厂商几乎不用，只有代理厂商的住宅代理和部分静态住宅代理才可以接受邀请。我搜索了多家代理厂商，价格便宜的只有 911s5 和 iproyal\n代理厂商 特点 价格 911s5 自有软件，pc端指定软件代理，使用简单，ip质量差，部分可以邀请使用 最低28美元/150ip，每ip可用24小时 iproyal 直接给地址端口和用户，所以在国内必须自己搭建国外节点并且中转才能使用，但是ip质量较好、使用舒适。必须实名，不实名很多网站不能访问（包括facebook），而且实名较为耗时 3美元/GB ，paypal入金最低20美元 “以xui为例的中转配置文件”\r// 直接修改\u0026#34;servers\u0026#34;即可使用 { \u0026#34;api\u0026#34;: { \u0026#34;services\u0026#34;: [ \u0026#34;HandlerService\u0026#34;, \u0026#34;LoggerService\u0026#34;, \u0026#34;StatsService\u0026#34; ], \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 62789, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;Socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;proxy.iproyal.com\u0026#34;, \u0026#34;port\u0026#34;: 12325, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34; }, { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: {} }, { \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;blocked\u0026#34; } ], \u0026#34;policy\u0026#34;: { \u0026#34;system\u0026#34;: { \u0026#34;statsInboundDownlink\u0026#34;: true, \u0026#34;statsInboundUplink\u0026#34;: true } }, \u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;inbound-12325\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;ip2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, \u0026#34;protocol\u0026#34;: [ \u0026#34;bittorrent\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;stats\u0026#34;: {} } “配置文件详解”\r// 配置文件详解 { \u0026#34;api\u0026#34;: { // api: 提供了一些 API 接口供远程调用 \u0026#34;services\u0026#34;: [ // services: [string] 开启的 API 列表 \u0026#34;HandlerService\u0026#34;, // HandlerService:添加、删除一个入站、出站代理在一个入站代理中添加、删除一个用户 \u0026#34;LoggerService\u0026#34;, // 内置Logger \u0026#34;StatsService\u0026#34; // 内置的数据统计服务 ], \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; // tag: string api中的tag是**出站**代理标识 }, \u0026#34;inbounds\u0026#34;: [ // 入站 -\u0026gt; 路由 不用修改 { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 62789, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, // 任意门,可以监听一个本地端口 \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ], \u0026#34;outbounds\u0026#34;: [ // 出站 ##################此处开始添加################## { // 添加出站节点 \u0026#34;protocol\u0026#34;: \u0026#34;Socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 12325, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34; }, #################此处结束添加################### { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, // 向任意网络发送（正常的）TCP 或 UDP 数据 \u0026#34;settings\u0026#34;: {} }, { \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, // 禁止访问 \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;blocked\u0026#34; } ], \u0026#34;policy\u0026#34;: { \u0026#34;system\u0026#34;: { \u0026#34;statsInboundDownlink\u0026#34;: true, \u0026#34;statsInboundUplink\u0026#34;: true } }, \u0026#34;routing\u0026#34;: { // 路由 -\u0026gt; 出站 \u0026#34;rules\u0026#34;: [ ##################此处开始添加################## { // 添加路由，xui的\u0026#34;inboundTag\u0026#34;规则是\u0026#34;inbound-port\u0026#34; \u0026#34;inboundTag\u0026#34;: [ \u0026#34;inbound-12325\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;ip2\u0026#34;, // -\u0026gt; \u0026#34;outbounds\u0026#34;: {\u0026#34;tag\u0026#34;: \u0026#34;ip2\u0026#34;} \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, #################此处结束添加################### { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, // -\u0026gt; \u0026#34;api\u0026#34;: {\u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34;} \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, // -\u0026gt; 禁止访问 \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; }, { \u0026#34;outboundTag\u0026#34;: \u0026#34;blocked\u0026#34;, // -\u0026gt; 禁止访问 \u0026#34;protocol\u0026#34;: [ \u0026#34;bittorrent\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;stats\u0026#34;: {} } 激活 下载Oculus App，quest2联网后配对，配对成功就说明Quest2激活成功了。\n安装第三方应用 便携方式 87vr助手安装热门游戏和应用，安卓apk可以通过QQ发送直接安装。 更多破解应用可以看看极客VR（1元注册）、VR魔趣网。\n常规方式 首先需要开启开发者模式。在Oculus开发者网站创建一个开发者组织，再去Oculus APP菜单 -\u0026gt; 设备 -\u0026gt; 开发者模式 -\u0026gt; 打开 。 下载SideQuest并安装。 下载Oculus ADB驱动。右键单击android_winusb.inf选择“安装”。然后用USB线将头显和电脑连接起来，在头显中点击“允许”。 然后就可以安装apk了。 如果apk附带文件夹，就拖入obb文件夹。 进入头显的未知来源就可以使用了。 SKYBOX 《SkyBox VR》是最优秀的vr视频播放器，而且可以使用电脑的本地网络播放电脑上的影片。\nvr影片体积超过10G的很常见，quest2装不了多少，所以放在pc，局域网共享。\n电脑设置开启共享。 无密码的共享 有密码的共享（选择有密码保护的共享），找到用户名和改密码\n共享存放影片的文件夹 右键文件夹 -\u0026gt; 属性 -\u0026gt; 共享 -\u0026gt; 选择用户或新建用户everyone\n删除共享：右键文件夹 -\u0026gt; 授予访问权限 -\u0026gt; 删除访问\n去quest2 SKYBOX 本地网络查看。 常见问题 恢复出厂设置 手机配对后在app菜单 -\u0026gt; 设备 -\u0026gt; 高级设置 -\u0026gt; 恢复出场设置\n登陆Oculus官网 -\u0026gt; 点头像 -\u0026gt; Oculus settings -\u0026gt; Devices DELETE -\u0026gt; DEVICE DATA\n截图 按住右手柄Oculus Home键（椭圆键） + 扳机按键（食指键）\n","date":"2022-05-14T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/quest2/","title":"quest2入门使用"},{"content":"安装 java版本控制（jvms） 我们可能需要多个java版本，主要是为了兼容Gradle版本。\n下载，解压到想要的路径 管理员身份打开cmd，cd到在jvms.exe所在的目录下，执行jvms init jvms.exe rls可列出java版本，如果失败，打开https://site.ip138.com/raw.Githubusercontent.com/查看ip，在C:\\Windows\\System32\\drivers\\etc\\hosts末尾添加一行[ip] raw.githubusercontent.com 安装jvms install [version] jvms.exe ls列出已安装JDK版本 jvms.exe switch [version]切换版本 java -version jvms.exe remove [version]删除某个版本 更多命令\n// 创建新项目 fvm flutter create // 更新项目依赖 fvm flutter pub get // 清除缓存 fvm flutter clean Android Studio 安装配置Android Studio\n下载地址\nAndroid SDK Tools:\npath:C:\\Users\\[username]\\AppData\\Local\\Android\\Sdk\\tools Android SDK Platform-Tools:\npath:C:\\Users\\[username]\\AppData\\Local\\Android\\Sdk\\platform-tools Android SDK\nTools -\u0026gt; SDK Manager -\u0026gt; 编辑Android SDK Location（默认即可）\nSDK Platforms：推荐Android 7.0及以上 SDK Tools 下载安装 -\u0026gt; Intel x86 Emulator Accelerator (HAXM installer)-Deprecated（模拟器支持） Android SDK Command-line Tools flutter版本控制（fvm） 安装 fvm，命令行运行以下命令： choco install fvm 查看当前有哪些版本可用 fvm releases 安装指定版本 // 有可能缺失文件，建议手动下载 fvm install [version] 列出所有已安装的 Flutter SDK 版本。 fvm list VS Code配置 在项目中创建一个.vscode文件夹，然后创建一个名为settings.json的文件并添加：\n{ \u0026#34;dart.flutterSdkPath\u0026#34;: \u0026#34;.fvm/flutter_sdk\u0026#34;, // Remove .fvm files from search \u0026#34;search.exclude\u0026#34;: { \u0026#34;**/.fvm\u0026#34;: true }, // Remove from file watching \u0026#34;files.watcherExclude\u0026#34;: { \u0026#34;**/.fvm\u0026#34;: true } } 切换版本 全局切换：fvm global [version] 项目中切换（每次都要）：项目目录下，终端运行fvm use [version]，重启vscode 运行上述命令后，项目中创建了一个名为.fvm 的文件夹，文件夹中有 flutter SDK，如果不希望提交此文件夹，在.gitignore文件中添加.fvm/flutter_sdk\n删除某个版本 fvm remove [version] 直接安装 安装 JDK 下载地址\n安装flutter(windows) flutter安装\nset PUB_HOSTED_URL=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/dart-pub\u0026#34; #配置国内镜像 set FLUTTER_STORAGE_BASE_URL=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/flutter\u0026#34; 配置环境变量 Dart: 无需配置，flutter现在自带dart。\nFlutter:\npath:C:\\flutter\\bin Java:\nJAVA_HOME:C:\\Program Files\\Java\\jdk-1.8\npath:%JAVA_HOME%\\bin\npath:%JAVA_HOME%\\jre\\bin (如果是jdk-17则不需要配置jre)\n删除自动配置的环境变量path：\nC:\\Program Files\\Common Files\\Oracle\\Java\\javapath C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath 不推荐设置系统环境变量classpath，始终建议通过-cp命令传入，JVM默认的classpath为.，即当前目录。\n创建 Flutter 项目 构建 构建项目工具是必学内容，也是项目容易报错的部分，所以放在前面。\nGradle是Android官方工具，比Maven更灵活高效，它具有高度可定制性，以适应不同的项目。\nGradle 注意不同版本的Gradle存在差异\n一般情况下Android项目使用Android Gradle Plugin(AGP)的版本，新项目请检查AGP对应gradle版本 flutter SDK有它自己对应的gradle版本 clone的java项目下载相应gradle到项目目录，在Settings -\u0026gt; Build Tools -\u0026gt; Distribution:Local installation使用。 更新AGP：Tools -\u0026gt; AGP upgrade assistant\n更改项目/模块gradle版本：File -\u0026gt; Project Structure -\u0026gt; Project/Modules\n参考：文档、示例：https://docs.gradle.org/[version]/samples/index.html#java\n基础 项目 build.gradle：配置项目整体属性，比如指定的代码仓库、依赖 buildscript { repositories { // gradle脚本执行需要的依赖 google() // 引用google上的开源项目 jcenter() // 引用 jcenter上的开源项目 } dependencies { // 依赖的jar包 classpath \u0026#39;com.android.tools.build:gradle:3.0.0\u0026#39; } } allprojects { // 项目本身需要的依赖 repositories { google() jcenter() } } task clean(type: Delete) { // 执行task任务：删除根目录中的build目录 delete rootProject.buildDir } 模块 build.gradle：配置当前Module的编译参数 // 使用插件 apply plugin: \u0026#39;com.android.application\u0026#39; android { compileSdk 34 // 设置编译时用的Android版本 defaultConfig { applicationId \u0026#34;com.example.myapplication\u0026#34; // 项目的包名（子模块不能指定） minSdkVersion 15 // 最低兼容的版本 targetSdk 34 // 目标版本 versionCode 1 // 版本号 versionName \u0026#34;1.0\u0026#34; // 版本名称 // 使用AndroidJUnitRunner进行单元测试 testInstrumentationRunner \u0026#34;android.support.test.runner.AndroidJUnitRunner\u0026#34; } buildTypes { release { // 生产环境 buildConfigField(\u0026#34;boolean\u0026#34;, \u0026#34;LOG_DEBUG\u0026#34;, \u0026#34;false\u0026#34;) // 配置Log日志 buildConfigField(\u0026#34;String\u0026#34;, \u0026#34;URL_PERFIX\u0026#34;, \u0026#34;\u0026#34;https://release.cn/\u0026#34;\u0026#34;) // 配置URL前缀 minifyEnabled false // 是否对代码进行混淆 //指定混淆的规则文件 proguardFiles getDefaultProguardFile(\u0026#39;proguard-android.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; signingConfig signingConfigs.release // 设置签名信息 pseudoLocalesEnabled false // 是否在APK中生成伪语言环境，帮助国际化 zipAlignEnabled true // 是否对APK包进行ZIP对齐优化 applicationIdSuffix \u0026#39;test\u0026#39; // 在applicationId 中添加了一个后缀，一般使用的不多 versionNameSuffix \u0026#39;test\u0026#39; // 在applicationId 中添加了一个后缀，一般使用的不多 } debug { // 测试环境 buildConfigField(\u0026#34;boolean\u0026#34;, \u0026#34;LOG_DEBUG\u0026#34;, \u0026#34;true\u0026#34;) // 配置Log日志 buildConfigField(\u0026#34;String\u0026#34;, \u0026#34;URL_PERFIX\u0026#34;, \u0026#34;\u0026#34;https://test.com/\u0026#34;\u0026#34;) // 配置URL前缀 minifyEnabled false //是否对代码进行混淆 //指定混淆的规则文件 proguardFiles getDefaultProguardFile(\u0026#39;proguard-android.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; signingConfig signingConfigs.debug // 设置签名信息 debuggable false // 是否支持断点调试 jniDebuggable false // 是否可以调试NDK代码 renderscriptDebuggable false // 是否开启渲染脚本 zipAlignEnabled true // 是否对APK包执行ZIP对齐优化 pseudoLocalesEnabled false // 是否在APK中生成伪语言环境，帮助国际化 applicationIdSuffix \u0026#39;test\u0026#39; // 在applicationId 中添加了一个后缀，一般使用的不多 versionNameSuffix \u0026#39;test\u0026#39; // 在applicationId 中添加了一个后缀，一般使用的不多 } } } dependencies { //项目的依赖关系 👉// 本地jar包依赖：新建 Project\\app\\libs 文件夹，粘贴 jar implementation fileTree(include: [\u0026#39;*.jar\u0026#39;], dir: \u0026#39;libs\u0026#39;) testImplementation \u0026#39;junit:junit:4.12\u0026#39; // 声明测试用例库 implementation \u0026#39;com.android.support:appcompat-v7:26.1.0\u0026#39; // 远程依赖 implementation project(\u0026#39;:library\u0026#39;) // 项目本地的Library模块 } 其他配置\randroid { signingConfigs { // 自动化打包配置 release { // 线上环境 keyAlias \u0026#39;test\u0026#39; keyPassword \u0026#39;123456\u0026#39; storeFile file(\u0026#39;test.keystore\u0026#39;) storePassword \u0026#39;123456\u0026#39; } debug { // 开发环境 keyAlias \u0026#39;test\u0026#39; keyPassword \u0026#39;123456\u0026#39; storeFile file(\u0026#39;test.keystore\u0026#39;) storePassword \u0026#39;123456\u0026#39; } } sourceSets { // 目录指向配置 main { jniLibs.srcDirs = [\u0026#39;libs\u0026#39;] // 指定lib库目录 } } packagingOptions{ // 当有重复文件时 ,使用第一个匹配的文件打包进apk pickFirsts = [\u0026#39;META-INF/LICENSE\u0026#39;] // 当出现重复文件时 合并重复的文件打包进apk merge \u0026#39;META-INF/LICENSE\u0026#39; // 同时使用butterknife、dagger2框架处理 （常用） exclude \u0026#39;META-INF/services/javax.annotation.processing.Processor\u0026#39; } productFlavors { wandoujia { // 豌豆荚渠道包配置 manifestPlaceholders = [UMENG_CHANNEL_VALUE: \u0026#34;wandoujia\u0026#34;] } xiaomi { manifestPlaceholders = [UMENG_CHANNEL_VALUE: \u0026#34;xiaomi\u0026#34;] applicationId \u0026#34;com.wiky.gradle.xiaomi\u0026#34; // 配置包名 } _360 { manifestPlaceholders = [UMENG_CHANNEL_VALUE: \u0026#34;_360\u0026#34;] } //... } lintOptions { // 关闭检查lint（有错误会停止build） abortOnError false // 即使报错也不会停止打包 checkReleaseBuilds false // 打包release版本的时候进行检测 } buildFeatures { // true表示生成build/app/generated/source/buildConfig/release/com/example/app/BuildConfig.java，不需要手动维护版本号、渠道等常量 buildConfig = false } } gradle-wrapper-properties：配置 Gradle Wrapper gradle-properties：配置 Gradle编译参数，详见文档 setting.gradle：配置 Gradle 的多项目管理 local.properties：存放 Android 项目的私有属性配置，如 SDK 路径 multiDexKeep.pro、proguard-rules.pro：可选的混淆文件，用于配置放置在主 Dex 的类、声明避免混淆的类 java插件 参考\n简介\nAndroid App：APK文件，新建时选择Empty Views Activity Android Library：ARR文件，在目录结构上与Android App相同，包含构建APP所需的一切。当你需要构建不同的APK时，具有通用的模块（如账户管理），可以将library添加为每个APP模块的依赖项 Java or Kotlin Library（插件）：JAR文件，打包可重用的代码，不含资源文件，如res中的图片 使用\napp/build.gradle使用library插件（项目下的Android Library已默认使用library插件） // 更改为library plugins { // id \u0026#39;com.android.application\u0026#39; id \u0026#39;com.android.library\u0026#39; } // 注释掉applicationId android { defaultConfig { // applicationId \u0026#34;com.example.myapp\u0026#34; } } AndroidManifest注释掉application配置\n处理本地aar\n在项目根目录中创建一个新文件夹，例如spotify-app-remote，把spotify-app-remote.arr放入，并创建新的build.gradle，添加 configurations.maybeCreate(\u0026#34;default\u0026#34;) artifacts.add(\u0026#34;default\u0026#34;, file(\u0026#39;spotify-app-remote-release-0.7.1.aar\u0026#39;)) settings.gradle 添加文件夹 include \u0026#39;:spotify-app-remote\u0026#39; build.gradle 添加文件夹（使用此arr的模块如app） dependencies{ api project(\u0026#39;:spotify-app-remote\u0026#39;) } 生成jar\\arr Android Studio 打开右侧的 Gradle，选择需要打包的module —\u0026gt; Tasks —\u0026gt; build, 双击 assemble\n生成jar\\arr到Project\\build\\library\\libs或outputs\\aar，移到Project\\app\\libs\n在模块gradle添加\nimplementation fileTree(dir: \u0026#39;libs\u0026#39;, include: [\u0026#39;*.aar\u0026#39;]) implementation fileTree(dir: \u0026#39;libs\u0026#39;, include: [\u0026#39;*.jar\u0026#39;]) 自定义插件的三种方式\nbuild script：在build.gradle脚本中直接编写，只能在本文件内使用 buildSrc项目：新建一个名为buildSrc的Module，Gradle会自动编译和测试，只能在本项目中使用 独立项目：在独立的项目中编写插件，发布到本地或者远程jcenter、maven仓库供其他项目使用 独立项目打包jar到maven：\n在项目中新建File -\u0026gt; New -\u0026gt; New Module -\u0026gt; Java or Kotlin Library\n修改build.gradle：\n// Gradle插件 apply plugin: \u0026#39;groovy\u0026#39; apply plugin: \u0026#39;maven\u0026#39; apply plugin: \u0026#39;java-gradle-plugin\u0026#39; // 依赖 dependencies { implementation gradleApi() //Groovy DSL implementation localGroovy() //Gradle DSL } // 仓库 repositories { mavenCentral() } // 配置插件id和映射类（生成resources文件夹储存) gradlePlugin { plugins { greeting { // 插件id id = \u0026#39;CustomPlugin\u0026#39; // 插件实现类 implementationClass = \u0026#39;com.group.myplugin.CustomPlugin\u0026#39; } } } def group=\u0026#39;com.group.myplugin\u0026#39; def artifactId=\u0026#39;myplugin\u0026#39; def version=\u0026#39;1.0.0\u0026#39; // 指定本地maven的路径，在插件目录下 def uploadRepo = \u0026#39;../myplugin\u0026#39; // 打包到本地maven仓库 uploadArchives { repositories { mavenDeployer { pom.groupId = group pom.artifactId = artifactId pom.version = version repository(url: uri(uploadRepo)) } } } 新建CustomPlugin.groovy文件写插件：实现Plugin接口 package com.group.myplugin import org.gradle.api.Plugin import org.gradle.api.Project class CustomPlugin implements Plugin\u0026lt;Project\u0026gt; { @Override void apply(Project project) { println(\u0026#34;Hello gradle plugin\u0026#34;) } } 将插件发布到本地 Maven 仓库的2种方式： 执行./gradlew uploadArchives命令\n可视化界面的 uploadArchives Task 点击发布\n故障排除 配置 配置build.gradle(project:android) allprojects { repositories { google() jcenter() maven { url \u0026#34;https://storage.googleapis.com/download.flutter.io\u0026#34; } } } 更新 flutter flutter upgrade flutter doctor 报错 查看错误信息 控制台Terminal：./gradlew assembleDebug --info\n常见错误\n更新Android Studio 重新建项目 \\android\\app\\build.gradle compileSdkVersion 33 minSdkVersion 21 其他错误\nAttribute application@label value=(Dormitory) from AndroidManifest.xml 解决：进入\\android\\app\\src\\main\\AndroidManifest.xml\n\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; // 添加此行 package=\u0026#34;com.example.model_dev\u0026#34;\u0026gt; \u0026lt;application tools:replace=\u0026#34;android:label\u0026#34; // 添加此行 android:label=\u0026#34;model_dev\u0026#34; android:name=\u0026#34;${applicationName}\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34;\u0026gt; \u0026lt;activity SDK XML versions up to 3 but an SDK XML file of version 4 was encountered 解决：local.properties添加转义符C\\:\\\\Users\nGradle threw an error while downloading artifacts from the network 解决：Gradle损坏，进入 C:\\Users\\username 删除 .gradle 文件夹\nExecution failed for task:generateDebugRFile 解决：Android Studio -\u0026gt; Analyze -\u0026gt; Code Inspect\ndart 变量 # 创建一个变量并将其初始化 var name = \u0026#39;Bob\u0026#39;; # 指定类型 String name = \u0026#39;Bob\u0026#39;; # 如果对象(name)不局限于单一的类型(例如String),可以将其指定为 Object（或 dynamic）类型 Object name = \u0026#39;Bob\u0026#39;; ? 可空类型 int? a=123; // int? 表示a是一个可空类型 int? a; // 未初始化变量的初始值为null ! 类型断言 a! // a不为空 late 延迟初始化:字段被第一次访问时延迟运行，而不是在实例化后立即运行。 class Weather { late int _temperature = _readThermometer(); } final 已经实例化的final对象不能指向另一个不同的对象，但其字段可以更改。 final name = \u0026#39;Bob\u0026#39;; final String nickname = \u0026#39;Bobby\u0026#39;; const 编译时常量：一经定义就会在编译期间对其进行初始化，const对象及其字段无法更改。 类型 常规类型 注意首字母大小写\nint 整数值 double 浮点数字 String 字符串 bool 布尔类型 List 列表类型 Map 字典型 List 属性：\nlength　长度 reversed　翻转 isEmpty　是否为空 isNotEmpty　是否不为空 方法：\nadd()　增加 addAll()　拼接数组 indexOf()　查找 传入具体值 remove()　删除 传入具体值 removeAt()　删除 传入索引值 fillRange()　修改 insert(index,value);　指定位置插入 insertAll(index,list)　指定位置插入List toList()　其他类型转换成List join()　List转换成字符串 split()　字符串转化成List forEach() map() 示例：List\u0026lt;Widget\u0026gt;.from(MyMap.keys.map((item) =\u0026gt; SomeWidget(item)).toList()); map()可以传入List或Map的每项数据，toList()转换成List，List.from接收Iterable（[Map.keys]、[List] 和 [Set] 都是 Iterable），返回widget List。 where() any() every() Map 属性：\nkeys　获取所有的key值 values　获取所有的value值 isEmpty　是否为空 isNotEmpty　是否不为空 方法：\nremove(key)　删除指定key的数据 addAll({\u0026hellip;})　合并映射 给映射内增加属性 containsValue()　查看映射内的值 返回true/false forEach() map() where() any() every() 其它类型 enum　枚举类型,用于表示固定数量的常量值。在switch语句中运行良好。\nObject　对象类型，允许任何类型。\ndynamic　动态类型，不仅接受所有对象，而且还允许所有操作\nvoid main() { dynamic foo=\u0026#34;bar\u0026#34;; print(foo); foo=123; print(foo); } Set　无序集合，主要的功能就是去除数组重复内容 void main(){ List myList=[\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;,\u0026#39;西瓜\u0026#39;,\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;,\u0026#39;香蕉\u0026#39;,\u0026#39;苹果\u0026#39;]; var s=new Set(); s.addAll(myList); print(s); print(s.toList()); } Future　用于异步支持。 Stream　用于异步支持。 Iterable　用在for-in 循环和同步生成器函数中。 Never　表示表达式永远无法成功完成计算。最常用于总是抛出异常的函数。 void　表示从未使用过某个值。通常用作返回类型。 (value1, value2)　记录（需dart3） Null　空值 不常用的类型 runes 暴露了字符串的 Unicode 代码点（Unicode 为每个字母、数字和符号定义了一个唯一的数值）。例如，用于表情符号，(😆) 是\\u{1f606}。经常被 \u0026ldquo;characters\u0026rdquo; API 取代。\nSymbol 表示标识符，例如#。\nvoid main() { assert(Symbol(\u0026#39;bar\u0026#39;)==#bar); } // true 类型转换 myint = int.parse(myString); // String -\u0026gt; int myString = myint.toString(); // int -\u0026gt; String mydouble = double.parse(myString); // String -\u0026gt; double myString = 3.14159.toStringAsFixed(2); // double -\u0026gt; String (myString = \u0026#39;3.14\u0026#39;) mynum.member = mynum.values.byName(myString); // String -\u0026gt; enum myString = mynum.member.name; // enum -\u0026gt; String 函数 bool isNoble(int atomicNumber) { // bool:返回类型 return _nobleGases[atomicNumber] != null; } 箭头函数 =\u0026gt;\n=\u0026gt; expr 是 { return expr; }的简写\n参数 命名参数（可传可不传） String printUserInfo(String username, {int age = 0, String sex = \u0026#39;男\u0026#39;}) {//行参，用大括号 if (age != 0) { return \u0026#34;姓名:$username---性别:$sex--年龄:$age\u0026#34;; } return \u0026#34;姓名:$username---性别:$sex--年龄保密\u0026#34;; } print(printUserInfo(\u0026#39;张三\u0026#39;)); //实参 print(printUserInfo(\u0026#39;张三\u0026#39;, age: 20, sex: \u0026#39;未知\u0026#39;)); //实参,命名参数的实参必须传入参数名age: sex: 位置参数（可传可不传） String printUserInfo(String username,[String sex=\u0026#39;男\u0026#39;,int age=0]){ //行参，用中括号 if(age!=0){ return \u0026#34;姓名:$username---性别:$sex--年龄:$age\u0026#34;; } return \u0026#34;姓名:$username---性别:$sex--年龄保密\u0026#34;; } print(printUserInfo(\u0026#39;张三\u0026#39;)); //实参 print(printUserInfo(\u0026#39;小李\u0026#39;,\u0026#39;女\u0026#39;,30)); //实参 运算符 算术运算符\n+(加)　–(减)　-(负)　*(乘)　/(除)　~/(取整)　%（取余）\n关系运算符\n==　！=　\u0026gt;　\u0026lt;　\u0026gt;=　\u0026lt;=\n逻辑运算符\n!(取反)　\u0026amp;\u0026amp;(与)　||(或)\n赋值运算符\n基础赋值运算符　=　??=(为 null 的变量赋值)\n复合赋值运算符　+=　-=　*=　/=　%=　~/=\n其他运算符 ()　使用一个方法\n[]　访问 List\n?[]　访问 List,左侧/?表示可以为null\n.　访问成员\n?.　访问成员,左侧/?表示可以为null\n.. 级联，可以在同一个对象上访问实例成员和调用多个实例方法\nif-else的表达式：\ncondition ? expr1 : expr2 如果条件为真，则计算expr1（并返回其值）；否则，计算并返回expr2的值。\nexpr1 ?? expr2 如果expr1不为 null，则返回其值；否则，计算并返回expr2的值。\n类 方法 实例变量和方法 实例变量:\nclass Point { double? x; // Declare instance variable x, initially null. double? y; // Declare y, initially null. double z = 0; // Declare z, initially 0. } 实例方法可以访问实例变量和 this\nimport \u0026#39;dart:math\u0026#39;; class Point { final double x; final double y; Point(this.x, this.y); double distanceTo(Point other) { var dx = x - other.x; var dy = y - other.y; return sqrt(dx * dx + dy * dy); } } 静态变量和方法 使用关键字 static 可以声明类变量或类方法。静态成员可以通过类名称直接访问（不需要实例化），提高性能。静态方法不能访问非静态成员，非静态方法可以访问静态成员，不能使用this关键字。\nget 和 set 特殊方法:实例对象的每一个属性都有一个隐式的 Getter 方法，非 final 属性还会有一个 Setter 方法。\n通过get和set修饰的方法不带小括号，可以使访问方法像访问属性一样，简便我们的使用、访问 set：传入属性，get：访问属性。 class Rectangle { double left, top, width, height; Rectangle(this.left, this.top, this.width, this.height); double get right =\u0026gt; left + width; set right(double value) =\u0026gt; left = value - width; } void main() { var rect = Rectangle(3, 4, 20, 15); // 通过getter访问 right assert(rect.right == 23); // 通过setter修改 right 属性 rect.right = 12; assert(rect.left == -8); } 抽象类、抽象方法 抽象类常用于定义接口，抽象类常常会包含抽象方法\nabstract class Doer { // Define instance variables and methods... void doSomething(); // Define an abstract method. } class EffectiveDoer extends Doer { void doSomething() { // Provide an implementation, so the method is not abstract here... } } call() 在别人项目经常看到此方法，看其解释感觉可以省略不写。\n所有 Dart函数（具有函数类型而不是类/接口类型的对象）都有一个call方法。\n该call方法与函数本身具有相同的函数类型，并且在调用它时它的行为完全相同。您甚至可以说调用函数就是隐式调用其call方法。如果您编写函数调用e1(e2, e3)，那么编译器会检查是否e1有call方法，如果有，则将其转换为方法调用e1.call(e2, e3)。\n构造函数 特点： 实例化类时会被自动触发\n一般用于初始化操作\n没有返回值\n普通构造函数 构造函数方法名和类名相同\nclass Point { num x, y; Point(num x, num y) { // There\u0026#39;s a better way to do this, stay tuned. this.x = x; this.y = y; } } 简化形式：\nclass Point { num x, y; // Syntactic sugar for setting x and y // before the constructor body runs. Point(this.x, this.y); } 命名构造函数 命名构造函数(类名.函数名)可以实现多个构造器。\nclass Point { num x, y; Point(this.x, this.y); // 命名构造函数 Point.origin() { x = 0; y = 0; } } 请记住，命名构造函数不可继承，如果子类想要有 和父类一样的命名构造函数，那就写个同名的（通常也会在子类的命名构造函数里，调用父类的同名命名构造函数）\n调用父类构造函数 如果你的类，继承于父类，那么子类的构造函数，势必要调用父类的构造函数，这时候就要分两种情况：\nDart语言帮你调用父类的无参数构造函数 代码中显式调用父类的构造函数 默认调用调用父类的无参数构造函数 如果你没有显式调用父类的构造函数，并且父类有一个无参数构造函数，那么Dart就会帮你在子类的构造函数方法体的最前面，调用父类的无参数构造函数。当然，后面我们会说道，构造函数分成好几部分来初始化成员变量，调用的顺序如下：\n初始化列表 父类的无参数构造函数 子类的无参数构造函数 当然，如果父类没有无参数构造函数，或者Dart这种隐式调用无法满足你的要求，那就需要显式调用父类的构造函数了\n显式调用父类构造函数 显式调用父类构造函数，应该在初始化列表中完成\nclass Person { String firstName; Person.fromJson(Map data) { print(\u0026#39;in Person\u0026#39;); } } class Employee extends Person { // Person does not have a default constructor; // you must call super.fromJson(data). Employee.fromJson(Map data) : super.fromJson(data) { print(\u0026#39;in Employee\u0026#39;); } } main() { var emp = new Employee.fromJson({}); // Prints: // in Person // in Employee } 初始化列表 在构造函数后加上: x = , y = 可以在构造函数中设置属性的默认值\n在构造函数体执行之前执行\n可以调用超类的构造函数\n// Initializer list sets instance variables before // the constructor body runs. Point.fromJson(Map\u0026lt;String, num\u0026gt; json) : x = json[\u0026#39;x\u0026#39;], y = json[\u0026#39;y\u0026#39;] { print(\u0026#39;In Point.fromJson(): ($x, $y)\u0026#39;); } 尤其是初始化那些final修饰的成员变量时，初始化列表很有用，因为在方法体中，不能给final修饰的成员变量赋值，因为在执行方法体的时候，final修饰的成员变量已经不能变了。这个地方很多人犯错。\nimport \u0026#39;dart:math\u0026#39;; class Point { final num x; final num y; final num distanceFromOrigin; Point(x, y) : x = x, y = y, distanceFromOrigin = sqrt(x * x + y * y); } main() { var p = new Point(2, 3); print(p.distanceFromOrigin); } 重定向构造函数 定义构造函数的时候，除了一个普通构造函数，还可以有若干命名构造函数，这些构造函数之间，有时候会有一些相同的逻辑，如果分别书写在各个构造函数中，会有些多余，所以构造函数可以传递。\nclass Point { num x, y; // The main constructor for this class. Point(this.x, this.y); // Delegates to the main constructor. Point.alongXAxis(num x) : this(x, 0); } 传递构造函数，没有方法体，会在初始化列表中，调用另一个构造函数。\n常量构造函数 class ImmutablePoint { static final ImmutablePoint origin = const ImmutablePoint(0, 0); final num x, y; const ImmutablePoint(this.x, this.y); } 如果你的类，创建的对象永远不会改变，你可以在编译期就创建这个常量实例，并且定义一个常量构造函数，并且确保所有的成员变量都是final的。\n工厂构造函数/单例模式 在构造函数前加上factory\n只实例化一次，节省相同实例化带来的消耗\n第一次调用命名构造函数进入工厂函数中实例化，后续调用就用缓存中现成的实例\n工厂构造函数，没有权利访问this\nclass Logger { final String name; bool mute = false; // _cache is library-private, thanks to // the _ in front of its name. static final Map\u0026lt;String, Logger\u0026gt; _cache = \u0026lt;String, Logger\u0026gt;{}; factory Logger(String name) { if (_cache.containsKey(name)) { return _cache[name]; } else { final logger = Logger._internal(name); # 调用构造函数 _cache[name] = logger; return logger; } } Logger._internal(this.name); # 定义命名构造函数 void log(String msg) { if (!mute) print(msg); } } main() { var logger = Logger(\u0026#39;UI\u0026#39;); logger.log(\u0026#39;Button clicked\u0026#39;); } 上例的意思是，类中又一个静态缓存_cache保存着一些Logger类实例，创建实例时，给工厂构造函数传递的name，如果在缓存中已经存在，就用缓存中现成的实例，如果没有，就新建一个实例，并且也放到缓存中。\n如此，我们可以创建名字为UI / SYS / API 等的实例，然后在debug的时候，如果设置名字为UI的Logger实例的mute为true，就不会打印UI相关的log，而不影响其它两个名字的log。\n回调函数 回调函数本质上是把函数作为参数传递给小部件的函数，当按钮按下时调用此函数。\n官方实现：\n/// Signature of callbacks that have no arguments and return no data. typedef VoidCallback = void Function(); /// Signature for callbacks that report that an underlying value has changed. /// See also: /// * [ValueSetter], for callbacks that report that a value has been set. typedef ValueChanged\u0026lt;T\u0026gt; = void Function(T value); 示例：\nimport \u0026#39;package:flutter/material.dart\u0026#39;; void main() { runApp(const MyApp()); } class MyApp extends StatefulWidget { const MyApp({Key? key}) : super(key: key); @override State\u0026lt;MyApp\u0026gt; createState() =\u0026gt; _MyAppState(); } class _MyAppState extends State\u0026lt;MyApp\u0026gt; { String topic = \u0026#34;Packages\u0026#34;; callback(varTopic) { // setState:通知内部状态已更改从而重建UI setState(() { topic = varTopic; }); } @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: AppBar( title: const Text(\u0026#34;Learning Flutter\u0026#34;), ), body: Column( children: [ Container( width: double.maxFinite, height: 70, margin: const EdgeInsets.only( top: 50, left: 40, right: 40, bottom: 20), decoration: BoxDecoration( color: Colors.lightBlue, borderRadius: BorderRadius.circular(20)), child: Center( child: Text( \u0026#34;We are learning Flutter $topic\u0026#34;, style: const TextStyle(fontSize: 20, color: Colors.white), ), ), ), MyButtons(topic: \u0026#34;Cubit\u0026#34;, callbackFunction: callback), MyButtons(topic: \u0026#34;BLoc\u0026#34;, callbackFunction: callback), MyButtons(topic: \u0026#34;GetX\u0026#34;, callbackFunction: callback) ], ), ), ); } } class MyButtons extends StatelessWidget { final String topic; final Function callbackFunction; const MyButtons( {Key? key, required this.topic, required this.callbackFunction}) : super(key: key); @override Widget build(BuildContext context) { return GestureDetector( onTap: () { callbackFunction(topic); }, child: Container( width: double.maxFinite, height: 70, margin: const EdgeInsets.only(top: 20, left: 40, right: 40, bottom: 20), decoration: BoxDecoration( color: Colors.lightBlue, borderRadius: BorderRadius.circular(20)), child: Center( child: Text( topic, style: const TextStyle(fontSize: 20, color: Colors.white), ), ), ), ); } } Function class Function是所有函数类型的超类。\nFunction有一些没有声明的特殊功能：\nFunction 静态类型的值仍然可以像函数一样被调用（这样的调用是动态调用,编译器无法在编译时检查类型的正确性,在运行时将执行检查以确保参数类型一致）。 Function f = (int x) =\u0026gt; \u0026#34;$x\u0026#34;; print(f(1)); // Prints \u0026#34;1\u0026#34;. f(\u0026#34;not\u0026#34;, \u0026#34;one\u0026#34;, \u0026#34;int\u0026#34;); // Throws! No static warning. widgets之间的通信 https://medium.com/flutter-community/flutter-communication-between-widgets-f5590230df1e\n扩展 扩展类 extends Extends是典型的OOP类继承。如果 a类 扩展了 b类，则 a类 可以使用或覆盖 b类 中实现的所有属性、变量、函数 。在 Dart 中，一个类只能扩展一个类。 implements 创建另一个类或接口的实现。当 a类 实现 b类 时，必须实现 b类 中定义的所有功能(所有属性、变量、函数)。一个类可以实现多个接口。\nwith mixin使用with关键字，类似于继承，可以扩展多个类。mixins的类只能继承自Object，不能再继承其他类，且不能有构造函数。\n# extends只能扩展一个类，而mixin没有限制，可以一起使用 class Maestro extends Person with Musical, Aggressive, Demented { Maestro(String maestroName) { name = maestroName; canConduct = true; } } super super关键字用于调用父类的对象、方法、构造函数和子类中的属性。\n// 访问父类变量 super.variable_name; // 访问父类方法 super.method_name(); // 转发给超类的构造函数 const MyApp({Key? key}) : super(key: key); 扩展方法 // 扩展 num，就可以使用 num.attribute 和 num.method extension FancyNum on num { num plus(num other) =\u0026gt; this + other; num times(num other) =\u0026gt; this * other; } print(5.plus(3)); // Equal to \u0026#34;5 + 3\u0026#34;. print(5.times(8)); // Equal to \u0026#34;5 * 8\u0026#34;. print(2.plus(1).times(3)); // Equal to \u0026#34;(2 + 1) * 3\u0026#34;. 泛型 泛型常用于需要要求类型安全的情况，可以减少代码重复。 如果 T 是一个class，则表示传入该类型的参数。\n@override 注解来表示你重写了一个成员 异步 Isolate Isolate 是运行所有 Dart 代码的地方，在许多其他语言里（例如 C++），你可以让多个线程共享相同的内存，但是在 Dart 中，每个线程都有自己的 Isolate 和它自己的内存。\n如果你要运行的计算量太过庞大，在 main Isolate 中运行可能会导致丢帧，如果处理可能需要几百毫秒，则考虑创建单独的Isolate，例如：\n解码 JSON，HttpRequest 的结果 =\u0026gt; compute 加密可能非常耗时 处理图像（例如裁剪） 从 Web 加载图像 事件循环\nDart使用永不阻塞的单线程来处理所有事件。因此，它运行一个事件循环，它从事件队列中取得最先发生的事件，处理它，返回下一个事件进行处理，依此类推，直到事件队列清空为止。\nFuture 定义\n// Future\u0026lt;type\u0026gt;是一种类型 Future\u0026lt;void\u0026gt; myVoidFuture() {} // 不返回任何内容，但可以在最终完成时通知调用者。 Future\u0026lt;bool\u0026gt; myTypedFuture() {} // 如果需要返回一个值，那么你传递给它一个类型。 Future 有两种状态：\n未完成(Uncompleted): 你刚刚得到一个 Future，还未打开 首先，事件发生，事件循环获取事件，并调用你写的处理程序，得到一个返回的 Future，此时Future是关着的，此时 Future 未能完成，事件循环继续执行其他事件。 已完成 Completed with a value: 打开了，带有一个值 等到数据抵达时，Future 得到数据并打开它，如果Future 完成并带有一个值，此时会触发你的 then 回调。then 是你可以用来在每个 Future 上注册回调的实例方法，你可以用它创建一个函数，传入一个匹配 Future 类型的参数。 Completed with an error: 打开了，抛出一个异常 如果Future 在完成时没有带一个值，你可以使用 catchError注册另一个回调，catchError 的工作方式和 then 一样，唯一不同的是它捕获异常而不是值。你甚至可以给它一个test方法，你可以通过这种方式使用多个 catchError 方法，每种方法都会检查错误返回值的类型。 void main() { Future\u0026lt;int\u0026gt;.delayed ( Duration (seconds: 3), () { return 100; }, ).then((value) { print(value); }).catchError( (err) { print(\u0026#39;Caught $err\u0026#39;); }, test: (err) =\u0026gt; err.runtimeType == String, ).whenComplete (() { print(\u0026#39;All finished!\u0026#39;); }); print(\u0026#39;waiting...\u0026#39;); } Future方法\nFuture.value 如果你已经知道 Future 返回的值，你可以使用 Future.value 为构造函数命名，构建缓存服务时可以用这个\nFuture.error 它需要一个异常对象和一个可选的堆栈跟踪\nFuture.delayed 在运行函数和 Future 完成之前，指定等待时长，可以创建测试用的模拟网络服务\nStreams 每个 future 单一地传递错误，或者数据，Streams随着时间的推移，可以传送零个、多个值，或者是错误。\nasync await async 和 await 实际上只是 future 和 streams 的替代语法，在连续的Future中，每一处Future都需要定义、then、return，而且所有内容添加到then下不易阅读，而await只需如下写：\nimport \u0026#39;dart:io\u0026#39;; void main() { createData(); } Future\u0026lt;ProcessedData\u0026gt; createData() async { try { final id = await _loadFromDisk(); final data = await _fetchNetworkData(id); return ProcessedData(data); } on HttpException catch (err) { print(\u0026#39;Network error: $err\u0026#39;); return ProcessedData.empty(); } finally { print(\u0026#39;All done!\u0026#39;); } } Future\u0026lt;int\u0026gt; _loadFromDisk() async { print(\u0026#39;loadFromDisk\u0026#39;); return 0; } Future\u0026lt;String\u0026gt; _fetchNetworkData(int id) async { print(\u0026#39;NetworkData\u0026#39;); return \u0026#39;NetworkData\u0026#39;; } class ProcessedData { ProcessedData(this.data); final String data; static Future\u0026lt;ProcessedData\u0026gt; empty() async { var empty = ProcessedData(\u0026#39;empty\u0026#39;); print(empty); return empty; } } 上面官方示例介绍了连续的 await，这是更清晰的使用示例：\nvoid main() async { print(getMeSomeFood()); print(await getMeSomethingBetter()); maybeSomethingSweet().then((String value) { print(value); }); print(\u0026#39;done\u0026#39;); } Future\u0026lt;String\u0026gt; getMeSomeFood() async { return \u0026#34;an apple\u0026#34;; } Future\u0026lt;String\u0026gt; getMeSomethingBetter() async { return \u0026#34;a burger?\u0026#34;; } Future\u0026lt;String\u0026gt; maybeSomethingSweet() async { return \u0026#34;a chocolate cake!!\u0026#34;; } // output: // Instance of ‘_Future\u0026lt;String\u0026gt;’ 不等待，返回一个future // a burger? 等待future完成 // done // a chocolate cake!! 不等待，先继续执行print(\u0026#39;done\u0026#39;)，future完成后再调用then Generator Single value Zero or more values Sync: int Iterable Async: Future Stream 当您需要延迟生成一系列值时，请考虑使用生成器函数。Dart 内置支持两种生成器函数：\n同步生成器：返回一个Iterable对象。 异步生成器：返回一个Stream对象。 实现一个同步生成器函数，将函数体标记为sync*，使用yield语句传递值：\nIterable\u0026lt;int\u0026gt; naturalsTo(int n) sync* { int k = 0; while (k \u0026lt; n) yield k++; } 实现异步生成器函数，将函数体标记为async*，使用yield语句传递值：\nStream\u0026lt;int\u0026gt; asynchronousNaturalsTo(int n) async* { int k = 0; while (k \u0026lt; n) yield k++; } 如果您的生成器是递归的，您可以使用以下方法提高其性能yield*：\nIterable\u0026lt;int\u0026gt; naturalsDownFrom(int n) sync* { if (n \u0026gt; 0) { yield n; yield* naturalsDownFrom(n - 1); } } flutter Widget生命周期 StatelessWidget生命周期源码图 Flutter 中万物皆为Widget，widget类继承自DiagnosticableTree。\nDiagnosticableTree即“诊断树”，主要作用是提供调试信息。\nFlutter 中的 UI 或一堆小部件组成，通常称为小部件树，根据 Widget 树生成一个 Element 树，Widget 和 Element 是一一对应的，根据 Element 树生成 Render 树（渲染树），真正的布局和渲染逻辑在 Render 树中。\nWidget.createElement() :创建一个Element实例，记为element。\nBuildContext是widget对应的Element，用于跟踪树中的每个小部件并定位它们及其在树中的位置。每个小部件的BuildContext都传递给它们的build方法。build方法返回小部件呈现的小部件树。\ncontext参数是BuildContext类的一个实例，表示当前 widget 在 widget 树中的上下文，每一个 widget 都会对应一个 context 对象。在很多时候我们都需要使用context，比如获取主题：Theme.of(context).colorScheme.primary。\nKey: [Key]是[Widget]、[Element]和[SemanticsNode]的标识符。Key可以保持组件之前的状态，比如在用户滑动时或者修改集合时，决定的条件在canUpdate()方法中。使用 GlobalKey时，Flutter 不仅会在树中查找与特定级别匹配的键，还会在整个应用程序中查找,GlobalKey就像全局变量。\ncanUpdate(...): newWidget与oldWidget的runtimeType和key同时相等时就会用new widget去更新Element对象的配置。如果 Type 相同但 Key 不同，则Element将被deactivated（释放，但它可能仍然存在）。如果 Type 不同，则Element将被disposed（永久删除）。\nelement.mount() :调用createRenderObject创建RenderObject，并使用attachRenderObject将RenderObject关联到Element上。\n使用 StatelessWidget 要求我们重写build方法,它将state作为输入并提供相应的 UI 显示在用户屏幕上：UI = build(state),当我们初始化一个StatelessWidget对象时会调用 build 方法。\nclass CounterWidget extends StatelessWidget { final bool isLoading; final int counter; const CounterWidget({ required this.isLoading, required this.counter, }); @override Widget build(BuildContext context) { return isLoading ? CircularProgressIndicator() : Text(\u0026#39;$counter\u0026#39;); } } StatefulWidget 要求我们重写createState功能:\nclass MyHomePage extends StatefulWidget { final bool isLoading; final int counter; const MyHomePage({ required this.isLoading, required this.counter, }); @override State\u0026lt;MyHomePage\u0026gt; createState() { return MyHomePageState(); } } createState()会为每一个StatefulElement创建一个State对象。示例中创建了MyHomePageState对象，当MyHomePageState初始化时，它会调用build函数。\nclass MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { @override Widget build(BuildContext context) { return Scaffold( body: Center( child: CounterWidget( isLoading: widget.isLoading, counter: widget.counter, ), ), ); } } widget.isLoading、widget.counter属性用于表示当前配置信息，并且在父级更新小部件时会被自动更新。setState是State的方法。当我们调用setState方法时，build方法将立即再次被调用。\n当你的组件是静态的，不需要更新自身状态,使用StatelessWidget。当你的组件需要根据事件或交互来动态更新自身状态,使用StatefulWidget。\nGetx 状态管理 介绍 分类 状态管理器 消耗RAM 结论 无状态页面 GetView 最少 相当于StatelessWidget,性能最好，最常用 简单的状态管理（一个页面的状态管理） GetBuilder 较少 相当于StatefulWidget,性能较好 反应式状态管理（全局的状态管理） Obx 稍多 反应式的基础层，较Getx简洁 GetX 较多 可以灵活使用的反应式状态管理 混合态管理 MixinBuilder 最多 在GetBuilder中插入一个Obx，既可以响应式更新、也可以手动更新 Controller Getx状态管理的代码结构都可以分为GetXController（控制器层）和view（界面层），GetXController 可以进一步分为state（状态层/变量层），logic（逻辑层）。\n└── sinup ├── controller.dart ──┤─ ─ logic.dart │ │─ ─ state.dart ├── view.dart 生命周期 在 StatefulWidget 中，使用initState或dispose()，而在 Controller 中我们可以使用相对应的操作：\nonStart（开始）[不可覆盖]：组件在内存分配的时间点就会被调用，完成后会调用onInit方法 onInit（初始化）：组件在内存分配后会被马上调用，适用于初始化 Controller（例如一些成员属性的初始化），详见Workers小节 onReady（加载完成）：在 onInit 一帧后被调用，适合做一些导航进入的事件（例如对话框提示、SnackBar）或异步网络请求 onClose（控制器被释放）：在 onDelete 方法前调用、用于销毁 controller 使用的资源（例如关闭事件监听，关闭流对象、动画）或者销毁可能造成内存泄露的对象（例如 TextEditingController，AniamtionController）。也适用于将数据进行离线持久化。 onDelete（删除）[不可覆盖]：在 controller销毁前调用，将控制器从内存中删除 反应状态管理 反应变量 使用反应状态管理需要声明反应变量，你有3种方法可以把一个变量变成是 \u0026ldquo;可观察的\u0026rdquo;。\n1 - 第一种是使用 Rx{Type}。\n// 建议使用初始值，但不是强制性的 final name = RxString(\u0026#39;\u0026#39;); final isLogged = RxBool(false); final count = RxInt(0); final balance = RxDouble(0.0); final items = RxList\u0026lt;String\u0026gt;([]); final myMap = RxMap\u0026lt;String, int\u0026gt;({}); 2 - 第二种是使用 Rx，规定泛型 Rx\u0026lt;Type\u0026gt;。\nfinal name = Rx\u0026lt;String\u0026gt;(\u0026#39;\u0026#39;); final isLogged = Rx\u0026lt;Bool\u0026gt;(false); final count = Rx\u0026lt;Int\u0026gt;(0); final balance = Rx\u0026lt;Double\u0026gt;(0.0); final number = Rx\u0026lt;Num\u0026gt;(0) final items = Rx\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;([]); final myMap = Rx\u0026lt;Map\u0026lt;String, int\u0026gt;\u0026gt;({}); // 自定义类 - 可以是任何类 final user = Rx\u0026lt;User\u0026gt;(); 3 - 第三种更实用、更简单和首选的方法，只需添加 .obs 作为value的属性。\nfinal name = \u0026#39;\u0026#39;.obs; final isLogged = false.obs; final count = 0.obs; final balance = 0.0.obs; final number = 0.obs; final items = \u0026lt;String\u0026gt;[].obs; final myMap = \u0026lt;String, int\u0026gt;{}.obs; // 自定义类 - 可以是任何class, literally final user = User().obs; 使用value // controller final count1 = 0.obs; final count2 = 0.obs; int get sum =\u0026gt; count1.value + count2.value; // 由于.obs把变量换成`Rx{Type}`类型，所以需要用.value取值 // 视图 GetX\u0026lt;Controller\u0026gt;( builder: (controller) { print(\u0026#34;count 1 rebuild\u0026#34;); return Text(\u0026#39;${controller.count1.value}\u0026#39;); }, ), GetX\u0026lt;Controller\u0026gt;( builder: (controller) { print(\u0026#34;count 2 rebuild\u0026#34;); return Text(\u0026#39;${controller.count2.value}\u0026#39;); }, ), GetX\u0026lt;Controller\u0026gt;( builder: (controller) { print(\u0026#34;count 3 rebuild\u0026#34;); return Text(\u0026#39;${controller.sum}\u0026#39;); }, ), Obx class StateObxView extends StatelessWidget { StateObxView({Key? key}) : super(key: key); final count = 0.obs; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\u0026#34;Obx(...)\u0026#34;), ), body: Center( child: Column( children: [ Obx(() =\u0026gt; Text(\u0026#34;count1 -\u0026gt; \u0026#34; + count.toString())), Obx(() =\u0026gt; Text(\u0026#34;count2 -\u0026gt; \u0026#34; + count.toString())), // Divider(), ElevatedButton( onPressed: () { count.value++; }, child: Text(\u0026#39;add\u0026#39;), ), ], ), ), ); } } GetX Controller\nclass CountController extends GetxController { final _count = 0.obs; set count(value) =\u0026gt; this._count.value = value; get count =\u0026gt; this._count.value; final _count2 = 0.obs; set count2(value) =\u0026gt; this._count2.value = value; get count2 =\u0026gt; this._count2.value; add() =\u0026gt; _count.value++; add2() =\u0026gt; _count2.value++; } View\nclass StateGetxView extends StatelessWidget { StateGetxView({Key? key}) : super(key: key); final controller = CountController(); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\u0026#34;Getx\u0026#34;), ), body: Center( child: Column( children: [ GetX\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetX - 1\u0026#34;); return Text(\u0026#39;value 1 -\u0026gt; ${_.count}\u0026#39;); }, ), GetX\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetX - 2\u0026#34;); return Text(\u0026#39;value 2 -\u0026gt; ${_.count}\u0026#39;); }, ), Divider(), // GetX\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetX - 3\u0026#34;); return Column( children: [ Text(\u0026#39;value 3 -\u0026gt; ${_.count}\u0026#39;), ElevatedButton( onPressed: () { _.add(); }, child: Text(\u0026#39;count1\u0026#39;), ) ], ); }, ), Divider(), // count2 GetX\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetX - 4\u0026#34;); return Text(\u0026#39;value 4 -\u0026gt; ${_.count2}\u0026#39;); }, ), Divider(), // 按钮 ElevatedButton( onPressed: () { controller.add(); }, child: Text(\u0026#39;count1\u0026#39;), ), ElevatedButton( onPressed: () { controller.add2(); }, child: Text(\u0026#39;count2\u0026#39;), ), ], ), ), ); } } 简单状态管理 GetBuilder Controller同Getx\nView\nclass StateGetBuilderView extends StatelessWidget { StateGetBuilderView({Key? key}) : super(key: key); final controller = CountController(); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\u0026#34;GetBuilder\u0026#34;), ), body: Center( child: Column( children: [ GetBuilder\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 1\u0026#34;); return Text(\u0026#39;value -\u0026gt; ${_.count}\u0026#39;); }, ), GetBuilder\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 2\u0026#34;); return Text(\u0026#39;value -\u0026gt; ${_.count}\u0026#39;); }, ), Divider(), // GetBuilder\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 3\u0026#34;); return Column( children: [ Text(\u0026#39;value -\u0026gt; ${_.count}\u0026#39;), ElevatedButton( onPressed: () { _.add(); }, child: Text(\u0026#39;GetBuilder -\u0026gt; add\u0026#39;), ) ], ); }, ), Divider(), // count2 GetBuilder\u0026lt;CountController\u0026gt;( init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 4\u0026#34;); return Text(\u0026#39;value count2 -\u0026gt; ${_.count2}\u0026#39;); }, ), Divider(), // id2 标记一个 `builder` ，触发方式`controller.update([\u0026#34;id2\u0026#34;]);` ，可传多个 `Array` 类型。 GetBuilder\u0026lt;CountController\u0026gt;( id: \u0026#34;id2\u0026#34;, init: controller, initState: (_) {}, builder: (_) { print(\u0026#34;GetBuilder - 4\u0026#34;); return Text(\u0026#39;id2 -\u0026gt; value count2 -\u0026gt; ${_.count2}\u0026#39;); }, ), Divider(), // 按钮 ElevatedButton( onPressed: () { controller.add(); }, child: Text(\u0026#39;add\u0026#39;), ), ElevatedButton( onPressed: () { controller.add2(); }, child: Text(\u0026#39;add2\u0026#39;), ), ElevatedButton( onPressed: () { controller.update(); }, child: Text(\u0026#39;controller.update()\u0026#39;), ), ElevatedButton( onPressed: () { controller.update([\u0026#34;id2\u0026#34;]); }, child: Text(\u0026#39;controller.update(id2)\u0026#39;), ), ], ), ), ); } } Workers Workers可以精确控制事件发生时触发回调，常用于Controller的onInit中：\nclass CountController extends GetxController { final _count = 0.obs; set count(value) =\u0026gt; this._count.value = value; get count =\u0026gt; this._count.value; add() =\u0026gt; _count.value++; @override void onInit() { super.onInit(); // 每次_count变化时调用 ever(_count, (value) { print(\u0026#34;ever -\u0026gt; \u0026#34; + value.toString()); }); // 第一次被改变时才会被调用。 once(_count, (value) { print(\u0026#34;once -\u0026gt; \u0026#34; + value.toString()); }); // 防DDos - 每当用户停止输入1秒时调用 debounce( _count, (value) { print(\u0026#34;debounce -\u0026gt; \u0026#34; + value.toString()); }, time: Duration(seconds: 1), ); // 忽略1秒内的所有变化。 interval( _count, (value) { print(\u0026#34;interval -\u0026gt; \u0026#34; + value.toString()); }, time: Duration(seconds: 1), ); } } 路由管理 普通路由 // 导航到新的页面。 Get.to(NextScreen()); // 要导航到下一条路由，并在返回后立即接收或更新数据。 var data = await Get.to(Payment()); // 关闭SnackBars、Dialogs、BottomSheets或任何你通常会用Navigator.pop(context)关闭的东西。 Get.back(); // 在另一个页面上，发送前一个路由的数据。并使用它。 Get.back(result: \u0026#39;success\u0026#39;); if(data == \u0026#39;success\u0026#39;) madeAnything(); // 进入下一个页面，但没有返回上一个页面的选项（用于SplashScreens，登录页面等）。 Get.off(NextScreen()); // 进入下一个界面并取消之前的所有路由（在购物车、投票和测试中很有用）。 Get.offAll(NextScreen()); 别名路由 普通路由管理起来比较麻烦,通常我们使用别名路由。\n// 导航到下一个页面 Get.toNamed(\u0026#34;/NextScreen\u0026#34;); // 传递参数 Get.toNamed(\u0026#34;/NextScreen\u0026#34;, arguments: \u0026#34;Hello\u0026#34;); // 浏览并删除前一个页面。 Get.offNamed(\u0026#34;/NextScreen\u0026#34;); // 浏览并删除所有以前的页面。 Get.offAllNamed(\u0026#34;/NextScreen\u0026#34;); // 动态URL Get.offAllNamed(\u0026#34;/NextScreen?device=phone\u0026amp;id=354\u0026amp;name=Enzo\u0026#34;); 示例 1\n注册时跳到到Pin页面，路由传参：\n// RegisterController Get.offNamed( RouteNames.systemRegisterPin, arguments: UserRegisterReq( username: userNameController.text, email: emailController.text, password: password, ), ); 从路由接收参数：\n// RegisterPinController UserRegisterReq? req = Get.arguments; 依赖注入 Get.put()： 不使用控制器实例也会被创建\nGet.put(CountController()); Get.lazyPut()： 懒加载方式创建实例，只有在使用时才创建\nGet.lazyPut\u0026lt;CountController\u0026gt;(() =\u0026gt; CountController()); Get.putAsync()： Get.put()的异步版版本\nGet.putAsync\u0026lt;CountController\u0026gt;(() async =\u0026gt; await CountController()); Get.create()： 每次使用都会创建一个新的实例\nGet.find()： 你可以实例化100万个控制器，Get总会找到你所需的控制器\nGet.find\u0026lt;CountController\u0026gt;(); 其他 GetView 一个已注册Controller的const StatelessWidget。\nGetxService 这个类就像一个GetxController，需要在应用程序的生命周期绝对持久化类实例，使用GetxService。\n其他高级 API https://github.com/jonataslaw/getx#other-advanced-apis\ndio 原理 # dio_mixin.dart 文件中 DioMixin 实现了 Dio abstract class DioMixin implements Dio { @override Future\u0026lt;Response\u0026lt;T\u0026gt;\u0026gt; post\u0026lt;T\u0026gt;( String path, { # path： 请求的url链接 data, # data： 请求数据，例如上传用到的FromData Map\u0026lt;String, dynamic\u0026gt;? queryParameters, # data： 请求数据，例如上传用到的FromData Options? options, # queryParameters： 查询参数 CancelToken? cancelToken, # cancelToken： 用来取消发送请求的token ProgressCallback? onSendProgress, # onSendProgress： 网络请求发送的进度 ProgressCallback? onReceiveProgress, # onSendProgress： 网络请求发送的进度 }) { return request\u0026lt;T\u0026gt;( # 返回request方法 path, data: data, options: checkOptions(\u0026#39;POST\u0026#39;, options), queryParameters: queryParameters, cancelToken: cancelToken, onSendProgress: onSendProgress, onReceiveProgress: onReceiveProgress, ); } } get() post() 等调用时，返回request方法，request 方法对请求参数处理，并返回 fetch 方法，fetch 进行响应数据设定、构建请求流、添加拦截器、请求分发。\nWebView WebView是应用内显示网页的功能，查看项目的官网、文档、条款等经常用到。推荐使用flutter_inappwebview，比官方webview_flutter有更丰富的功能和详尽的文档。主要功能：\nInAppWebView：是一个内嵌原生 WebView 小部件，集成到 Flutter 小部件树中。\nContextMenu：WebView 的快捷菜单。例如长按网页文本后的复制。 HeadlessInAppWebView：无头模式下的 WebView。在没有界面或UI的情况下运行WebView。它可以在没有用户界面的情况下执行网页加载和渲染操作，而不需要在用户界面中显示网页，用于后台处理网页数据、自动化测试、网络爬虫等。 InAppBrowser\nInAppBrowser：显示在 Flutter 应用程序顶部的原生 WebView，它没有集成到 Flutter 小部件树中。 ChromeSafariBrowser：Android 上的 Chrome 自定义选项卡和 iOS 上的SFSafariViewController。 InAppLocalhostServer：这个类允许你在 http://localhost:[port] 上创建一个简单的服务器。默认端口值为 8080。能够在本地服务器上缓存 js，html等资产文件，优化加载时间。\nCookieManager：此类实现了一个单例对象（共享实例），该对象管理 WebView 实例使用的 cookie。\nHttpAuthCredentialDatabase：此类实现管理共享 HTTP 身份验证凭据缓存的单例对象（共享实例）。\nWebStorageManager：这个类实现了一个单例对象（共享实例），它管理 WebView 实例使用的 Web 存储。\nService Worker：Service Worker 是 PWA 的基本组成部分。它们支持快速加载（无论网络如何）、离线访问、推送通知和其他功能。\nInAppWebView官方示例注释\rimport \u0026#39;dart:async\u0026#39;; import \u0026#39;package:flutter/foundation.dart\u0026#39;; import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:flutter_inappwebview/flutter_inappwebview.dart\u0026#39;; import \u0026#39;package:url_launcher/url_launcher.dart\u0026#39;; Future main() async { WidgetsFlutterBinding.ensureInitialized(); // 如果是Android，则对加载到 WebView 中的 Web内容（HTML/CSS/JavaScript）启用调试 if (!kIsWeb \u0026amp;\u0026amp; defaultTargetPlatform == TargetPlatform.android) { await InAppWebViewController.setWebContentsDebuggingEnabled(true); } runApp(const MaterialApp(home: MyApp())); } class MyApp extends StatefulWidget { const MyApp({super.key}); @override State\u0026lt;MyApp\u0026gt; createState() =\u0026gt; _MyAppState(); } class _MyAppState extends State\u0026lt;MyApp\u0026gt; { final GlobalKey webViewKey = GlobalKey(); InAppWebViewController? webViewController; InAppWebViewSettings settings = InAppWebViewSettings( // 能够监听 WebView.shouldOverrideUrlLoading（URL即将加载时）的事件。 useShouldOverrideUrlLoading: true, // 设置为 true 以防止 HTML5 音频或视频自动播放。 mediaPlaybackRequiresUserGesture: false, // 允许 HTML5 媒体播放在屏幕布局中内嵌显示，即让媒体播放器嵌入到网页的其他内容中一起显示 allowsInlineMediaPlayback: true, // 根据请求的来源定义了哪些功能可供使用（例如，访问麦克风、摄像头、电池、网络共享等） iframeAllow: \u0026#34;camera; microphone\u0026#34;, // 如果 iframe 可以通过调用 requestFullscreen() 方法激活全屏模式，则设置为 true。 iframeAllowFullscreen: true ); PullToRefreshController? pullToRefreshController; String url = \u0026#34;\u0026#34;; double progress = 0; final urlController = TextEditingController(); @override void initState() { super.initState(); // 在 WebView 中开启下拉刷新 pullToRefreshController = kIsWeb ? null : PullToRefreshController( settings: PullToRefreshSettings( color: Colors.blue, ), onRefresh: () async { if (defaultTargetPlatform == TargetPlatform.android) { webViewController?.reload(); } else if (defaultTargetPlatform == TargetPlatform.iOS) { webViewController?.loadUrl( urlRequest: URLRequest(url: await webViewController?.getUrl())); } }, ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text(\u0026#34;Official InAppWebView website\u0026#34;)), body: SafeArea( child: Column(children: \u0026lt;Widget\u0026gt;[ TextField( decoration: const InputDecoration(prefixIcon: Icon(Icons.search)), controller: urlController, keyboardType: TextInputType.url, onSubmitted: (value) { var url = WebUri(value); if (url.scheme.isEmpty) { url = WebUri(\u0026#34;https://www.google.com/search?q=$value\u0026#34;); } webViewController?.loadUrl(urlRequest: URLRequest(url: url)); }, ), Expanded( child: Stack( children: [ InAppWebView( key: webViewKey, // 初始化URL initialUrlRequest: URLRequest(url: WebUri(\u0026#34;https://inappwebview.dev/\u0026#34;)), // 初始化设置 initialSettings: settings, // 下拉刷新 pullToRefreshController: pullToRefreshController, // 创建 WebView 时触发的事件 onWebViewCreated: (controller) { webViewController = controller; }, // 当 WebView 开始加载 url 时触发的事件。 onLoadStart: (controller, url) { setState(() { this.url = url.toString(); urlController.text = this.url; }); }, // 请求无访问权限资源 时触发的事件。 onPermissionRequest: (controller, request) async { return PermissionResponse( resources: request.resources, action: PermissionResponseAction.GRANT); }, // 让APP有机会在 URL即将加载 时进行控制。 shouldOverrideUrlLoading: (controller, navigationAction) async { var uri = navigationAction.request.url!; if (![ \u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;, \u0026#34;file\u0026#34;, \u0026#34;chrome\u0026#34;, \u0026#34;data\u0026#34;, \u0026#34;javascript\u0026#34;, \u0026#34;about\u0026#34; ].contains(uri.scheme)) { if (await canLaunchUrl(uri)) { // Launch the App await launchUrl( uri, ); // and cancel the request return NavigationActionPolicy.CANCEL; } } return NavigationActionPolicy.ALLOW; }, // 完成加载 url 时触发的事件。 onLoadStop: (controller, url) async { pullToRefreshController?.endRefreshing(); setState(() { this.url = url.toString(); urlController.text = this.url; }); }, // 加载请求时遇到错误 时触发的事件。 onReceivedError: (controller, request, error) { pullToRefreshController?.endRefreshing(); }, // 更改正在加载的页面 时触发的事件。 onProgressChanged: (controller, progress) { if (progress == 100) { pullToRefreshController?.endRefreshing(); } setState(() { this.progress = progress / 100; urlController.text = url; }); }, // APP更新其访问的链接 时触发的事件。 onUpdateVisitedHistory: (controller, url, androidIsReload) { setState(() { this.url = url.toString(); urlController.text = this.url; }); }, // WebView收到控制台报错 时触发的事件。 onConsoleMessage: (controller, consoleMessage) { if (kDebugMode) { print(consoleMessage); } }, ), // 进度指示器 progress \u0026lt; 1.0 ? LinearProgressIndicator(value: progress) : Container(), ], ), ), ButtonBar( alignment: MainAxisAlignment.center, children: \u0026lt;Widget\u0026gt;[ // 后退按钮 ElevatedButton( child: const Icon(Icons.arrow_back), onPressed: () { webViewController?.goBack(); }, ), // 前进按钮 ElevatedButton( child: const Icon(Icons.arrow_forward), onPressed: () { webViewController?.goForward(); }, ), // 刷新按钮 ElevatedButton( child: const Icon(Icons.refresh), onPressed: () { webViewController?.reload(); }, ), ], ), ]) ) ); } } FlexColorPicker FlexColorPicker 是 Fl​​utter 的可定制颜色选择器。可以使用 Material 2 和 Material 3。\n// 属性 ColorPicker( color: selectedColor, // 启用tab栏选择器:both, primary, accent, bw, custom, wheel pickersEnabled: const \u0026lt;ColorPickerType, bool\u0026gt;{ ColorPickerType.both: true, ColorPickerType.primary: false, ColorPickerType.accent: false, ColorPickerType.bw: false, ColorPickerType.custom: false, ColorPickerType.wheel: true, }, // 自定义颜色 // customColorSwatchesAndNames: customSwatches, // 定制tab标签 pickerTypeLabels: \u0026lt;ColorPickerType, String\u0026gt;{ ColorPickerType.both: \u0026#39;preset\u0026#39;.tr, ColorPickerType.wheel: \u0026#39;custom\u0026#39;.tr, }, // 在选择主要颜色后，基于所选颜色为您提供一组它的深浅颜色,禁用时才需要此属性 // enableShadesSelection:false, // 生成所选颜色的 15 种色调的 Material 3 色调调色板 enableTonalPalette: true, // 颜色不透明度滑块 enableOpacity: true, // 显示所选颜色名称 showMaterialName: true, materialNameTextStyle: Theme.of(context).textTheme.bodySmall, showColorName: true, colorNameTextStyle: Theme.of(context).textTheme.bodySmall, // 显示所选颜色的 RGB 颜色值 showColorCode: true, // colorCodeHasColor: true, // showColorValue: true, colorCodeTextStyle: Theme.of(context).textTheme.bodyMedium, colorCodePrefixStyle: Theme.of(context).textTheme.bodySmall, // 显示最近选择的颜色 // showRecentColors: true, // maxRecentColors: 8, // recentColors: , // onRecentColorsChanged: , // 标题 title: Text( \u0026#39;ColorPicker\u0026#39;, style: Theme.of(context).textTheme.headline6, ), heading: Text( \u0026#39;Select color\u0026#39;, style: Theme.of(context).textTheme.headline5, ), subheading: Text( \u0026#39;Select color shade\u0026#39;, style: Theme.of(context).textTheme.headline1, ), wheelSubheading: Text( \u0026#39;Selected color and its shades\u0026#39;, style: Theme.of(context).textTheme.headline1, ), opacitySubheading: Text( \u0026#39;Opacity\u0026#39;, style: Theme.of(context).textTheme.headline1, ), recentColorsSubheading: Text( \u0026#39;Selected color and its color swatch\u0026#39;, style: Theme.of(context).textTheme.headline1, ), // 各个颜色小部件的大小、形状和间距以及色轮和不透明度滑块大小的属性。 width: 40, height: 40, borderRadius: 4, spacing: 5, runSpacing: 5, hasBorder: false, // borderColor: Theme.of(context).dividerColor, elevation: 0, // 轮盘直径、宽度和边框 wheelDiameter: 155, wheelWidth: 16, wheelHasBorder: false, // borderColor: Theme.of(context).dividerColor, // 颜色元素的间距、对齐方式和填充 crossAxisAlignment: CrossAxisAlignment.center, padding: const EdgeInsets.all(16), columnSpacing: 0, // 复制按钮,确定按钮,取消按钮,关闭按钮 enableTooltips: ture, // Dialog“确定”和“取消”操作按钮以及样式 actionButtons: const ColorPickerActionButtons(...), // 颜色的复制粘贴行为 copyPasteBehavior: const ColorPickerCopyPasteBehavior( // 颜色代码后缀复制按钮 editFieldCopyButton: ture, // 键盘快捷键 ctrlC: ture, ctrlV: ture, // 工具栏按钮 copyButton: ture, copyIcon: ture, copyTooltip: MaterialLocalizations.of(context).copyButtonLabel, pasteButton: ture, pasteIcon: ture, pasteTooltip: MaterialLocalizations.of(context).pasteButtonLabel, // 从选取器复制颜色并将颜色粘贴 longPressMenu: ture, secondaryMenu: ture, secondaryOnDesktopLongOnDevice: ture, // 颜色代码格式和粘贴解析 copyFormat: ColorPickerCopyFormat.dartCode， parseShortHexCode: ture, editUsesParsedPaste: ture, snackBarParseError: ture, snackBarMessage: ture, snackBarDuration: const Duration(milliseconds: 1800), feedbackParseError: false, ), // 回调 // 当选择具有所选新颜色值的新颜色时调用 onColorChanged: (Color color) { selectedColor = color; }, // 开始颜色选择时调用 onColorChangeStart: , // 结束颜色选择时调用 onColorChangeEnd: , // 返回最近选择的颜色的当前列表 onRecentColorsChanged: , ), // dialog方法： // 在对话框打开时跟踪 ColorPicker 的不同onChange回调 ColorPicker(...).showPickerDialog; // dialog函数： // 只需传入对话框的构建上下文以及所需的起始颜色值，并等待它在对话框关闭时返回选定的颜色 showColorPickerDialog(...) Widgetbook(仅作了解) 使用Widgetbook可以管理组件、使用不同设备尺寸测试组件、实时修改组件参数、协作共享。\nWindows配置 确保安装Visual Studio，及其应用： 从https://www.nuget.org/downloads下载最新的nuget.exe,并放入任意文件夹（我的在C:\\Program Files\\Microsoft Visual Studio），配置系统环境变量。\n使用 在pubspec.yaml安装 widgetbook 组件 注意是放在 dev_dependencies 下面\ndev_dependencies: flutter_test: sdk: flutter flutter_lints: ^2.0.0 widgetbook: ^3.0.0-beta.14 新建lib/app.widgetbook.dart import \u0026#39;package:flutter/material.dart\u0026#39;; // ignore: depend_on_referenced_packages import \u0026#39;package:widgetbook/widgetbook.dart\u0026#39;; import \u0026#39;你的组件\u0026#39;; void main() { runApp(const HotReload()); } class HotReload extends StatelessWidget { const HotReload({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return Widgetbook.material( // Widgetbook 属性选择 addons: [ // 主题 // buildMaterialThemeAddon(), // 字体大小 // buildTextScaleAddon(), ], // 可以容纳包、文件夹、类别、组件和用例 directories: [ // buildWidgetbookCategory(), // //buildWidgetbookCategory2(), ], ); } TextScaleAddon buildTextScaleAddon() { return TextScaleAddon( setting: TextScaleSetting.firstAsSelected( textScales: [1.0, 1.25, 1.5, 1.75, 2])); } MaterialThemeAddon buildMaterialThemeAddon() { return MaterialThemeAddon( setting: MaterialThemeSetting.firstAsSelected(themes: [ WidgetbookTheme(name: \u0026#34;dark\u0026#34;, data: ThemeData.dark()), WidgetbookTheme(name: \u0026#34;light\u0026#34;, data: ThemeData.light()), ])); } WidgetbookCategory buildWidgetbookCategory() { return WidgetbookCategory( // 分类名 name: \u0026#39;公共组件\u0026#39;, children: [ WidgetbookComponent( // 组件名 name: \u0026#39;Spinkit加载\u0026#39;, useCases: [ WidgetbookUseCase.center( // 组件用例名 name: \u0026#34;SpinKitFadingCircle\u0026#34;, child: mySpinkit(), ), ], ), ], ); } } Plugin Flutter Plugin是可以插入到主程序中，扩展功能的独立组件，我们实现原生平台的功能就需要用到。\n创建\n使用 Android Studio 创建 Flutter 项目，项目类型选 plugin 。目录如下\nproject ├── android // 原生 ├── example // 运行调试 ├── ios // 原生 ├── lib Flutter Channel Flutter有三种类型的Channel:\nBasicMessageChannel:用于传递字符串和半结构化的信息。持续通信，收到消息后可以回复此次消息，如：Native将遍历到的文件信息陆续传递到Dart。 MethodChannel:用于传递方法调用(method invocation)。一次性通信：如Flutteri调用Native拍照； EventChannel:用于数据流(event streams)的通信。持续通信，收到消息后无法回复此次消息，通过长用于Native向Dat的通信，如：手机电量变化，网络连接变化，陀螺仪，传感器等； Channel支持的数据类型：\nDart Android ios null null nil (NSNull when nested) bool java.lang.Boolean NSNumber numberWithBool: int java.lang.Integer NSNumber numberWithInt: int, if 32 bits notenough java.lang.Long NSNumber numberWithLong: double java.lang.Double NSNumber numberWithDouble: String java.lang.String NSString Uint8List byte[] FlutterStandardTypedData typedDataWithBytes: Int32List int][] FlutterStandardTypedData typedDataWithInt32: Int64List long[] FlutterStandardTypedData typedDataWithInt64: Float64List double[] FlutterStandardTypedData typedDataWithFloat64: List java.util.ArrayList NSArray Map java.util.HashMap NSDictionary 手动创建Channel 创建Channel\n三种Channel 的构造十分相似：\n// 传递字符串、JSON BasicMessageChannel(BinaryMessenger messenger,String name,MessageCodec\u0026lt;T\u0026gt; codec) // 方法调用 // MethodChannel只是对 BasicMessageChannel封装，方便直接获取函数名和参数 MethodChannel(BinaryMessenger messenger,String name,MethodCodec codec) // 事件流监听，包括用户事件监听，电量变化，网络连接变化，陀螺仪，传感器等 EventChannel(BinaryMessenger messenger,String name,MethodCodec codec) BinaryMessenger messenger 消息的发送与接收的工具； String name Channel的名字； MessageCodec\u0026lt;T\u0026gt; codec 消息的编解码器，它有几种不同类型的实现： BinaryCodec 最为简单的一种Codec,因为其返回值类型和入参的类型相同，均为二进制格式(Android中为ByteBuffer,.iS中为NSData)。实际上，BinaryCodec在编解码过程中什么都没做，只是原封不动将二进制数据消息返回而已。或许你会因此觉得BinaryCodec没有意义，但是在某些情况下它非常有用，比如使用BinaryCodec可以使传递内存数据块时在编解码阶段免于内存拷贝； StringCodec 用于字符串与二进制数据之间的编解码，其编码格式为UTF-8; JSONMessageCodec 用于基础数据与二进制数据之间的编解码，其支持基础数据类型以及列表、字典。其在iOS端使用了NSJSONSerialization作为序列化的工具，而在Android端则使用了其自定义的JSONUtil.与StringCodec作为序列化工具； StandardMessageCodec 是BasicMessageChannel的默认编解码器，其支持基础数据类型、二进制数据、列表、字典。比JSONMessageCodec更通用。 接收/发送消息 接收Dart发来的消息：\n// BasicMessageChannel setMessageHandler(MessageHandler\u0026lt;T\u0026gt; handler) // MethodChannel setMethodCallHandler(MethodCallHandler handler) // EventChannel void setstreamHandler(EventChannel.StreamHandler handler) 其参数：\n// BasicMessageChannel // var1 是消息内容 // var2 是回复此消息的回调函数 public interface MessageHandler\u0026lt;T\u0026gt; { void onMessage(T var1, BasicMessageChannel.Reply\u0026lt;T\u0026gt; var2); } // MethodChannel // var1.methed 表示 var1方法名的String // var1.arguments 表示 var1方法的参数 // var2：提供 var2.success、 var2.error、 var2.notImplemented 三种回复 public interface MethodCallHandler { void onMethodCall(MethodCall var1,Result var2); } // EventChannel // args 是传递的参数 // eventSink 提供 success、error、endOfStream 三个回调方法 // onCancel 取消监听时调用 public interface StreamHandler { void onListen(Object args,EventChannel.Eventsink eventsink); void onCancel(Object o); } 向dart发送消息：\nvoid send(T message) // dart不回复 void send(T message,BasicMessageChannel.Reply\u0026lt;T\u0026gt; callback) //dart回复 pigeon生成channel 新建flutter_plugin项目，删除flutter_plugin/lib下所有自带代码\npubspec.yaml添加依赖\ndev_dependencies: pigeon: ^16.0.5 编写pigeon配置文件，定义通信接口 lib同级目录创建一个pigeons文件夹，新建input_message.dart文件\n// ignore_for_file: public_member_api_docs, sort_constructors_first import \u0026#39;package:pigeon/pigeon.dart\u0026#39;; // 输出配置 // https://github.com/flutter/packages/blob/main/packages/pigeon/example/README.md @ConfigurePigeon(PigeonOptions( // dart输出位置 dartOut: \u0026#39;./lib/pigeon/message.dart\u0026#39;, // Android输出位置 javaOut: \u0026#39;android/src/main/java/com/example/flutter_plugin/pigeon/Messages.java\u0026#39;, javaOptions: JavaOptions( // 包名 package: \u0026#39;com.example.flutter_plugin.pigeon\u0026#39;, ), // // ios输出位置 // // ios/flutter_pigeon_plugin.podspec -\u0026gt; s.source_files = \u0026#39;Classes/**/*\u0026#39; // objcHeaderOut: \u0026#39;ios/Classes/Pigeon.h\u0026#39;, // objcSourceOut: \u0026#39;ios/Classes/Pigeon.m\u0026#39;, // objcOptions: ObjcOptions( // // 默认前缀 // prefix: \u0026#39;FLT\u0026#39;, // ), )) // 请求参数类型 class SearchRequest { SearchRequest({required this.query}); String query; } // 返回参数类型 class SearchReply { SearchReply({required this.result}); String result; } // flutter 调用 native // @HostApi()：BasicMessageChannel、MethodChannel // @EventChannelApi()：EventChannel @HostApi() abstract class FlutterCallNativeApi { // @async：处理长时间运行的任务或从native异步接收数据 SearchReply search(SearchRequest request); } // native 调用 flutter @FlutterApi() abstract class NativeCallFlutterApi { SearchReply query(SearchRequest request); } 生成代码：\n项目目录下运行dart run pigeon --input pigeons/input_message.dart\n依赖：(不应添加)\n由于该项目作为 Flutter plugin加载，不能识别Android依赖，如果打开Android目录请在build.gradle添加以下依赖（仅作开发使用，妨碍构建）。\nandroid { def flutterRoot = \u0026#34;C:\\\\flutter\u0026#34; dependencies { compileOnly files(\u0026#34;$flutterRoot/bin/cache/artifacts/engine/android-arm/flutter.jar\u0026#34;) compileOnly \u0026#39;androidx.annotation:annotation:1.9.1\u0026#39; } } Android端具体实现 编辑Android目录下flutterPlugin.java\npackage com.example.flutterplugin; import android.content.Context; import android.widget.Toast; import androidx.annotation.NonNull; import com.example.flutterplugin.pigeon.Messages; import io.flutter.embedding.engine.plugins.FlutterPlugin; import io.flutter.plugin.common.MethodCall; import io.flutter.plugin.common.MethodChannel; import io.flutter.plugin.common.MethodChannel.MethodCallHandler; import io.flutter.plugin.common.MethodChannel.Result; // 1. 继承FlutterCallNativeApi /** FlutterPigeonPlugin */ public class FlutterPlugin implements FlutterPlugin, Messages.FlutterCallNativeApi { private Messages.NativeCallFlutterApi nativeApi; private Context context; @Override public void onAttachedToEngine(@NonNull FlutterPlugin.FlutterPluginBinding flutterPluginBinding) { context = flutterPluginBinding.getApplicationContext(); // 2. setup初始化FlutterCallNativeApi Messages.FlutterCallNativeApi.setUp(flutterPluginBinding.getBinaryMessenger(), this); nativeApi = new Messages.NativeCallFlutterApi(flutterPluginBinding.getBinaryMessenger()); } @Override public void onDetachedFromEngine(@NonNull FlutterPlugin.FlutterPluginBinding binding) { Messages.FlutterCallNativeApi.setUp(binding.getBinaryMessenger(), null); } // 3. 自定义具体search方法 // flutter调用native @Override public Messages.SearchReply search(Messages.SearchRequest arg) { Messages.SearchReply reply = new Messages.SearchReply.Builder() .setResult(arg.getQuery() + \u0026#34;-nativeResult\u0026#34;) .build(); // native调用flutter nativeApi.query(arg, new Messages.Result\u0026lt;Messages.SearchReply\u0026gt;() { @Override public void success(Messages.SearchReply result) { Toast.makeText(context, result.getResult(), Toast.LENGTH_SHORT).show(); } @Override public void error(Throwable error) { // 处理错误 } }); return reply; } } flutter example 添加pubspec.yaml\nplugin: platforms: android: package: com.example.flutter_flutterplugin pluginClass: FlutterPluginPlugin ios: pluginClass: FlutterPluginPlugin linux: pluginClass: FlutterPluginPlugin macos: pluginClass: FlutterPluginPlugin windows: pluginClass: FlutterPluginPluginCApi web: pluginClass: FlutterPluginWeb fileName: flutter_plugin_web.dart flutter调用channel\nimport \u0026#39;package:flutter_plugin/pigeon/message.dart\u0026#39;; import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;dart:async\u0026#39;; import \u0026#39;dart:developer\u0026#39; as developer; void main() { runApp(const MyApp()); } class MyApp extends StatefulWidget { const MyApp({super.key}); @override State\u0026lt;MyApp\u0026gt; createState() =\u0026gt; _MyAppState(); } class _MyAppState extends State\u0026lt;MyApp\u0026gt; { String _platformVersion = \u0026#39;Unknown\u0026#39;; FlutterCallNativeApi? _api; @override void initState() { super.initState(); _initApi(); } void _initApi() { try { _api = FlutterCallNativeApi(); developer.log(\u0026#39;API initialized successfully\u0026#39;); } catch (e) { developer.log(\u0026#39;Error initializing API: $e\u0026#39;, error: e); } } Future\u0026lt;void\u0026gt; getNativeResult() async { if (_api == null) { developer.log(\u0026#39;API not initialized\u0026#39;); return; } try { developer.log(\u0026#39;Calling native search method\u0026#39;); SearchRequest request = SearchRequest(query: \u0026#34;Zero\u0026#34;); SearchReply reply = await _api!.search(request); developer.log(\u0026#39;Received reply: ${reply.result}\u0026#39;); if (mounted) { setState(() { _platformVersion = reply.result; }); } } catch (e) { developer.log(\u0026#39;Error calling native method: $e\u0026#39;, error: e); if (mounted) { setState(() { _platformVersion = \u0026#39;Error: $e\u0026#39;; }); } } } @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: AppBar( title: const Text(\u0026#39;Plugin example app\u0026#39;), ), body: Center( child: Column( children: [ Text(\u0026#39;Running on: $_platformVersion\\n\u0026#39;), MaterialButton( height: 40, color: Colors.blue, textColor: Colors.white, elevation: 5, splashColor: Colors.teal, padding: const EdgeInsets.all(8), child: const Text(\u0026#34;点击调用 native\u0026#34;), onPressed: () =\u0026gt; getNativeResult()) ], ), ), ), ); } } 常用 API： FlutterPluginBinding: 向所有 FlutterEngine 注册的插件提供可用的资源。\nActivityPluginBinding : 绑定使ActivityAware插件可以访问关联的Activity和Activity的生命周期方法。\nActivityAware: FlutterPlugin 把 Activity生命周期事件 关联到 FlutterEngine中运行的Activity\nFlutterView: 在 Android 设备上显示 Flutter UI\nNotificationManager：用于通知用户发生的事件\nResources: 用于访问应用程序资源的类。\nAndroid Java 访问修饰符 访问范围 private default protected public 同一类中 √ √ √ √ 同一包中(子类和非子类) × √ √ √ 不同包中的子类 × × √ √ 不同包中的非子类 × × × √ 多线程 进程和线程 进程\n进程就是运行的程序，是受操作系统管理的独立单元。例如Windows任务管理器中的exe Binder/Socket用于进程间通信 线程\n线程是操作系统调度的最小单元，在一个进程中可以创建多个线程，有的加载网页，有的处理缓存，有的进行下载 概念 定义 作用 主线程(UI thread) 当应用程序启动时，会自动开启1条主线程 处理与UI相关的事件(如更新、操作等) 子线程 (工作线程) 人为手动开启的线程 执行耗时操作(如网络请求、数据加载等) 消息 (Message) 线程间通讯的数据单元 (即Handler接受\u0026amp;处理的消息对象) 存储需操作的通信信息 消息队列 (Message Queue) 一种数据结构(存储特点：先进先出) 存储Handler发送过来的消息(Message) 处理者 (Handler) 主线程与子线程的通信媒介线程消息的主要处理者 * 添加消息(Message)到消息队列(Message Queue) * 处理循环器(Looper)分派过来的消息(Message) 循环器 (Looper) 消息队列(Message Queue)与处理者(Handler)的通信媒介 每个线程中只能拥有1个Looper，多个线程可往1个Looper所持有的MessageQueue 中发送消息，提供了线程间通信的可能 * 消息获取：循环取出消息队列(Message Queue)的消息(Message) * 消息分发：将取出的消息(Message)发送给对应的处理者(Handler) View.post() View类中的方法，适用于任何View对象 * 将Runnable对象添加到View的事件队列中 * 获取View的宽高等属性值 ThreadLocal 提供线程本地变量 ThreadLocal为每一个线程开辟了一个独立的存储器，只有对应的线程才能够访问其数据 runOnUiThread() Activity类中的方法，仅适用于Activity 将Runnable对象添加到Activity的事件队列中，可以确保其在当前主线程中执行 线程的状态 使用 继承 Thread 类 // 1.继承Thread类 class MyThread extends Thread{ // 2.复写run @Override public void run(){ // 线程具体任务 System.out.println(＂Hello World＂)； } } // 3.实例化线程 MyThread mt=new MyThread(“线程名称”); // 4.启动线程 mt.start(); 实现 Runnable 接口 // 1.实现 Runnable 接口 public class TestRunnable implements Runnable { // 2.复写run public void run() { // 线程具体任务 System.out.println(＂Hello World＂)； } } // 3.创建Runnable对象 MyThread mt=new MyThread(); // 4.Runnable作为参数实例化线程 Thread td=new Thread(mt); // 5.启动线程 td.start(); 同步 多个线程需要共享同一个数据的存取，但同时使用同一个资源会造成冲突。\nsynchronized 关键字自动提供了锁,如果一个方法用 synchronized 关键字声明，那么对象的锁将保护整个方法。\npublic synchronized void method(){ } 例：支付宝转账\npublic synchronized void transfer(int from,int to,int amount) throws InterruptedException{ // 锁中的条件管理其它调用的线程。 while (accounts[from]＜amount) { wait()； } // 转账的操作 accounts[from]=accounts[from]-amount； accounts[to]=accounts[to]+amount； notifyAll()； } 线程通信 Handler\nHandler用于同进程的线程间通信 子线程运行并生成Message，Looper获取message并传递给Handler，Handler逐个获取子线程中的Message 有Handler.sendMessage()、Handler.post()两种使用方法 如果有多个任务同时执行时则会显得代码臃肿。Android 提供了 AsyncTask，使异步任务更简洁 AsyncTask\n// 1.继承AsyncTask类。 // 为3个泛型参数指定类型；若不使用，可用java.lang.Void类型代替 private class MyTask extends AsyncTask\u0026lt;Params, Progress, Result\u0026gt; { // 执行线程任务前的操作（可选） @Override protected void onPreExecute() { ... } // 执行任务中的耗时操作（必须） @Override protected String doInBackground(String... params) { // 自定义的线程任务 ... // 可调用publishProgress（）显示进度, 之后将执行onProgressUpdate（） publishProgress(count); } // 在主线程 显示线程任务执行的进度（可选） @Override protected void onProgressUpdate(Integer... progresses) { ... } // 将执行结果显示到UI组件（必须） @Override protected void onPostExecute(String result) { // UI操作 ... } // 将异步任务设置为：取消状态 @Override protected void onCancelled() { ... } } // 2.创建AsyncTask子类的实例对象 MyTask mTask = new MyTask(); // 3.手动调用execute(Params... params) 执行异步线程任务 mTask.execute()； 生命周期 View的生命周期方法\n英文原表\n类别 方法 描述 创建 构造函数 构造函数有两种形式，一种是在通过代码创建视图时调用的，另一种是在通过布局文件填充视图时调用的。第二种形式解析并应用布局文件中定义的属性。 onFinishInflate() 在视图及其所有子视图都从 XML 中映射后调用。 布局 onMeasure(int, int) 调用来确定此视图及其所有子视图的尺寸要求。 onLayout(boolean, int, int, int, int) 当此视图必须为其所有子视图分配大小和位置时调用。 onSizeChanged(int, int, int, int) 当此视图的大小改变时调用。 绘画 onDraw(Canvas) 当视图必须呈现其内容时调用。 事件处理 onKeyDown(int, KeyEvent) 当发生按键事件时调用。 onKeyUp(int, KeyEvent) 当发生按键释放事件时调用。 onTrackballEvent(MotionEvent) 当轨迹球运动事件发生时调用。 onTouchEvent(MotionEvent) 当发生触摸屏运动事件时调用。 焦点 onFocusChanged(boolean, int, Rect) 当视图获得或失去焦点时调用。 onWindowFocusChanged(boolean) 当包含视图的窗口获得或失去焦点时调用。 附加 onAttachedToWindow() 当视图附加到窗口时调用。 onDetachedFromWindow() 当视图与其窗口分离时调用。 onWindowVisibilityChanged(int) 当包含视图的窗口的可见性发生改变时调用。 Activity生命周期\nActivity的启动\nActivity 调用onCreate方法，将资源 ID R.layout.main_activity 更改为 setContentView() Activity 调用onWindowAttributesChanged 方法，而且这个方法连续调用多次 View 调用构造方法 View 调用onFinishInflate方法，说明这个时候View已经填充完毕，但是还没开始触发绘制过程 Activity 调用onstart方法， 进入“已启动”状态 Activity 再次调用 onWindowAttributesChanged 方法 Activity 调用onResume，“已恢复”状态，进行后面初始化步骤，并进入与用户互动的状态 Activity 调用onAttachedToWindow，Activity跟Window进行绑定 View 调用onAttachedToWindow，View跟Window进行绑定 View 调用 onWindowVisibilityChanged(int visibility)，参数变为 View.VISIABLE View 调用onMeasure，开始测量 View 调用onSizeChanged，表示测量完成，尺寸发生了变化 View 调用onLayout，开始摆放位置 View 调用 onDraw，开始绘制 Activity 调用onWindowFocusChanged(boolean hasFocus)，此时为true，代表窗体已经获取了焦点 View 调用 onWindowFocusChanged(boolean hasWindowFocus)，此时为true，代表当前的控件获取了Window焦点，当调用这个方法后说明当前Activity中的View才是真正的可见了 Activity的退出\nActivity 调用 onPause，中断时的暂停状态 View 调用 onWindowVisibilityChanged(int visibility)，参数变为 View.GONE，View中对应的Window隐藏 Activity 调用onWindowFocusChanged(boolean hasFocus)，此时为false，说明Actvity所在的Window已经失去焦点 Activity 调用 onStop，此时Activity已经切换到后台 Activity 调用 onDestory，此时Activity开始准备销毁，实际上并不代表Activity已经销毁 View 调用 onDetachedFromWindow，此时View 与Window解除绑定 Activity 调用 onDetathedFromWindow ，此时Activity 与Window 解除绑定 View即将被销毁，可以在 onDetachedFromWindow 方法中做一些资源释放，防止内存泄漏 android四大组件 activity\n每个 Activity 提供一个用户界面窗口，一个app 由多个Activity 组成，其中一个主 Activity为程序入口。\n应用窗口（TYPE_APPLICATION）：Activity 的默认窗口，层级最低。 子窗口（TYPE_APPLICATION_PANEL）：依附于应用窗口（如 Dialog）。 系统窗口（TYPE_TOAST）：无需 Activity 承载，直接由系统管理（如 Toast、悬浮窗）。 Activity通过 Intent 和 Bundle 实现数据传递。\n每一个Activity都必须要在AndroidManifest.xml配置。\nservice\nService通常位于后台运行，没有UI。\nservice分为两种\nstarted（启动）：由其他组件调用startService()方法启动，可以在后台无限期运行，调用stopSelf()或由其他组件调用stopService()方法才会停止。 bound（绑定）：调用bindService()者与服务绑定在了一起，调用者一旦退出，服务也就终止。 必须在AndroidManifest.xml配置\u0026lt;service android:name=\u0026quot;.ExampleService\u0026quot;/\u0026gt;\ncontent provider\nAndroid 系统为常见数据类型（如视频、音频、图像、电话簿等）提供了 ContentProvider 接口，用于应用程序之间共享数据。\n通过 URI 标识数据资源，并通过 ContentResolver 提供对数据的 CRUD 操作。\nbroadcast receiver\n事件触发：当特定事件发生时（如来电、短信、电池电量变化等），Android系统会生成特定的Intent对象并自动进行广播。 接收处理：针对特定事件注册的BroadcastReceiver会接收到这些广播，并获取Intent对象中的数据进行处理。 动态注册 静态注册：AndroidManifest文件 builder模式 当一个对象有很多属性，比如用户对象有很多属性：用户名、ID、性别、地址、工作类型、联系方式等等，写多个构造方法和set、get将难以阅读维护，我们可以采用java链式调用这种更优雅的方式。\npublic class User { private final String name; private int age; private String address; private User(Builder builder) { // 初始化变量 this.name = builder.name; this.age = builder.age; this.address = builder.address; } static class Builder { // 与外部User类属性一致 private final String name; private int age; private String address; // 必填属性 public Builder(String name) { this.name = name; } // 可选属性 public Builder Age(int age) { this.age = age; return this; } // 可选属性 public Builder Address(String address) { this.address = address; return this; } // 提供外部类实例对象 public User build() { // 合理性做判断 if (age \u0026lt;= 0) { throw new RuntimeException(\u0026#34;年龄不合法\u0026#34;); } return new User(this); } } } //使用 User user = new User.Builder(\u0026#34;UserName\u0026#34;) .Age(18) .Address(\u0026#34;China\u0026#34;) .build(); 另外，可以使用IDE中的插件InnerBuilder生成代码。\n// 在类中右键Generate选择Builder public class User { private final String name; private int age; private String address; } AndroidManifest.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; \u0026lt;!-- 应用的包名、版本 --\u0026gt; package=\u0026#34;com.example.app\u0026#34; android:versionCode=\u0026#34;1\u0026#34; android:versionName=\u0026#34;1.0.1\u0026#34;\u0026gt; \u0026lt;!-- 权限设置 ---\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34;/\u0026gt; \u0026lt;!---访问网络\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34;/\u0026gt; \u0026lt;!---网络连接是否有效\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34;/\u0026gt; \u0026lt;!--读写外部存储器\u0026gt; \u0026lt;application \u0026lt;!---参考：https://juejin.cn/post/7006296858494500877--\u0026gt; android:allowBackup=\u0026#34;true\u0026#34; \u0026lt;!---允许app数据备份--\u0026gt; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; \u0026lt;!--图标--\u0026gt; android:label=\u0026#34;@string/app_name\u0026#34; \u0026lt;!--标题--\u0026gt; android:name=\u0026#34;.App\u0026#34; \u0026lt;!--应用程序开始的类名--\u0026gt; android:theme=\u0026#34;@style/AppTheme\u0026#34; \u0026gt; \u0026lt;!--主题--\u0026gt; \u0026lt;activity android:name=\u0026#34;.ui.activities.MainActivity\u0026#34; \u0026lt;!--activity名称--\u0026gt; android:screenOrientation=\u0026#34;portrait\u0026#34; \u0026lt;!--限制此页为竖屏显示--\u0026gt; android:label=\u0026#34;@string/app_name\u0026#34; \u0026gt; \u0026lt;!--标签名称--\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;!--Main point--\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;!--启动时有效--\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;activity android:name=\u0026#34;.ui.activities.LoginActivity\u0026#34; android:screenOrientation=\u0026#34;portrait\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; \u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;service android:name=\u0026#34;com.csr.csrmesh2.MeshService\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;false\u0026#34; \u0026gt; \u0026lt;!--禁止此服务被其他组件调用和交互--\u0026gt; \u0026lt;/service\u0026gt; \u0026lt;receiver android:name=\u0026#34;.events.ConnectionChangeReceiver\u0026#34; android:label=\u0026#34;ConnectionChangeReceiver\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.net.conn.CONNECTIVITY_CHANGE\u0026#34; /\u0026gt; \u0026lt;!--网络连接发生变化--\u0026gt; \u0026lt;!-- \u0026lt;action android:name=\u0026#34;android.net.wifi.WIFI_STATE_CHANGED\u0026#34; /\u0026gt;--\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; \u0026lt;!--组件相关配置--\u0026gt; \u0026lt;meta-data android:name=\u0026#34;com.facebook.sdk.ApplicationId\u0026#34; android:value=\u0026#34;@string/facebook_app_id\u0026#34;/\u0026gt; \u0026lt;meta-data android:name=\u0026#34;com.facebook.sdk.ApplicationName\u0026#34; android:value=\u0026#34;@string/app_name\u0026#34; /\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 常用权限（查看权限大全）\n\u0026lt;!--网络--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_WIFI_STATE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.CHANGE_WIFI_STATE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.MODIFY_AUDIO_SETTINGS\u0026#34; /\u0026gt; \u0026lt;!--文件读写--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_EXTERNAL_STORAGE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34; /\u0026gt; \u0026lt;!--录音机--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.RECORD_AUDIO\u0026#34; /\u0026gt; \u0026lt;!--读取手机状态，获取IMEI --\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_PHONE_STATE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.MANAGE_EXTERNAL_STORAGE\u0026#34;/\u0026gt; \u0026lt;!--蓝牙--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.BLUETOOTH\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.BLUETOOTH_ADMIN\u0026#34; /\u0026gt; \u0026lt;!--相机，及硬件支持--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.CAMERA\u0026#34; /\u0026gt; \u0026lt;uses-feature android:name=\u0026#34;android.hardware.camera\u0026#34; /\u0026gt; \u0026lt;uses-feature android:name=\u0026#34;android.hardware.camera.autofocus\u0026#34; /\u0026gt; \u0026lt;!--接收彩信--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.RECEIVE_MMS\u0026#34; /\u0026gt; \u0026lt;!--访问GMail账户列表--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.GET_ACCOUNTS\u0026#34; /\u0026gt; \u0026lt;!--精确位置、粗略位置--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_FINE_LOCATION\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; /\u0026gt; \u0026lt;!--通知，Android13以上--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.POST_NOTIFICATIONS\u0026#34; /\u0026gt; \u0026lt;!--以下不太常用--\u0026gt; \u0026lt;!--读写日历--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_CALENDAR\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_CALENDAR\u0026#34; /\u0026gt; \u0026lt;!--读写通讯录--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_CONTACTS\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_CONTACTS\u0026#34; /\u0026gt; \u0026lt;!--读取电话号码--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_PHONE_STATE\u0026#34; android:maxSdkVersion=\u0026#34;29\u0026#34; /\u0026gt; \u0026lt;!--Android11以上--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_PHONE_NUMBERS\u0026#34; /\u0026gt; \u0026lt;!--获取传感器（心率等）信息--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.BODY_SENSORS\u0026#34; /\u0026gt; \u0026lt;!--收发短信--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.RECEIVE_SMS\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.SEND_SMS\u0026#34; /\u0026gt; \u0026lt;!--悬浮窗、在其他应用上显示--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.SYSTEM_ALERT_WINDOW\u0026#34; /\u0026gt; 存储权限（Android 10 版本引入了分区存储机制）\n参考\nXML视图 常见属性\ngravity属性值 说明 top 不改变控件大小，对齐到容器顶部 bottom 不改变控件大小，对齐到容器底部 left 不改变控件大小，对齐到容器左侧 right 不改变控件大小，对齐到容器右侧 center_vertical 不改变控件大小，对齐到容器纵向中央位置 center_horizontal 不改变控件大小，对齐到容器横向中央位置 center 不改变控件大小，对齐到容器中央位置 fill_vertical 若有可能，纵向拉伸以填满容器 fill_horizontal 若有可能，横向拉伸以填满容器 fill 若有可能，纵向横向同时拉伸填满容器 特殊属性\n使用SVG 图片转SVG：AI打开图片 -\u0026gt; 点击图片 -\u0026gt; 右侧栏图像描摹 -\u0026gt; 下拉框素描图稿 -\u0026gt; 导出为SVG\nSVG转Android xml：右键drawable -\u0026gt; New -\u0026gt; Vector Asset -\u0026gt; Local file\n用在 ImageView ：\n\u0026lt;ImageView android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:src=\u0026#34;@drawable/ic_arrow\u0026#34;/\u0026gt; 作为背景：\n\u0026lt;View android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:background=\u0026#34;@drawable/ic_arrow\u0026#34; /\u0026gt; 作为自定义 View 使用 override fun onDraw(canvas: Canvas?) { super.onDraw(canvas) ArrowSvgObject.getDrawable( canvas, viewRect.width(), viewRect.height() ) } 作为 Drawable 使用 val icon = ArrowSvgObject.getDrawable(size) imageView.setImageDrawable(icon) 作为 Icon Tinting 使用 val blueTintedIcon = ArrowSvgObject.getTintedDrawable(size, Color.BLUE) 调试 VS Code debug 参考\n运行前提\n当前编程语言环境 当前编程语言用于调试的扩展，例如Java Extension Pack 配置文件launch.json 按钮介绍\n继续：跳到下一个断点\n单步跳过：跳过当前语句（调用其他文件夹的所有语句），运行下一行\n单步调试：进入当前函数内，运行下一行\n单步跳出：当debug陷入某个循环时，跳出循环并执行循环外的语句\n重启\n配置文件\nlaunch.json是用于调试的配置文件，位于.vscode文件夹，大多数情况下会自动创建，也可以在左侧边栏Run and Debug点击create a launch.json file launch.json注释（无需了解）\r\u0026#34;configurations\u0026#34;: [ { // 正在调试的项目名称（左侧边栏下拉菜单） \u0026#34;name\u0026#34;: \u0026#34;flutter_project\u0026#34;, // 指定调试模式 // launch模式：支持断点调试 // attach模式：支持对运行中的程序（多为远程服务器)断点调试，点击Add Configuration，选择Attach to Process \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, // 编程语言 \u0026#34;type\u0026#34;: \u0026#34;dart\u0026#34; }, ] 断点类型\n在代码行左侧断点出右键看到3种类型：\nAdd Breakpoint：在断点处阻塞程序 Add Conditional Breakpoint：在条件为true时断点生效 Add Logpoint：程序运行中，以非阻塞的方式，记录调试日志 Inline Breakpoint：当一行代码中有多个函数，光标定位在函数前，Run -\u0026gt; New Breakpoint -\u0026gt; Inline Breakpoint，断点在当前函数之前生效，点击单步调试可以进入当前函数 布局调试 参考\n模拟器 开启hyper-v\nWindows搜索 -\u0026gt; 启用与关闭Windows功能 -\u0026gt; hyper-v\n模拟器报错：找不到libandroid-emu-metrics.dll，重启hyper-v\nvscode连接第三方模拟器\n项目目录下执行：adb connect 127.0.0.1:[port]\nillustrator(AI)画图 Ai 设置：视图 -\u0026gt; 显示网格\n多边形变换：多边形工具 -\u0026gt; 自定义变换工具\n缩放：鼠标左键向右划放大、向左划缩小\n形状合成：选中区域 -\u0026gt; 形状生成器工具 -\u0026gt; 穿过需要的区域 -\u0026gt; 按住Alt穿过不要的区域\n渐变：双击圆圈弹出调色板\n动画 lottie需要用到Ae，rive是在线编辑。\n上架 包名 Android 是在 android ▸ app ▸ src ▸ main ▸ AndroidManifest.xml iOS 在 ios ▸ Runner ▸ Info.plist 应用名称 Android 是在 android ▸ app ▸ src ▸ main ▸ AndroidManifest.xml 中修改android:label=\u0026quot;XXX\u0026quot;; iOS 在 ios ▸ Runner ▸ Info.plist 中修改CFBundleName对应的Value 图标 Android 在android ▸ app ▸ src ▸ res ▸ mipmap-... 文件夹中替换相应图片 iOS 在 ios ▸ Runner ▸ Assets.xcassets ▸ AppIcon.appiconset文件夹中替换相应尺寸的图片， 如果使用不同的文件名，那还必须更新同一目录中的Contents.json文件。 启动图片 Android 在android ▸ app ▸ src ▸ res ▸ drawable ▸ launch_background.xml 通过自定义drawable来实现自定义启动界面。 iOS 在 ios ▸ Runner ▸ Assets.xcassets ▸ LaunchImage.imageset文件夹中替换相应尺寸的图片， 如果使用不同的文件名，那还必须更新同一目录中的Contents.json文件。 签名（安卓） 创建 android studio方法 以管理员身份运行 android studio -\u0026gt; 打开项目下的Android文件夹 -\u0026gt; Build -\u0026gt; Generate Signed Bundle / APK -\u0026gt; 选择 APK 点击 Next -\u0026gt; Create new\n命令行ketool方法（推荐） ketool容易修改密钥，参考Java8版官方文档或更多版本。\n使用：\n项目下的Android/app文件夹打开cmd\n// 创建keystore和密钥对 keytool -genkeypair -alias key -keyalg RSA -keysize 2048 -validity 10000 -keystore ./release.keystore.jks // 列出可用的证书别名（指定路径） keytool -list -v -keystore ./release.keystore.jks // 删除证书（指定别名、路径） keytool -delete -alias key -keystore ./release.keystore.jks 详细参数\r-genkeypair 生成密钥对（公钥和关联的私钥）。将该证书链和私钥存储在由alias标识的新密钥库条目中 -alias 别名，每个keystore都关联这一个独一无二的alias，这个alias通常不区分大小写 -keystore 密钥库位置 -keyalg 指定密钥的算法 (默认值：DSA) -keysize 指定密钥长度 （默认值取决于keyalg：RSA为2048，DSA为1024） -validity 指定创建的证书有效期多少天(默认 90) -storepass 指定密钥库的密码(获取keystore信息所需的密码) -keypass 指定别名条目的密码(私钥的密码) -dname 指定证书发行者信息 其中： “CN=名字与姓氏,OU=组织单位名称,O=组织名称,L=城市或区域名 称,ST=州或省份名称,C=单位的两字母国家代码” -list 显示密钥库中的证书信息 -export 将别名指定的证书导出到文件 keytool -export -alias 需要导出的别名 -keystore 指定keystore -file 指定导出的证书位置及证书名称 -storepass 密码 -file 参数指定导出到文件的文件名 -delete 删除密钥库中某条目 keytool -delete -alias 指定需删除的别 -keystore 指定keystore – storepass 密码 -printcert 查看导出的证书信息 keytool -printcert -file g:\\sso\\michael.crt -keypasswd 修改密钥库中指定条目口令 keytool -keypasswd -alias 需修改的别名 -keypass 旧密码 -new 新密码 -storepass keystore密码 -keystore sage -storepasswd 修改keystore口令 keytool -storepasswd -keystore g:\\sso\\michael.keystore(需修改口令的keystore) -storepass pwdold(原始密码) -new pwdnew(新密码) -import 将已签名数字证书导入密钥库 keytool -import -alias 指定导入条目的别名 -keystore 指定keystore -file 需导入的证书 中创建一个默认文件”.keystore”,还会产生一个mykey的别名，mykey中包含用户的公钥、私钥和证书(在没有指定生成位置的情况下,keystore会存在用户系统默认目录) 配置 为防止 build.gradle 协作时被修改、上线后反编译泄露，把密钥信息保存到 android/local.properties： storePassword=12345678 keyPassword=12345678 keyAlias=key storeFile=./release.keystore.jks local.properties默认不会被添加到Git提交到远程仓库。\n在android/app/build.gradle添加： // 读取 local.properties def mystoreFile = file(localProperties.getProperty(\u0026#39;storeFile\u0026#39;)) def mystorePassword = localProperties.getProperty(\u0026#39;storePassword\u0026#39;) def mykeyAlias = localProperties.getProperty(\u0026#39;keyAlias\u0026#39;) def mykeyPassword = localProperties.getProperty(\u0026#39;keyPassword\u0026#39;) // 签名配置 signingConfigs { release { keyAlias mykeyAlias keyPassword mykeyPassword storeFile mystoreFile storePassword mystorePassword } // // debug模式使用默认的 C:\\Users\u0026lt;用户名\u0026gt;.Android\\debug.keystore 进行签名，密码是 android // debug { // keyAlias \u0026#39;androiddebugkey\u0026#39; // keyPassword \u0026#39;android\u0026#39; // storeFile file(\u0026#39;C:\\\\Users\\\\90487\\\\.android\\\\debug.keystore\u0026#39;) // storePassword \u0026#39;android\u0026#39; // } } buildTypes { release { // TODO: Add your own signing config for the release build. // Signing with the debug keys for now, so `flutter run --release` works. signingConfig signingConfigs.release // // 混淆 // minifyEnabled false // // 混淆文件 // proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; } // debug { // signingConfig signingConfigs.debug // // // 包名后添加.debug，可以同时安装多个应用 // // applicationIdSuffix \u0026#39;.debug\u0026#39; // } } android studio验证配置：File -\u0026gt; Project Structure -\u0026gt; Modules -\u0026gt; Signing Configs\n参考：官方文档 buildTypes\n生成签名报告（可以获得md5） 点击右侧Gradle选项卡，android -\u0026gt; app -\u0026gt; Tasks -\u0026gt; android -\u0026gt; signingReport。\n如果 Gradle 面板目录中没有 signingReport 文件，进入设置项：File -\u0026gt; Settings -\u0026gt; Experimental -\u0026gt; 取消选中 Only include\u0026hellip;during Gradle Sync。然后同步一下：File -\u0026gt; Sync Project with Gradle Files。\n编译 apk 项目根目录下执行\nflutter build apk --split-per-abi bundles（google 平台需要 bundle 文件格式） 项目根目录下执行\nflutter build appbundle 输出 build/app/outputs/bundle/release/app-release.aab\n其他 double width = MediaQuery.of(context).size.width; 屏幕宽度\ndouble height = MediaQuery.of(context).size.height; 屏幕高度\n","date":"2022-04-30T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/flutter/","title":"flutter基础"},{"content":"root 前言：\n使用虚拟机 VMOS Pro，可以拥有大多应用权限，不必刷机。不同手机不同操作，刷机有变砖风险！\n步骤：\n解bl锁 各品牌手机解锁有所不同，三星、小米、一加、Google pixel等部分厂商官方给解锁。\n解锁困难的华为旧机：我用的是github的potatoNV短接解锁，如果其中没有你的手机，直接淘宝不要浪费时间。作者在youtube有教程，照做就好了（视频简介的USB com 1.0连接教程也要看，他的点击DriverSetup操作很快，不要漏了），短接点可以参考这里。获得解锁码搜华为工具箱即可解锁。\n刷入 TWRP (recovery)、刷rom（系统） 建议不要刷机软件一键刷机，都是一堆广告的系统。\n手机品牌官网下载对应机型的驱动，并在windows设备管理器确认连接。 twrp官网下载TWRP。（TWRP 类似于 windows PE，是修改系统的程序。也可以去https://unofficialtwrp.com下载，收录了全面的非官方TWRP，如果有广告拦截检测可以安装ublock插件。） 下载刷机软件和rom： 三星为例： 进入刷机模式，下载三星手机刷机的软件Odin和 tar格式的TWRP，然后用Odin（选择AP）刷进手机。可参考youtube视频。\n卡刷：在https://samfw.com/下载，放入手机存储，双清后安装即可。\n线刷：在https://samfirmtool.com/下载三星手机官方系统下载器SamFirm，然后使用Odin。\nSamFirm使用方法：\n小米为例： 在https://xiaomirom.com/下载刷机工具，下载酷安大神（例如：乌堆小透明）的ROM，或者欧版eu社区版ROM。然后按照此教程操作，安装选择默认即可，开机后卸载重装magisk。\n华为旧机为例： 在https://m.huaweirom.com/rom/找到对应机型的rom，我当时看到网站干净无广告就刷了，是可以用的。Fastboot模式运行run脚本就行了。\nroot github下载magisk放进手机储存卡（有人建议低版安卓用20.4版本），进入TWRP recovery安装，开机后安装magisk manager app即可。\n自动化 工具 识别方式 控件查找：可兼容所有机型，但是不能定位非原生安卓的对象（如 Unity3D 的游戏），或随机变化的控件（如安全键盘）。显然图像识别时必备的\n图像识别：可查找所有显示内容，且难以被检测。但可能有识别慢、识别结果不准确、多分辨率不兼容的问题，不过使用airtest可以缓解\n自动化工具有\nYyds.Auto：使用root深度掌控，内置yolo等ai模型，堪称最强方案，但部分app可能会对root设备监控 airtest：基于图像识别 appium：图像识别需自己实现 EasyClick：支持打包apk，收费 AutoX.js：支持打包apk，图像识别需自己实现 Hamibot：支持打包apk，可以浏览器远程控制 AiBote：办公自动化 Tasker、MacroDroid：单独app即可简单使用，收费 airtest（使用PC） 可支持自动化测试Android/Windows/iOS，详见官网及官方教程\n优点：图像识别+控件识别满足绝大部分自动化任务\n缺点：windows运行手机模拟器略卡，再映射到airtest IDE中更卡\n算法 Airtest算法介绍\n模板匹配 速度快 无法跨分辨率识别 屏幕没有结果也会匹配出不准确的结果 特征点匹配 跨分辨率识别（可跨设备） 不能识别纯文字、空白截图 技巧 截有特征的小图（多截空白背景图会使准确度下降） 有相同按钮时，把按钮全部截图再定位 基础 mumu模拟器连接示例 文件\u0026ndash;\u0026gt;新建脚本\u0026ndash;\u0026gt;.py纯Python(高级用户) Save Path： 文件保存路径 Log Directory： log保存路径 Devices：使用当前已连接的手机设备进行初始化 Project Root： 项目的父目录 坐标 绝对坐标：打开IDE的选项\u0026ndash;\u0026gt;设置\u0026ndash;\u0026gt;Device，勾选实时坐标显示显示鼠标在手机中的坐标 相对坐标：勾选实时坐标选项，再勾选相对坐标，显示鼠标在手机中的相对坐标（可跨分辨率），相对坐标*电脑分辨率=绝对坐标，点击鼠标右键可复制坐标信息 # 获取横屏电脑分辨率 height = G.DEVICE.display_info[\u0026#39;width\u0026#39;] width = G.DEVICE.display_info[\u0026#39;height\u0026#39;] # 已知相对坐标[0.3,0.55]，转换成绝对坐标 x2 = 0.3*width y2 = 0.55*height # 已知绝对坐标[311,1065]，转换成相对坐标 x1 = 311/width y1 = 1065/height 图像识别 touch(Template(r\u0026#34;tpl1598948415043.png\u0026#34;, target_pos=6)) # 参数 filename：截图路径 threshold：可信度，默认0.7 target_pos：点击位置，默认5（图像中心），1（左上角）~9（右下角） rgb：使用彩色识别 局部截图 from airtest.aircv import * screen = G.DEVICE.snapshot() # 局部截图，左上（0,160）右下（1067,551） part_screen = aircv.crop_image(screen,(0,160,1067,551)) # 保存局部截图到log文件夹中 try_log_screen(part_screen) API 点击：touch 滑动：swipe 等待截图出现：wait 存在某个截图：exists 文本输入：text 关键词操作：keyevent 截图：snapshot 等待：sleep 断言：assert_exists、assert_not_exists、assert_equal、assert_not_equal 文字识别 # 建议尝试Poco控件识别，小概率识别不准，就会影响程序运行 # 实际使用中，单纯文字识别准确率尚可，数字/符号识别不准（使用相应匹配规则也不行，需借助另外专业的库） import pytesseract from PIL import Image # 打开图片 image = Image.open(r\u0026#39;D:/test/score0.png\u0026#39;) # 识别 text = pytesseract.image_to_string(image) # 识别中文 text3 = pytesseract.image_to_string(image3,lang=\u0026#39;chi_sim\u0026#39;) # 点击ocr文字 def touch_ocr(target_text): # 已知相对坐标[0.13,0.01][0.27,0.04],局部截图 x1 = 0.13*height y1 = 0.01*width x2 = 0.27*height y2 = 0.04*width part_screen = aircv.crop_image(screen,(x1,y1,x2,y2)) # try_log_screen(part_screen) # 识别 text = pytesseract.image_to_string(part_screen,lang=\u0026#39;chi_sim\u0026#39;) # print(text) if target_text == text: x_center=(x1+x2)//2 y_center=(y1+y2)//2 touch(x_center,y_center) Tasker（使用andriod） 优点：性能好，无需电脑\n缺点：需root，只能处理简单任务\n基础 Tasker终身许可$3.49，可app单独使用，需root才顺畅使用，否则锁屏都不能解决\n设置：\n防止系统清理：进入系统最近任务界面，点击应用旁边的小锁，锁定应用不被系统清理 忽略电池优化：依次打开系统设置，应用和通知，应用管理，设置，特殊访问权限，忽略电池优化（直接在设置搜索栏搜索电池也能找到），允许忽略应用 设置启动管理：依次打开系统设置，电池，启动管理，关闭应用自动管理后弹出的对话框中选中：允许自启动，允许关联启动，允许后台活动 权限全部打开 shell shell命令很方便定义操作（点击的坐标可以在手机开发者选项中打开指针位置）。shell命令摘录网站\n#按键事件 input text \u0026lt;string\u0026gt; #输入文本 input keyevent 20 #向下 input keyevent 4 #返回 input keyevent 3 #Home input keyevent 6 #挂机 input keyevent 84 #搜索 input keyevent 26 #电源，息屏 input keyevent 24 #音量+ input keyevent 25 #音量- #模拟点击 input tap 100 100 #滑动 input swipe x1 y1 x2 y2 ms input swipe 100 100 400 100 300 #左往右 input swipe 400 100 100 100 300 #右往左 input swipe 100 100 100 400 300 #上往下 input swipe 100 400 100 100 300 #下往上 input swipe 100 100 400 400 300 #上往下斜 input swipe 400 400 100 100 300 #下往上斜 #长按 input swipe 100 100 100 100 1000 //在 100 100 位置长按 1000毫秒 ","date":"2021-11-24T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/phone-root/","title":"root手机和自动化"},{"content":"本github actions方法已于2022-07-15被封，详情请去仓库看文档 freenom自动续期 Fork luolongfei大佬的freenom库，再添加以下workflow： “点击展开完整代码”\r# 1、Fork 本仓库 # 2、在你 Fork 的本仓库下的 Settings \u0026gt; Secrets 画面追加以下几个 secret 变量： # FREENOM_USERNAME、FREENOM_PASSWORD、MULTIPLE_ACCOUNTS、MAIL_USERNAME、MAIL_PASSWORD、TO、MAIL_ENABLE、TELEGRAM_CHAT_ID、 # TELEGRAM_BOT_TOKEN、TELEGRAM_BOT_ENABLE、NOTICE_FREQ # （注：此处列出了所有可用变量，你只用追加你需要用到的变量，变量的具体含义请参考本项目的 .env 文件中的说明，一般情况下，.env 文件中的某些 # 项存在默认值，如果默认值满足你的需求则可不追加到 Secrets，它们会保持默认） # # 下面定时任务中的时间是世界时间，每天 10:00（本示例已改为2:00） 执行，由于创建虚拟环境会消耗时间，故任务会延迟 30 秒左右执行 # # @Author of yml configuration file: RouRouX \u0026lt;https://github.com/RouRouX\u0026gt; \u0026amp; mybsdc \u0026lt;mybsdc@gmail.com\u0026gt; # ###### end 说明 ###### name: Run it on action on: push: branches: - main schedule: - cron: 00 02 * * * workflow_dispatch: jobs: run-it: runs-on: ubuntu-18.04 name: Run it on action steps: - name: Checkout master uses: actions/checkout@v2 - name: Setup PHP uses: shivammathur/setup-php@v2 with: php-version: \u0026#39;7.2\u0026#39; - name: Setting run: | echo \u0026#39;Renew freenom domain name automatically.\u0026#39; echo \u0026#39;@Author of yml configuration file: RouRouX \u0026lt;https://github.com/RouRouX\u0026gt; \u0026amp; mybsdc \u0026lt;mybsdc@gmail.com\u0026gt;\u0026#39; echo \u0026#39;@Url: https://github.com/luolongfei/freenom\u0026#39; cp .env.example .env if [[ (\u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39; == \u0026#39;\u0026#39; || \u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39; == \u0026#39;\u0026#39;) \u0026amp;\u0026amp; \u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39; == \u0026#39;\u0026#39; ]]; then echo \u0026#39;你在 Github 的当前项目的 Settings \u0026gt; Secrets 画面没有设置任何与账户信息相关的 secret 值，无法正常运行，请添加新的 secret 值，设置 FREENOM_USERNAME 与 FREENOM_PASSWORD，或者设置 MULTIPLE_ACCOUNTS，以及 .env 文件中其它必要项，各项的具体含义与格式参考本项目 .env 文件中的说明。\u0026#39;; fi if [ \u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^FREENOM_USERNAME=.*$/FREENOM_USERNAME=\u0026#39;${{ secrets.FREENOM_USERNAME }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^FREENOM_PASSWORD=.*$/FREENOM_PASSWORD=\u0026#39;${{ secrets.FREENOM_PASSWORD }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MULTIPLE_ACCOUNTS=.*$/MULTIPLE_ACCOUNTS=\u0026#39;${{ secrets.MULTIPLE_ACCOUNTS }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_USERNAME }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_USERNAME=.*$/MAIL_USERNAME=\u0026#39;${{ secrets.MAIL_USERNAME }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_PASSWORD }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_PASSWORD=.*$/MAIL_PASSWORD=\u0026#39;${{ secrets.MAIL_PASSWORD }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TO }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TO=.*$/TO=\u0026#39;${{ secrets.TO }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.MAIL_ENABLE }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^MAIL_ENABLE=.*$/MAIL_ENABLE=\u0026#39;${{ secrets.MAIL_ENABLE }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_CHAT_ID }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_CHAT_ID=.*$/TELEGRAM_CHAT_ID=\u0026#39;${{ secrets.TELEGRAM_CHAT_ID }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_BOT_TOKEN }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_BOT_TOKEN=.*$/TELEGRAM_BOT_TOKEN=\u0026#39;${{ secrets.TELEGRAM_BOT_TOKEN }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.TELEGRAM_BOT_ENABLE }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^TELEGRAM_BOT_ENABLE=.*$/TELEGRAM_BOT_ENABLE=\u0026#39;${{ secrets.TELEGRAM_BOT_ENABLE }}\u0026#39;/\u0026#34; .env; fi if [ \u0026#39;${{ secrets.NOTICE_FREQ }}\u0026#39; != \u0026#39;\u0026#39; ]; then sed -i \u0026#34;s/^NOTICE_FREQ=.*$/NOTICE_FREQ=\u0026#39;${{ secrets.NOTICE_FREQ }}\u0026#39;/\u0026#34; .env; fi sed -i \u0026#34;s/^ON_GITHUB_ACTIONS=.*$/ON_GITHUB_ACTIONS=true/\u0026#34; .env - name: Run run: | php run # 以下为保活所需step - name: curl id: enable_workflow env: REST_TOKEN: ${{ secrets.REST_TOKEN }} API_ADDRESS: ${{ secrets.API_ADDRESS }} run: | echo \u0026#34;Enable Workflow Start...\u0026#34; curl -X PUT -H \u0026#34;Authorization: token $REST_TOKEN\u0026#34; \u0026#34;$API_ADDRESS\u0026#34; echo \u0026#34;Finished\u0026#34; 在你 Fork 的本仓库下的 Settings -\u0026gt; Secrets 页面追加以下几个secret秘密环境变量\n变量名 含义 默认值 是否必须 备注 FREENOM_USERNAME freenom 账户 - 是 只支持邮箱账户，不支持也不打算支持第三方社交账户登录 FREENOM_PASSWORD freenom 密码 - 是 某些特殊字符可能需要转义，在Github actions环境，请在除字母数字以外的字符前加上“\\”，否则可能无法正确读取密码，此举是防止某些字符在shell命令行被解析，举个例子，比如我密码是fei.,:!~@#$%^\u0026amp;*?233-_abcd^$$，那么写到秘密变量时就应写为fei\\.\\,\\:\\!\\~\\@\\#\\$\\%\\^\\\u0026amp;\\*\\?233\\-\\_abcd\\^\\$\\$。而在普通VPS环境，则只用在密码中的“#”或单双引号前加“\\”，请参考.env.example文件内的注释，应该没人会设置那么变态的密码吧 MULTIPLE_ACCOUNTS 多账户支持 - 否 多个账户和密码的格式必须是“\u0026lt;账户1\u0026gt;@\u0026lt;密码1\u0026gt;|\u0026lt;账户2\u0026gt;@\u0026lt;密码2\u0026gt;|\u0026lt;账户3\u0026gt;@\u0026lt;密码3\u0026gt;”，如果设置了多账户，上面的FREENOM_USERNAME和FREENOM_PASSWORD可不设置 MAIL_USERNAME 机器人邮箱账户 - 是 支持Gmail、QQ邮箱以及163邮箱，尽可能使用163邮箱或者QQ邮箱，而非之前推荐的Gmail。因为谷歌的安全机制，每次在新设备登录 Gmail 都会先被限制，需要手动解除限制才行，而Github Actions每次创建的虚拟环境都会分配一个新的设备IP，相当于每次都是从新设备登录Gmail，而我们不可能每次都去手动为Gmail解除登录限制，所以这种机制会导致无法发出通知邮件。具体的配置方法参考「 配置发信邮箱 」 MAIL_PASSWORD 机器人邮箱密码 - 是 Gmail填密码，QQ邮箱或163邮箱填授权码 TO 接收通知的邮箱 - 是 你自己最常用的邮箱，推荐使用QQ邮箱，用来接收机器人邮箱发出的域名相关邮件 MAIL_ENABLE 是否启用邮件推送功能 true 否 true：启用\nfalse：不启用\n默认启用，如果设为false，不启用邮件推送功能，则上面的MAIL_USERNAME、MAIL_PASSWORD、TO变量变为非必须，可不设置 TELEGRAM_CHAT_ID 你的chat_id - 否 通过发送/start给@userinfobot可以获取自己的id TELEGRAM_BOT_TOKEN 你的Telegram bot的token - 否 TELEGRAM_BOT_ENABLE 是否启用Telegram Bot推送功能 false 否 true：启用\nfalse：不启用\n默认不启用，如果设为true，则必须设置上面的TELEGRAM_CHAT_ID和TELEGRAM_BOT_TOKEN变量 NOTICE_FREQ 通知频率 1 否 0：仅当有续期操作的时候\n1：每次执行 REST_TOKEN 如后文所示 - 否 保活所需 API_ADDRESS 如后文所示 - 否 保活所需 （注：你只用关注上面表格中的必须项，非必须项可不设置，将保持默认值。更多相关变量的含义、格式以及默认值，请参考本项目的.env.example文件内的注释）\n启用 Actions ，完成。 保活 Fork zhzhzhy/Workflow-Keep-Alive库\n创建 sercets ：\n变量名 值 备注 REST_TOKEN 个人访问令牌（Personal access tokens） 个人资料照片-\u0026gt;设置-\u0026gt;Developer settings API_ADDRESS https://api.github.com/repos/{owner}/{target-repo}/actions/workflows/enable_workflow/enable 修改{owner}/{target-repo} 运行 github action。\n相互唤醒，再次在目标 repo 的工作流程中执行上述步骤，并添加所需 step（已在代码中注释）。\n附 github workflow 语法文档\n修改定时任务 —— Cron示例\n","date":"2021-11-19T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/freenom/","title":"freenom自动续期（废弃）"},{"content":"docker 安装docker：\n#更新apt包索引 sudo apt-get update #安装包以允许apt通过 HTTPS 使用存储库 sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release #添加Docker官方的GPG密钥 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg #设置稳定存储库 echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null #安装最新版本的Docker Engine和containerd sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io #hello-world 映像验证 sudo docker run hello-world # 使用脚本安装 curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh Dockerfile “点击展开go语言示例”\r# 这个参考示例来自李文周大佬的bluebell项目 FROM golang:alpine AS builder # 为我们的镜像设置必要的环境变量 ENV GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 # 移动到工作目录：/build WORKDIR /build # 复制项目中的 go.mod 和 go.sum文件并下载依赖信息 COPY go.mod . COPY go.sum . RUN go mod download # 将代码复制到容器中 COPY . . # 将我们的代码编译成二进制可执行文件 bluebell_app RUN go build -o bluebell_app . ################### # 接下来创建一个小镜像 ################### FROM debian:stretch-slim COPY ./wait-for.sh / COPY ./templates /templates COPY ./static /static COPY ./conf /conf # 从builder镜像中把/dist/app 拷贝到当前目录 COPY --from=builder /build/bluebell_app / RUN set -eux; \\ apt-get update; \\ apt-get install -y \\ --no-install-recommends \\ netcat; \\ chmod 755 wait-for.sh # 声明服务端口 EXPOSE 8084 # 需要运行的命令 #ENTRYPOINT [\u0026#34;/bluebell_app\u0026#34;, \u0026#34;conf/config.yaml\u0026#34;] 基础知识参考 以下简介节选自docker文档：\n**卷（volumes）**存储在由 Docker管理的主机文件系统（在 Linux 上的/var/lib/docker/volumes/ ）。卷完全由 Docker 管理，非 Docker 进程不应修改文件系统的这一部分。卷是在 Docker 中持久化数据的最佳方式。 # 将当前目录的相对路径挂载到/app目录中 volumes: - ./:/app docker compose 安装docker compose：\n#单独下载和安装 Compose，不装Docker CLI #下载 Docker Compose 的当前稳定版本 curl -SL https://github.com/docker/compose/releases/download/v2.7.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose #对二进制文件应用可执行权限 sudo chmod +x /usr/local/bin/docker-compose #测试安装 docker compose version # 脚本 curl -fsSL https://get.docker.com -o get-docker.sh \u0026amp;\u0026amp; \\ sudo sh get-docker.sh \u0026amp;\u0026amp; \\ docker -v \u0026amp;\u0026amp; \\ curl -SL https://github.com/docker/compose/releases/download/v2.7.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose \u0026amp;\u0026amp; \\ sudo chmod +x /usr/local/bin/docker-compose \u0026amp;\u0026amp; \\ docker compose version docker-compose.yaml “点击展开和折叠代码”\rversion: \u0026#39;3.7\u0026#39; services: mysql5.7: # 镜像名 image: \u0026#39;mysql:5.7\u0026#39; # 容器名(以后的控制都通过这个) container_name: mysql5.7 # 重启策略 restart: always environment: # 时区上海 TZ: Asia/Shanghai # root 密码 MYSQL_ROOT_PASSWORD: root # 初始化数据库(后续的初始化sql会在这个库执行) MYSQL_DATABASE: nacos_config # 初始化用户(不能是root 会报错, 后续需要给新用户赋予权限) MYSQL_USER: nacos # 用户密码 MYSQL_PASSWORD: nacos # 映射端口 ports: - 3306:3306 volumes: # 数据挂载 #- /root/mysql/data/:/var/lib/mysql/ # 配置挂载 #- /root/mysql/conf/:/etc/mysql/conf.d/ # 初始化目录挂载，注意此处我只跑了这个挂载，只是为了说明其他配置不应该数据初始化 - /root/mysql/init/:/docker-entrypoint-initdb.d/ command: # 将mysql8.0默认密码策略 修改为 原先 策略 (mysql8.0对其默认策略做了更改 会导致密码无法匹配) --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 networks: - proxy server: image: ghcr.io/USERNAME/server:master container_name: server ports: - 8082:8082 expose: - \u0026#34;8082\u0026#34; depends_on: - mysql5.7 restart: always volumes: - \u0026#39;./data:/data/\u0026#39; networks: - proxy web: image: ghcr.io/USERNAME/web:master container_name: web depends_on: - server restart: always ports: - 3000:3000 expose: - \u0026#34;3000\u0026#34; environment: - VIRTUAL_HOST=example.com - VIRTUAL_PORT=3000 - LETSENCRYPT_HOST=example.com - LETSENCRYPT_EMAIL=mail@example.com networks: - proxy networks: proxy: name: nginx-proxy external: true “点击展开nginx-proxy代码”\rversion: \u0026#39;3\u0026#39; services: nginx-proxy: image: jwilder/nginx-proxy container_name: nginx-proxy ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; volumes: - conf:/etc/nginx/conf.d - vhost:/etc/nginx/vhost.d - html:/usr/share/nginx/html - dhparam:/etc/nginx/dhparam - certs:/etc/nginx/certs:ro - /var/run/docker.sock:/tmp/docker.sock:ro restart: always networks: - nginxproxy labels: - \u0026#34;com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy\u0026#34; letsencrypt: image: jrcs/letsencrypt-nginx-proxy-companion container_name: nginx-proxy-le depends_on: - nginx-proxy volumes: - vhost:/etc/nginx/vhost.d - html:/usr/share/nginx/html - dhparam:/etc/nginx/dhparam:ro - certs:/etc/nginx/certs - acme:/etc/acme.sh - /var/run/docker.sock:/var/run/docker.sock:ro ################## # 由于LETSENCRYPT证书速率限制，可使用ZeroSSL # 注释掉web服务environment中的： - LETSENCRYPT_HOST=example.com - LETSENCRYPT_EMAIL=mail@example.com # 需添加如下environment environment: - ACME_CA_URI=https://acme.zerossl.com/v2/DV90 - ZEROSSL_API_KEY= ################## restart: always networks: - nginxproxy volumes: conf: vhost: html: dhparam: certs: acme: networks: nginxproxy: name: nginx-proxy external: true 基础知识参考 以下简介节选自docker compose文档：\nCompose 中的网络: Compose默认为您的应用程序设置单个网络。服务中的每个容器都加入默认网络。例如，假设您的应用程序是在一个名为myapp的目录，运行docker-compose up时会创建一个名为myapp_default的网络，服务中使用web和db的配置创建的容器会以web和db的名字加入myapp_default。\n但是，当你使用external（外部网络，例如你有2个或多个docker-compose.yml）时，Compose不会创建默认网络，你必须使用docker network create Your_Nerwork预先创建网络。\n注意：文档中示例写法错误，会报错\nnetworks: proxy: external: name: nginx-proxy 应写为:\nnetworks: proxy: name: nginx-proxy external: true 常用命令 Docker命令 docker run [可选参数] imagename #新建并启动容器 --name = \u0026#34;name\u0026#34; 容器取名 -it 交互模式进入容器 -d 后台启动容器 注意：一般后台启动要有前台的应用，否则很可能被守护程序杀掉 -p ip:主机端口:容器端口 #指定端口映射 -v或--volume /卷名称的路径:/容器中的挂载路径 查看： docker search xxx #搜索dockerhub-镜像 docker images [-a][-q] #列出本地主机的-镜像 -a 显示所有信息 -q 显示所有id docker ps [-a][-q] #显示当前正在运行的容器 -a 显示当前运行的容器，并显示历史运行过的容器 -q 只显示运行容器的编号 docker logs 容器id #日志 docker top 容器id #查看容器中进程信息 docker inspect 容器id #查看容器的详细信息 操作： docker build -t tag . #构建标签为tag的镜像 docker pull 镜像：版本号 #拉取-镜像 docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止容器 docker kill 容器id #强制停止容器 docker rm 容器id #删除停止状态的容器 docker rm -f 容器id #强制删除容器 docker rmi -f xxx #删除单个-镜像 docker rmi -f $(docker images -aq) #删除所有-镜像 docker stop $(docker ps -a -q) #停止所有容器运行 docker rm $(docker ps -a -q) #删除所有容器 docker network rm $(docker network ls -q) #删除所有network docker system prune --all --force --volumes #删除一切 exit 容器停止并退出 ctrl+p+q 容器不停止退出 docker exec -it mysql /bin/bash #进入正在执行的mysql容器 docker exec -it 容器名 /bin/sh #进入容器 docker exec -it 容器名 -c \u0026#34;apt-get update \u0026amp;\u0026amp; apt-get install -y vim\u0026#34; #进入容器安装vim编辑器 docker exec -it 容器名 -c \u0026#34; apk add --update vim\u0026#34; #进入alpine容器安装vim编辑器 docker inspect -f \u0026#39;{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}\u0026#39; [container_name_or_id] #查看容器ip 从容器拷贝内容到主机： docker cp 容器id: 路径 主机目的路径 #此处不必进入容器，容器可以是关闭的。 Docker-compose命令 docker-compose up -d # 在后台启动服务 docker-compose pull # 拉取 docker-compose -f docker-compose.yml up -d # 指定docker-compose.yml docker-compose -f docker-compose.yml pull # 指定docker-compose.yml，后同 查看： docker-compose ps # 查看正在运行中的容器 docker-compose ps -a # 查看所有编排容器，包括已停止的容器 docker-compose images # 列出Compose文件构建的镜像 docker-compose logs # 查看日志 docker-compose logs [serviceName] # 查看某服务的日志 docker-compose logs -f [serviceName] # 查看某服务的实时日志 操作： docker-compose stop # 停止服务 docker-compose start # 启动已经存在的服务 docker-compose pause [serviceName] # 暂停服务 docker-compose unpause [serviceName] # 恢复服务 docker-compose restart [serviceName] # 重启服务 docker-compose rm # 删除所有（停止状态的）服务容器 docker-compose down # 删除所有容器 docker-compose down --remove-orphans # 删除orphans容器 docker-compose config -q # 验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容 docker-compose exec --index=1 [serviceName] sh # 进入某服务的第1个容器执行命令 docker-compose --help # 帮助 actions自动化部署前后端分离项目 参考文章\n本文使用github actions + docker compose部署到github container registry（适用于中小型项目） 附：容器注册平台对比\n准备好你的dockerfile\n使用github actions “点击展开示例actions”\ron: push: branches: - master workflow_dispatch: env: REGISTRY: ghcr.io IMAGE_NAME: ${{ github.repository }} jobs: build-and-push-image: runs-on: ubuntu-latest permissions: contents: read packages: write strategy: matrix: node: [ \u0026#39;14\u0026#39; ] steps: - name: Checkout repository uses: actions/checkout@v2 - name: Setup node uses: actions/setup-node@v2 with: node-version: ${{ matrix.node }} - name: npm install run: | cd web #进入前端dockerfile目录 npm install - name: Set up QEMU uses: docker/setup-qemu-action@v1 - uses: docker/setup-buildx-action@v1 id: builder1 - uses: docker/setup-buildx-action@v1 id: builder2 - name: Log in to the Container registry uses: docker/login-action@v1 with: registry: ${{ env.REGISTRY }} username: ${{ github.actor }} password: ${{ secrets.GITHUB_TOKEN }} # 用于消毒标签，tag是此动作的重要功能之一，本示例没使用，请见文档 - name: Extract metadata (tags, labels) for Docker id: meta1 uses: docker/metadata-action@v3 with: images: ghcr.io/username/server # images地址 - name: Extract metadata (tags, labels) for Docker id: meta2 uses: docker/metadata-action@v3 with: images: ghcr.io/username/web # images地址 - name: Build and push Docker image 1 uses: docker/build-push-action@v2 with: builder: ${{ steps.builder1.outputs.name }} context: ./server # 服务端dockerfile目录 file: ./server/Dockerfile # 服务端dockerfile push: true tags: ${{ steps.meta1.outputs.tags }} labels: ${{ steps.meta1.outputs.labels }} cache-from: type=gha cache-to: type=gha,mode=max - name: Build and push Docker image 2 uses: docker/build-push-action@v2 with: builder: ${{ steps.builder2.outputs.name }} context: ./web # 前端dockerfile目录 file: ./web/Dockerfile # 前端dockerfile push: true tags: ${{ steps.meta2.outputs.tags }} labels: ${{ steps.meta2.outputs.labels }} cache-from: type=gha cache-to: type=gha,mode=max deploy: runs-on: ubuntu-latest needs: build-and-push-image steps: - uses: appleboy/ssh-action@master with: host: ${{ secrets.host }} #仓库设置中添加Secrets：HOST username: root password: ${{ secrets.PASSWORD }} #仓库设置中添加Secrets：PASSWORD port: 22 script: | echo $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin # 用户名 docker-compose -f docker-compose-nginx.yaml -f docker-compose-app.yaml pull # docker-compose名 docker-compose -f docker-compose-nginx.yaml -f docker-compose-app.yaml up -d # docker-compose名 # 此actions许多参数由github自动提供，无需添加，需修改的均已注释 在服务器上完成向 Container registry 验证\n具体操作：打开/etc/profile\nexport CR_PAT=YOUR_TOKEN source /etc/profile echo $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin 新建docker-compose-app.yaml和代理容器docker-compose-nginx.yaml,示例文档。如有不懂，请查看acme-companion和示例文档。最后，Issues中的实例可能会有帮助。 ","date":"2021-10-27T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/docker-compose/","title":"docker和docker-compose"},{"content":"git git命令 官网git备忘表\nsubmodule\ngit submodule add [git@github.com:xxx/submodule.git] [directory] # 添加子模块 git clone [git@github.com:xxx/submodule.git] [directory] --recurse-submodules # 克隆一个存储库,并自动更新仓库中所有子模块（更新可能不兼容，慎用） git submodule update # 更新 问题\n更新被拒绝，因为远程仓库包含您本地尚不存在的提交。 git push -u origin +master # 强制push gitmodules错误 删掉.git和.gitmodules重新初始化更容易。\npush脚本 #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master 公开仓库fork为私有仓库 fork一个公开仓库 使用github导入功能，写fork仓库的地址，并创建私有仓库 本地操作 git clone git@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git # 克隆到本地 git remote add upstream git@github.com:\u0026lt;original_owner\u0026gt;/\u0026lt;original_repo\u0026gt;.git # 添加上游(源)仓库用于更新 git remote set-url --push upstream DISABLE # 禁用推送到上游(源)仓库 如果上游(源)仓库有更新\ngit fetch upstream # 获取主分支的最新修改到本地 git merge upstream/master # 将upstream分支修改内容合并到本地master git remote -v可以看到： origin\tgit@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git (fetch) origin\tgit@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_repo\u0026gt;.git (push) upstream\tgit@github.com:\u0026lt;original_owner\u0026gt;/\u0026lt;original_repo\u0026gt;.git (fetch) upstream\tDISABLE (push) 拉取更新 git fetch upstream git merge upstream/master Linux 文件 i 键可以对文件进行修改， Esc + :+ wq 退出并保存修改之后的文件\nsudo gedit ~/File //编辑 touch File //新建文件 mkdir -p Folder/a/src //新建文件夹 sudo rm -r Folder //删除文件夹 安装包 apt sudo apt update \u0026amp;\u0026amp; apt upgrade //更新 dpkg --list //显示所有软件 sudo apt-get install 包名 //安装 sudo apt-get remove 包名 //卸载不删除配置文件 sudo apt-get --purge remove 包名 //软件及其配置文件一并删除 snap sudo snap list //列出已经安装的snap包 sudo snap install \u0026lt;snap name\u0026gt; //安装一个snap包 sudo snap refresh \u0026lt;snap name\u0026gt; //更新一个snap包，如果后面不加包的名字更新所有的snap包 sudo snap remove \u0026lt;snap name\u0026gt; //删除一个snap包 端口 sudo apt-get install lsof //安装lsof lsof -i:80 //查看80端口 kill -9 pid //强制杀进程 命令 local #用于声明局部变量 source systemctl stop service # 停止一个服务 systemctl daemon-reload # 重载所有修改过的配置文件 systemctl enable #将服务设置为每次开机启动 set -eux #用于脚本开头设置 #-e 若指令传回值不等于0，则立即退出shell。0表示没有错误 #-u 当执行时使用到未定义过的变量，则显示错误信息。 #-x 执行指令后，会先显示该指令及所下的参数。 grep 、sed、awk grep 、sed、awk被称为linux中的\u0026quot;三剑客\u0026quot;。\ngrep 更适合单纯的查找或匹配文本 sed 更适合编辑匹配到的文本 awk 更适合格式化文本，对文本进行较复杂格式处理 sed sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为\u0026quot;pattern space\u0026quot;，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。\n语法 sed [option] \u0026#39;command\u0026#39; fileName 选项\n-n 使用安静silent模式。在一般sed的用法中，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来\n-e 直接在指令列模式上进行 sed 的动作编辑\n-f 直接将 sed 的动作写在一个文件内，-f filename则可以执行filename内的sed命令\n-r 让sed命令支持扩展的正则表达式(默认是基础正则表达式)\n-i 直接修改读取的文件内容，而不是由屏幕输出\n命令\na\\：追加行，a\\的后面跟上字符串s(多行字符串可以用\\n分隔)，则会在当前选择的行的后面都加上字符串s\nc\\：替换行，c\\后面跟上字符串s(多行字符串可以用\\n分隔)，则会将当前选中的行替换成字符串s\ni\\：插入行，i\\后面跟上字符串s(多行字符串可以用\\n分隔)，则会在当前选中的行的前面都插入字符串s\nd：删除行delete，该命令会将当前选中的行删除\np：打印print，该命令会打印当前选择的行到屏幕上\ny：替换字符，通常y命令的用法是这样的：y/Source-chars/Dest-chars/，分割字符/可以用任意单字符代替，用Dest-chars中对应位置的字符替换掉Soutce-chars中对应位置的字符\ns：替换字符串，通常s命令的用法是这样的：1,$s/Regexp/Replacement/Flags，分隔字符/可以用其他任意单字符代替，用Replacement替换掉匹配字符串\n替换选项\n\\digit：Replacement中可含有后向引用中的\\digit(digit是1至9)，引用前面定义的子表达\n\u0026amp;：代表模版空间中的整个匹配部分\n\\L：将在其后的替换部分转换成小写字母，直到发现一个\\U或\\E，GNU扩展功能\n\\l：将下一个字符转换成小写字母，GNU扩展功能\n\\U：将在其后的替换部分转换成大写字母，直到发现一个\\L或\\E，GNU扩展功能\n\\u：将下一个字符转换成大写字母，GNU扩展功能\n\\E：停止由\\L或\\U指示开始的大小写转换，GNU扩展功能\n标志选项\ng：将用Replacement替换模版空间中所有匹配Regexp的部分，则不仅仅是第一个匹配部分\ndigit：只用Replacement替换模版空间中第digit(digit是1至9)个匹配Regexp的部分\np：若发生了替换操作，指示显示模版空间中新的数据\nw file-name：若发生了替换操作，指示将模版空间中新的数据写入指定的文件file-name中\ni：表示进行Regexp匹配时，是不区分大小写字母的\n示例 a命令 sed '1,$a\\add one' test.txt 从第一行到最后一行所有行后追加\u0026quot;add one\u0026quot;字符串行\nsed '/first/a\\add one' test.txt 在匹配到first行追加\u0026quot;add one\u0026quot;字符串行\ni命令 与a命令类似，只不过在匹配的行前面插入字符串行，不举例了。\nc命令 sed '1,$c\\add one' test.txt 从第一行到最后一行所有行替换为\u0026quot;add one\u0026quot;字符串行\nsed '/first/c\\add one' test.txt 将匹配到first行替换为\u0026quot;add one\u0026quot;字符串行\nd命令 sed '4,$d' test.txt 从第四行到最后一行全部删除\np命令 sed -n '/^first.*end$/p' test.txt 以first开头end结尾的所有行全部打印\ns命令 sed 's/line/text/g' test.txt 将所有行的line替换为text，g代表全局选项，没有g只替换所有行的第一个匹配项\nsed '/^first.*end$/s/line/text/g' test.txt 匹配以first开头end结尾的所有行，然后将line全部替换为text\nsed 's/\\(.*\\)line$/\\1/g' test.txt 本例中的\\(\\)中包裹的内容表示正则表达式的第n部分，.*表示任意字符串，所以此例相当于删除所有行末的line\n脚本语言备忘录 shell 原文地址\nname=\u0026#34;MyName\u0026#34; //定义变量 echo $name 或 echo ${name} //使用变量 val=`expr 2 + 2` #expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 echo \u0026#34;Total value : $val\u0026#34; 2\u0026gt;\u0026amp;1 把\u0026#34;标准错误输出\u0026#34;重定向到\u0026#34;标准输出\u0026#34; 特殊变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2 $# 传递给脚本或函数的参数个数总和 $* 传递给脚本或函数的所有参数，当被双引号 \u0026quot; \u0026quot; 包含时，所有的位置参数被看做一个字符串 $@ 传递给脚本或函数的所有参数，当被双引号 \u0026quot; \u0026quot; 包含时，每个位置参数被看做独立的字符串 $? 上个命令的退出状态，或函数的返回值 $$ 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。 测试符 描述 -eq，equal 等于 -ne，not equal 不等于 -gt，greater than 大于 -lt，lesser than 小于 -ge，greater or equal 大于或等于 -le，lesser or equal 小于或等于 -z 检测字符串长度是否为 0，为 0 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 待续\npython os 函数名 使用方法 getcwd() 返回当前工作目录 chdir(path) 改变工作目录 listdir(path=\u0026rsquo;.') 列举指定目录中的文件名（\u0026rsquo;.\u0026lsquo;表示当前目录，\u0026rsquo;..\u0026lsquo;表示上一级目录） mkdir(path) 创建单层目录，如该目录已存在抛出异常 makedirs(path) 递归创建多层目录，如该目录已存在抛出异常，注意：\u0026lsquo;E:\\a\\b\u0026rsquo;和\u0026rsquo;E:\\a\\c\u0026rsquo;并不会冲突 remove(path) 删除文件 rmdir(path) 删除单层目录，如该目录非空则抛出异常 removedirs(path) 递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常 rename(old, new) 将文件old重命名为new system(command) 运行系统的shell命令 walk(top) 遍历top路径以下所有的子目录，返回一个三元组：(路径, [包含目录], [包含文件])【具体实现方案请看：第30讲课后作业^_^】 以下是支持路径操作中常用到的一些定义，支持所有平台 os.curdir 指代当前目录（\u0026rsquo;.\u0026rsquo;） os.pardir 指代上一级目录（\u0026rsquo;..\u0026rsquo;） os.sep 输出操作系统特定的路径分隔符（Win下为\u0026rsquo;\\\u0026rsquo;，Linux下为\u0026rsquo;/\u0026rsquo;） os.linesep 当前平台使用的行终止符（Win下为\u0026rsquo;\\r\\n\u0026rsquo;，Linux下为\u0026rsquo;\\n\u0026rsquo;） os.name 指代当前使用的操作系统（包括：\u0026lsquo;posix\u0026rsquo;, \u0026rsquo;nt\u0026rsquo;, \u0026lsquo;mac\u0026rsquo;, \u0026lsquo;os2\u0026rsquo;, \u0026lsquo;ce\u0026rsquo;, \u0026lsquo;java\u0026rsquo;） os.path 函数名 使用方法 basename(path) 去掉目录路径，单独返回文件名 dirname(path) 去掉文件名，单独返回目录路径 join(path1[, path2[, \u0026hellip;]]) 将path1, path2各部分组合成一个路径名 split(path) 分割文件名与路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在 splitext(path) 分离文件名与扩展名，返回(f_name, f_extension)元组 getsize(file) 返回指定文件的尺寸，单位是字节 getatime(file) 返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getctime(file) 返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getmtime(file) 返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） 以下为函数返回 True 或 False exists(path) 判断指定路径（目录或文件）是否存在 isabs(path) 判断指定路径是否为绝对路径 isdir(path) 判断指定路径是否存在且是一个目录 isfile(path) 判断指定路径是否存在且是一个文件 islink(path) 判断指定路径是否存在且是一个符号链接 ismount(path) 判断指定路径是否存在且是一个挂载点 samefile(path1, paht2) 判断path1和path2两个路径是否指向同一个文件 BeautifulSoup from bs4 import BeautifulSoup html_doc = \u0026#34;\u0026#34;\u0026#34; \u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;story\u0026#34;\u0026gt;Once upon a time there were three little sisters; and their names were \u0026lt;a href=\u0026#34;http://example.com/elsie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026#34;http://example.com/lacie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Lacie\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026#34;http://example.com/tillie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link3\u0026#34;\u0026gt;Tillie\u0026lt;/a\u0026gt;; and they lived at the bottom of a well.\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;story\u0026#34;\u0026gt;...\u0026lt;/p\u0026gt; \u0026#34;\u0026#34;\u0026#34; # 解析html_doc soup = BeautifulSoup(html_doc, \u0026#39;html.parser\u0026#39;) # 按照标准的缩进格式的结构输出 print(soup.prettify()) # 选择元素 soup.title # \u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt; # 提取节点信息 soup.title.name # u\u0026#39;title\u0026#39; # 获取属性 soup.p.attrs # {\u0026#39;class\u0026#39;: [\u0026#39;title\u0026#39;], \u0026#39;name\u0026#39;: \u0026#39;Dormouse\u0026#39;} soup.p.attrs[\u0026#39;name\u0026#39;] # Dormouse # 获取文本内容 soup.title.get_text() soup.title.string # u\u0026#39;The Dormouse\u0026#39;s story\u0026#39; # 获取第一个P标签下的所有的子节点，children是迭代器，所以用list转换 list(soup.p.children) list(soup.p.children)[0].text # 获取前面和后面的兄弟节点，迭代器类型 list(soup.a.next_siblings) list(soup.a.previous_siblings) # 找到标签 soup.find(\u0026#39;title\u0026#39;) # \u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt; # 找到所有\u0026lt;a\u0026gt;标签的链接 for link in soup.find_all(\u0026#39;a\u0026#39;): print(link.get(\u0026#39;href\u0026#39;)) # CSS选择器 html_doc = \u0026#34;\u0026#34;\u0026#34; \u0026lt;div class=\u0026#34;panel\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;panel-heading\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;Hello World\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;panel-body\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;list\u0026#34; id=\u0026#34;list-1\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Foo\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Bar\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Jay\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;list list-samll\u0026#34; id=\u0026#34;list-2\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Foo\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Bar\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;element\u0026#34;\u0026gt;Jay\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026#34;\u0026#34;\u0026#34; print(soup.select(\u0026#39;.panel-heading\u0026#39;)) # 获取class为panel-heading的节点 print(soup.select(\u0026#39;ul li\u0026#39;)) # 获取ul下的li节点 print(soup.select(\u0026#39;#list-2 li\u0026#39;)) # 获取id为list-2下的li节点 print(soup.select(\u0026#39;ul\u0026#39;)) # 获取所有的ul节点 正则表达式 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n\u0026lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“`(. (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`( (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95 (?\u0026lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?\u0026lt;=95 (?\u0026lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?\u0026lt;!95 x|y 匹配x或y。例如，“`z [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \\d 匹配一个数字字符。等价于[0-9]。 \\D 匹配一个非数字字符。等价于[^0-9]。 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04\u0026amp;1”。正则表达式中可以使用ASCII编码。. *num* 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。 *n* 标识一个八进制转义值或一个向后引用。如果*n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n*为一个八进制转义值。 *nm* 标识一个八进制转义值或一个向后引用。如果*nm之前至少有nm个获得子表达式，则nm为向后引用。如果*nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则*nm将匹配八进制转义值nm*。 *nml* 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 一、校验数字的表达式 1. 数字：^[0-9]*$ 2. n位的数字：^\\d{n}$ 3. 至少n位的数字：^\\d{n,}$ 4. m-n位的数字：^\\d{m,n}$ 5. 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 10. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 12. 非零的负整数：^\\-[1-9][]0-9″*$ 或 ^-[1-9]\\d*$ 13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1. 汉字：^[\\u4e00-\\u9fa5]{0,}$ 2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3. 长度为3-20的所有字符：^.{3,20}$ 4. 由26个英文字母组成的字符串：^[A-Za-z]+$ 5. 由26个大写英文字母组成的字符串：^[A-Z]+$ 6. 由26个小写英文字母组成的字符串：^[a-z]+$ 7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20} 9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 11. 可以输入含有^%\u0026amp;’,;=?$\\”等字符：[^%\u0026amp;’,;=?$\\x22]+ 12. 禁止输入含有~的字符[^~\\x22]+ 其它： .*匹配除 \\n 以外的任何字符。 /[\\u4E00-\\u9FA5]/ 汉字 /[\\uFF00-\\uFFFF]/ 全角符号 /[\\u0000-\\u00FF]/ 半角符号 三、特殊需求表达式 1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%\u0026amp;=]*)?$ 4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 5. 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6. 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7. 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 12. 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 1.有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0″不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了+可以用*替代,如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\n1. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 2. 中文字符的正则表达式：[\\u4e00-\\u9fa5] 3. 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 4. 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 5. HTML标记的正则表达式：\u0026lt;(\\S*?)[^\u0026gt;]*\u0026gt;.*?\u0026lt;/\\1\u0026gt;|\u0026lt;.*? /\u0026gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 6. 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 7. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 8. 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 9. IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) 10. IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 11. IP-v4地址：\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b (提取IP地址时有用) 12. 校验IP-v6地址:(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 13. 子网掩码：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 14. 校验日期:^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。) 15. 抽取注释：\u0026lt;!–(.*?)–\u0026gt; 16. 查找CSS属性:^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 17. 提取页面超链接:(\u0026lt;a\\\\s*(?!.*\\\\brel=)[^\u0026gt;]*)(href=”https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?’.implode(‘|(?:www\\\\.)?’, $follow_list).’))[^” rel=”external nofollow” ]+)”((?!.*\\\\brel=)[^\u0026gt;]*)(?:[^\u0026gt;]*)\u0026gt; 18. 提取网页图片:\\\\\u0026lt; *[img][^\\\\\\\\\u0026gt;]*[src] *= *[\\\\”\\\\’]{0,1}([^\\\\”\\\\’\\\\ \u0026gt;]*) 19. 提取网页颜色代码:^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 20. 文件扩展名效验:^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?”\u0026lt;\u0026gt;|]+\\\\.txt(l)?$ 21. 判断IE版本：^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ ","date":"2021-07-22T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/command/","title":"常用命令"},{"content":"部分电脑配置记录 架构 windows-386 ：这些是针对 32 位 Windows 系统编译的 windows-amd64 ：这些是针对具有 AMD 或 Intel x86-64 架构的 64 位 Windows 系统编译的 windows-arm64 ：这些是针对具有 ARM 架构的 64 位 Windows 系统编译的\nwin10 config git git config --global http.proxy http://127.0.0.1:[port.http] git config --global https.proxy https://127.0.0.1:[port.http] 文件路径：C:\\Users\\[Username]\\.gitconfig\nTerminal（临时使用） set http_proxy=http://127.0.0.1:[port.http] #临时命令行代理 set https_proxy=http://127.0.0.1:[port.http] #临时命令行代理 VM Ubuntu config 代理 Windows中使用ipconfig查看WLAN 2的ip地址，ubuntu中进入“设置”-“网络”-“proxy”，在Socks Host里写入查到的ip地址\ngit config 默认保存在用户的主目录下的 .gitconfig 文件内 git config --global user.name \u0026#34;John Doe\u0026#34; #配置github账号用户名 git config --global user.email johndoe@example.com #配置邮箱 git ssh 代理 创建~/.ssh/config 文件：\nHost github.com User git ProxyCommand nc -v -x ip:port.socks %h %p #写自己ip 终端代理（临时使用）\n方法一：直接在命令前加proxychains\n方法二：在.bashrc最后加入：\nexport http_proxy=\u0026#34;http://ip:port.http\u0026#34; #写自己ip export https_proxy=\u0026#34;http://ip:port.http\u0026#34; #写自己ip source ~/.bashrc #使配置生效 VM Ubuntu升级 # 更新 sudo apt update sudo apt upgrade sudo reboot # 启动 GUI 更新向导 sudo update-manager -c update错误 N: 无法安全地用该源进行更新，所以默认禁用该源 cd /etc/apt/sources.list.d sudo rm -f * # 删除全部软件源 W: Failed to fetch http://archive.ubuntu.com/ 备份您的来源列表 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup\n打开/etc/apt/sources.list粘贴这里对应地区和版本的sources.list条目\n# DNS 设置 sudo vim /etc/resolv.conf # 使用Google DNS作为首选 DNS 服务器 nameserver 8.8.8.8 nameserver 8.8.4.4 VM Ubuntu克隆 1. 概念\n虚拟机克隆 完整克隆 是和原始虚拟机完全独立的一个备份，可以脱离原始虚拟机独立使用 链接克隆 需要和原始虚拟机共享同一虚拟磁盘文件，不能脱离原始虚拟机独立运行 虚拟机模板克隆 克隆虚拟机固然是快速部署虚拟机的利器，但是所有的虚拟机都可以克隆，被克隆的虚拟机也可以再次被克隆，长此以往系统就会崩毁，从而给管理员带来诸多的麻烦。模板就是解决此问题的最好的方法，即将一台经常发起克隆的虚拟机做成虚拟机模板，每次需要克隆类似的虚拟机时都通过模板发起 虚拟快照 快照是针对虚拟机的VMDK文件在某一时间点的\u0026quot;备份\u0026quot;，快照任务启动时，将冻结虚拟机源VMDK文件处于只读状态，同时创建出1个快照文件，今后所有修改的数据都会写入这个快照文件。一旦触发快照恢复操作。系统将放弃文件的内容，回滚到源VMDK文件的状态，实现快照恢复 2. 模板克隆过程\n关机 -\u0026gt; 创建快照 -\u0026gt; 虚拟机、设置、高级、启用模板模式 -\u0026gt; 右键虚拟机克隆 -\u0026gt; 从快照克隆 -\u0026gt; 完整克隆\n3. 解决IP相同问题\n在虚拟机的网络设置 -\u0026gt; 高级 -\u0026gt; 点击生成新的mac地址\ncd /etc/netplan sudo gedit 01-network-manager-all.yaml # 添加内容 network: ethernets: ens33: dhcp4: true # 动态ip开启 dhcp-identifier: mac # 将DHCP获取IP地址的标识改为mac version: 2 # 更新配置 sudo netplan apply Ubuntu安装go sudo apt install snap #安装snap，使用snap更易安装、更新 sudo snap install go --classic #安装go sudo vim /etc/profile #编辑profile export GOROOT=/snap/go #在最后一行添加 export PATH=$PATH:$GOROOT/bin source /etc/profile #保存 go version #验证 export GO111MODULE=on export GOPROXY=https://goproxy.cn #设置 go get 为国内源（无代理） IDEA 使用 教程1\n教程2\n不能输入中文（Ubuntu） 在idea.sh注释之后的首行添加\nexport XMODIFIERS=\u0026#34;@im=ibus\u0026#34; export GTK_IM_MODULE=\u0026#34;ibus\u0026#34; export QT_IM_MODULE=\u0026#34;ibus\u0026#34; goland.vmoptions添加-Drecreate.x11.input.method=true\nWin10 系统问题 文件夹分类管理 在要分类的文件夹下新建desktop.txt文件 [.ShellClassInfo] InfoTip=分类名称 另存为desktop.ini，保存类型：所有文件，编码：ANSI\n生效：文件夹属性 -\u0026gt; 自定义 -\u0026gt; 更改图标 -\u0026gt; 还原默认值\n文件夹查看 -\u0026gt; 分组依据 -\u0026gt; 选择备注\n修改删除：文件夹查看 -\u0026gt; 选项 -\u0026gt; 查看 -\u0026gt; 取消选中\u0026quot;隐藏受保护的操作系统文件（推荐）\u0026ldquo;可以看到ini文件\n文件删不掉 TASKKILL /IM explorer* /F # 关掉任务栏 explorer.exe # 开启任务栏 管理员权限 方法一： cmd -\u0026gt; 输入 gpedit.msc 方法二： 添加右键超级管理员权限，新建1.reg文件并运行\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell\\runas] @=\u0026#34;获取超级管理员所有权限\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Windows\\\\System32\\\\imageres.dll,101\u0026#34; \u0026#34;NoWorkingDirectory\u0026#34;=\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\*\\shell\\runas\\command] @=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F\u0026#34; \u0026#34;IsolatedCommand\u0026#34;=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F\u0026#34; [HKEY_CLASSES_ROOT\\exefile\\shell\\runas2] @=\u0026#34;获取超级管理员所有权限\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Windows\\\\System32\\\\imageres.dll,101\u0026#34; \u0026#34;NoWorkingDirectory\u0026#34;=\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\exefile\\shell\\runas2\\command] @=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F\u0026#34; \u0026#34;IsolatedCommand\u0026#34;=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\runas] @=\u0026#34;获取超级管理员所有权限\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Windows\\\\System32\\\\imageres.dll,101\u0026#34; \u0026#34;NoWorkingDirectory\u0026#34;=\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command] @=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; /r /d y \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F /t\u0026#34; \u0026#34;IsolatedCommand\u0026#34;=\u0026#34;cmd.exe /c takeown /f \\\u0026#34;%1\\\u0026#34; /r /d y \u0026amp;\u0026amp; icacls \\\u0026#34;%1\\\u0026#34; /grant administrators:F /t\u0026#34; 关闭安全通知 关闭Win10防火墙通知 控制面板 -\u0026gt; 安全与维护 -\u0026gt; 更改用户账户控制设置 -\u0026gt; 从不通知\n搜索\u0026quot;编辑组策略\u0026rdquo; -\u0026gt; 管理模板 -\u0026gt; windows组件 -\u0026gt; windows安全中心 -\u0026gt; 通知 -\u0026gt; 打开隐藏所有通知 -\u0026gt; 已启用\n从注册表彻底关闭 Windows安全中心 win+R输入regedit，定位到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SecurityHealthService，找到Start，修改数值数据3为4。\n关闭\u0026quot;打开文件-安全警告\u0026quot;弹框 控制面板-\u0026gt; internet选项 -\u0026gt; 安全 -\u0026gt; 自定义级别 -\u0026gt; 启用(不安全)\nWin10 资源管理器无限重启闪屏 安全模式开机\n长按开机键3次，选择【疑难解答】-【高级选项】-【启动设置】- 【重启】，在启动设置内， 按 4 或 F4 就可以进入安全模式了。\n更换本地账户、新建本地账户。\n开机后右键windows图标点击 powershell（管理员）\n在命令提示符(管理员)中复制粘贴输入以下指令：\nnet user User ****** /add (User是新建账户，******是新建的随机密码)　net localgroup administrators User /add (赋予该账号管理员权限)\n重启后按电源键息屏，再开启后可以切换到User账户，进去后一切正常，表示故障原因不在硬件和系统方面，肯定是第三方软件。\n新建文本粘贴以下代码\nWindows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\\LocalDumps\\explorer.exe] \u0026#34;DumpFolder\u0026#34;=hex(2):43,00,3a,00,5c,00,43,00,72,00,61,00,73,00,68,00,44,00,75,\\ 00,6d,00,70,00,73,00,00,00 重命名为1.reg，运行后会在C盘建立CrashDumps文件夹（路径C:\\CrashDumps），当系统闪屏后里面有后缀.dmp文件，把这个文件拖到Visual Studio里打开，可以排查相关的第三方软件的路径，挨个卸载。我放在vs里显示我IDM下载程序缺少二进制文件，卸载后完美进入系统。\n自用软件 win10优雅必备 Wallpaper Engine　# 壁纸，steam购买\nEverything + uTools　# 文件快捷搜索及工具\nquicker　# 鼠标便捷操作神器\nDeskGo　# 腾讯出品的桌面软件格子\nIDM　# 下载\nPowerShell：irm https://massgrave.dev/ias | iex Geek Uninstaller　# 卸载无残留\nclover　# 资源管理器多标签页\n火绒　# 屏蔽弹窗\nwin10 microsoft store工具\nWindows Terminal　#命令行 TranslucentTB　#任务栏透明 EarTrumpet　#音频管理 开发者实用工具\ntypora　# markdown记事本 joplin　# markdown多端同步 sourcetree　# Git 界面 DBeaver　# 连接数据库 Postman　# 接口测试 素材工具\nGIMP　# 图像处理 例：转换pdf，文件-\u0026gt;打开，导入分辨率填300,文件-\u0026gt;导出 Pr　# 视频剪辑 Ae　# 动画特效 Ps　# 图片处理 Ai　# 插图 安卓app 浏览器：Chrome、Edge\n影视：\n论坛：haopanyou.net（已失效） App：tg破解软件中文频道，搜#影视 网盘搜索：pan.qianfan.app VLC　# 局域网视频播放器 椒盐音乐　# 本地音乐播放器\n音乐标签　# 歌词 小说：\n阅读　# 酷安评论区可以找书源 笔趣阁 阅读：ReadEra、福昕PDF阅读器\n去除启动广告：跳过广告\n动态壁纸：星空视频壁纸\n手机控制\ntasker、hamibot　# 手机自动化 Moonlight　# 局域网投屏 AirDroid和AirMirror　# 手机远程控制手机 向日葵远程控制 文件管理\nzarchiver　# 文件管理和解压 猫头鹰文件　# 访问局域网文件 APK Extractor　# 提取apk ","date":"2021-07-18T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/config/","title":"环境配置和软件"},{"content":"准备 1.Ubuntu\nsudo apt update # 更新 2.github账号\n3.git配置 默认保存在用户的主目录下的 .gitconfig 文件内\ngit config --global user.name \u0026#34;John Doe\u0026#34; # 配置github账号用户名 git config --global user.email johndoe@example.com # 配置邮箱 4.连接github\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # 生成SSH Keys 此为新版 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; # 此为旧版 cat ~/.ssh/id_ed25519.pub # 复制 点击github右上角头像-\u0026gt; Settings -\u0026gt; SSH and GPG Keys -\u0026gt; New SSH key添加\nssh -T git@github.com # 验证连接，输入yes 官方文档\n5.git ssh 代理设置\n非必要步骤，如果有一天ssh push网速极慢但https push正常，可尝试此操作\n创建~/.ssh/config 文件：\nHost github.com User git ProxyCommand nc -v -x 127.0.0.1:10808 %h %p # 请修改127.0.0.1:10808 安装 snap install hugo --channel=extended # 安装hugo hugo version # 验证 hugo new site myblog # 创建博客 git init # 初始化 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 删掉themes文件夹，安装stack主题作为子模块 rm config.toml \u0026amp;\u0026amp; cp themes/hugo-theme-stack/exampleSite/config.yaml . # 使用主题的配置文件 把myblog/themes/hugo-theme-stack/exampleSite/content内容移到myblog/content使用主题示例文章\n本地预览： myblog下执行\nhugo server 浏览器打开：\nhttp://localhost:1313/ 部署 注：我将介绍使用github托管源码自动化部署，如果您仅在本地存放源码，提交public文件夹即可，无需使用下列方法。\n1.虽然博客内容全都能看到，但我们可能不太希望公开源码，不开放源码使用github pages需要创建2个仓库: 创建 username.github.io.source 仓库存放源码可设为私人仓库，创建 username.github.io 仓库作为公开仓库\ngit remote add origin git@github.com:******.github.io.source.git # 连接远程仓库。注意使用ssh连接，如果使用https连接每次都要输账号密码。 点击github右上角头像-\u0026gt; Settings -\u0026gt; Developer Settings-\u0026gt; Personal access tokens -\u0026gt; Generate new token （Note随意，Select scopes全选,复制token，我们这里使用Personal tokens比Deploy keys更方便）\n找到源码仓库Settings-\u0026gt; Secrets and variables -\u0026gt; Actions -\u0026gt; New repository secret （Name写PERSONAL_TOKEN，Value粘贴token）\n2.创建github actions的workflows自动部署文件：\nmkdir -p .github/workflows \u0026amp;\u0026amp; touch ~/myblog/.github/workflows/main.yml 粘贴脚本：\nname: github pages on: push: branches: - master jobs: deploy: runs-on: ubuntu-latest #可 使用指定版本，例：runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest # 可使用指定版本，例：hugo-version: \u0026#39;0.83.1\u0026#39; extended: true - name: Build run: hugo --gc --forceSyncStatic --minify --cleanDestinationDir - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} # PERSONAL_TOKEN是源码仓库secrets的name external_repository: username/username.github.io # Pages 远程仓库 publish_branch: master # 部署的分支 publish_dir: ./public commit_message: ${{ github.event.head_commit.message }} #cname: www.example.com # 使用自定义域名 只需更改external_repository: username/username.github.io 为你的github账户名，脚本详情\n3.在myblog文件夹下创建push.sh\ntouch push.sh 粘贴脚本：\n#!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master 在myblog下运行 sh push.sh命令。\n到此已完成部署，之后任何更新如上运行push脚本即可\n修改主题 此处仅列举常见需修改内容，更多内容请看stack主题文档\n本博客修改样式来自rmdhnreza\n更多定制文章可以参考这里\n主题配置 1.修改~/myblog/config.yaml\n1 baseurl: https://username.github.io # 改为自己的 2 languageCode: zh-CN # 中文编码 4 paginate: 10 # 文章分页数 5 title: Example Site # 博客名字 30 DefaultContentLanguage: zh-cn # 中文 34 hasCJKLanguage: true # 正确计数中、日、韩文语言的字数 48 since: 2021 52 published: 2006-01-02 # 日期格式 53 lastUpdated: 2006-01-02 # 更新日期格式 56 emoji: 🍥 # 头像角标 57 subtitle: # 博客名下的简介 61 src: img/avatar.png # 头像，myblog/themes/hugo-theme-stack/assets/img 135 name: \u0026#39;首页\u0026#39; # 改中文左侧菜单home 155 startLevel: 1 # 从文章1级标题使用文章目录 195 unsafe: true # 允许Markdown嵌入html 2.左侧菜单栏 ~/myblog/content/page用于左侧菜单，请自定义\n2 title: \u0026#39;关于\u0026#39; #中文左侧菜单about，后同 3.覆盖主题样式\n直接在~/myblog下复制rmdhnreza的assets和layouts文件夹。\n另外修改：\n~/myblog/assets/scss/variables.scss\nlink-background-color: 0, 255, 255 链接背景颜色 注：浏览器可能缓存样式，可使用无痕模式\n创建文章 hugo new post/文件夹名/index.md #创建文章 写文章：\n1.front matter:\n--- title: hugo使用stack主题搭建博客及部署 #标题 description: #副标题，此样式不可用 date: 2021-07-04 #日期 lastUpdated: 2021-07-27 #上次修改内容的日期 slug: hugo-blog #URL的尾部，用于文章地址 categories: #文章分类 - blog --- front matter仅列举本文使用，hugo front matter官方文档\n2.常见文章markdown语法：\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n`单行代码` `` 有`需用双反引号 ``\n```html\n多行代码\n```\n[链接](https://)\n\\ 写在特殊符号前为转义；写在行尾为换行\\\n*斜体*\n**加粗**\n~~删除线~~\n* 无序列表\n双空格* 子无序列表\n![图片描述](本地图片.jpg)\n表格\n| Italics | Bold | Code | | -------- | -------- | ------ | | *italics* | **bold** | `code` | shortcodes ./myblog/layouts/shortcodes\n{{\u0026lt; spoiler text=\u0026quot;点击展开和折叠代码\u0026quot; \u0026gt;}}\n```html\ncode\n```\n{{\u0026lt; /spoiler \u0026gt;}}\n{{\u0026lt; typography font=default size=\u0026quot;30px\u0026quot; style=\u0026quot;normal\u0026quot; weight=\u0026quot;bold\u0026quot; color=\u0026quot;blue\u0026quot;\u0026gt;}} 自定义字体 {{\u0026lt; /typography \u0026gt;}}\n# font　Google 字体\n# size　大小\n# style　normal正常， italic 斜体\n# weight　bold 加粗 ， lighter 更细\n{{\u0026lt; box info \u0026gt;}} Hello there, and have a nice day {{\u0026lt; /box \u0026gt;}} Hello there, and have a nice day\n{{\u0026lt; box warning \u0026gt;}} Hello there, and have a nice day {{\u0026lt; /box \u0026gt;}} Hello there, and have a nice day\n{{\u0026lt; box important \u0026gt;}} Hello there, and have a nice day {{\u0026lt; /box \u0026gt;}} Hello there, and have a nice day\n{{\u0026lt; box tip \u0026gt;}} Hello there, and have a nice day {{\u0026lt; /box \u0026gt;}} Hello there, and have a nice day\n评论系统 waline官方文档写得非常清楚，您只需 LeanCloud设置 和 部署到Vercel ，拿到URL\n然后修改~/myblog/config.yaml\n52 provider: waline #评论系统，本文示例使用waline 73 serverURL: https:// #评论系统URL用你自己的 执行sh push.sh即可\n自定义域名 在~/myblog/config.yaml修改baseurl: https://username.github.io\n在~/myblog/.github/workflows/main.yml最后一行取消注释并修改cname: https://example.com\n执行sh push.sh即可\n启用https：参考链接\n","date":"2021-07-03T00:00:00Z","permalink":"https://xiaoxiano.github.io/p/hugo-blog/","title":"hugo使用stack主题搭建博客及部署"}]